<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Achtung Kackhaufen!</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #222;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        #game-container {
            width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
        }
        canvas { }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <script>
// ================================================================
//  ACHTUNG KACKHAUFEN! - Das ultimative Hundehaufen-Abenteuer
// ================================================================

// === CONSTANTS ===
const GW = 800, GH = 500;
const GROUND_Y = 400;
const PLAYER_X = 180;

const COLORS = {
    HAIR: 0xC8A060, SKIN: 0xFFD4A3, EYE: 0x333333, MOUTH: 0xCC6644,
    SHIRT: 0xDD3333, PANTS: 0x3366AA, SHOES: 0x8B5E3C, LEASH: 0x886644,
    DACKEL: 0x8B4513, MOPS: 0xDEB887, LABRADOR: 0xDAA520, PUDEL: 0xEEEEEE, SCHAFER: 0x654321,
    POOP: 0x6B3410, POOP_L: 0x8B5E3C, POOP_GOLD: 0xFFD700,
    SIDEWALK: 0xBBBBBB, ROAD: 0x666666, GRASS: 0x55AA55, SKY: 0x87CEEB,
    GOLD: 0xFFD700, RED: 0xDD3333, WHITE: 0xFFFFFF, BLACK: 0x222222,
};

const COMBO_TEXTS = ['', '', 'DOPPELT!', 'COMBO x3!', 'MEGA COMBO!', 'KACK-COMBO!!'];
const OMA_LINES = ['Du Lümmel!', 'Räum das auf!', 'Warte nur!', 'Du Frechdachs!', 'Das gibt was hinter die Löffel!'];
const GAMEOVER_TEXTS = ['In der Kacke gelandet!', 'Ausgerutscht!', 'Das stinkt!', 'Voll reingetreten!'];
const TIPS = [
    'Tipp: Kacke einsammeln bringt Geld!',
    'Tipp: Die Oma ist schneller als sie aussieht!',
    'Tipp: Combos bringen Extra-Kohle!',
    'Tipp: Nicht in die Haufen treten!',
    'Tipp: Das Ordnungsamt kennt kein Pardon!',
];

const DOG_BREEDS = [
    { name: 'Wurst', breed: 'dackel', color: COLORS.DACKEL, poopRate: 0.4, w: 150, h: 80 },
    { name: 'Schnuffi', breed: 'mops', color: COLORS.MOPS, poopRate: 0.6, w: 130, h: 90 },
    { name: 'Bello', breed: 'labrador', color: COLORS.LABRADOR, poopRate: 0.5, w: 130, h: 90 },
    { name: 'Fifi', breed: 'pudel', color: COLORS.PUDEL, poopRate: 0.35, w: 130, h: 90 },
    { name: 'Sir Barksalot', breed: 'schafer', color: COLORS.SCHAFER, poopRate: 0.55, w: 130, h: 90 },
];

const LEVELS = [];
for (let i = 1; i <= 20; i++) {
    LEVELS.push({
        level: i,
        dogs: Math.min(i, 5),
        speed: 150 + i * 20,
        distance: 6000 + i * 800,
        poopGoal: 8 + i * 3,
        weather: i <= 2 ? 'sunny' : ['sunny','sunny','rain','snow','fog'][i % 5],
        obstacles: Math.min(1 + Math.floor(i / 2), 6),
        catChance: i >= 3 ? 0.02 : 0,
        omaAfter: i >= 2 ? 5 : 999,
        env: ['suburb','suburb','park','park','city','school','suburb','park','city','school'][i % 10],
    });
}

// === SAVE MANAGER ===
const SaveMgr = {
    _key: 'kackhaufen_save',
    load() {
        try { return JSON.parse(localStorage.getItem(this._key)) || this.defaults(); }
        catch(e) { return this.defaults(); }
    },
    defaults() { return { highscores: [], totalMoney: 0, maxLevel: 1, settings: { sound: true } }; },
    save(data) { try { localStorage.setItem(this._key, JSON.stringify(data)); } catch(e) {} },
    addHighscore(data, entry) {
        data.highscores.push(entry);
        data.highscores.sort((a,b) => b.money - a.money);
        data.highscores = data.highscores.slice(0, 10);
        this.save(data);
    }
};

// === SOUND MANAGER ===
const SndMgr = {
    ctx: null, muted: false, musicGain: null, musicOscs: [], _unlocked: false,
    init() {
        if (this.ctx) return;
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.5;
        this.masterGain.connect(this.ctx.destination);
        // iOS: AudioContext starts suspended, must be unlocked on user gesture
        if (this.ctx.state === 'suspended') {
            const unlock = () => {
                if (this._unlocked) return;
                this.ctx.resume().then(() => {
                    this._unlocked = true;
                    // Play a silent buffer to fully unlock iOS audio
                    const buf = this.ctx.createBuffer(1, 1, 22050);
                    const src = this.ctx.createBufferSource();
                    src.buffer = buf;
                    src.connect(this.ctx.destination);
                    src.start(0);
                });
            };
            document.addEventListener('touchstart', unlock, { once: false });
            document.addEventListener('touchend', unlock, { once: false });
            document.addEventListener('click', unlock, { once: false });
        } else {
            this._unlocked = true;
        }
    },
    resume() {
        if (!this.ctx) return;
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    _tone(freq, dur, type, vol, delay) {
        if (this.muted || !this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const t = this.ctx.currentTime + (delay || 0);
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = type || 'square';
        o.frequency.setValueAtTime(freq, t);
        g.gain.setValueAtTime((vol || 0.3), t);
        g.gain.exponentialRampToValueAtTime(0.001, t + dur);
        o.connect(g); g.connect(this.masterGain);
        o.start(t); o.stop(t + dur);
    },
    _noise(dur, vol, delay) {
        if (this.muted || !this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const t = this.ctx.currentTime + (delay || 0);
        const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * dur, this.ctx.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
        const s = this.ctx.createBufferSource();
        const g = this.ctx.createGain();
        s.buffer = buf;
        g.gain.setValueAtTime(vol || 0.1, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + dur);
        s.connect(g); g.connect(this.masterGain);
        s.start(t); s.stop(t + dur);
    },
    jump()    { this._tone(300, 0.15, 'square', 0.2); this._tone(500, 0.1, 'square', 0.15, 0.05); },
    collect() { this._tone(660, 0.08, 'square', 0.25); this._tone(880, 0.15, 'square', 0.2, 0.08); },
    poop()    { this._tone(100, 0.2, 'triangle', 0.3); this._noise(0.1, 0.1, 0.05); },
    bark()    { this._noise(0.08, 0.15); this._tone(400 + Math.random()*200, 0.1, 'sawtooth', 0.1); },
    siren()   { const t=this.ctx?this.ctx.currentTime:0; if(!this.ctx||this.muted)return; const o=this.ctx.createOscillator(),g=this.ctx.createGain(); o.type='square'; o.frequency.setValueAtTime(600,t); o.frequency.linearRampToValueAtTime(900,t+0.3); o.frequency.linearRampToValueAtTime(600,t+0.6); g.gain.setValueAtTime(0.15,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.6); o.connect(g); g.connect(this.masterGain); o.start(t); o.stop(t+0.6); },
    bonk()    { this._tone(200, 0.05, 'square', 0.4); this._tone(100, 0.2, 'triangle', 0.3, 0.05); this._noise(0.1, 0.2); },
    fanfare() { [0,0.12,0.24,0.36,0.48].forEach((d,i) => this._tone([523,659,784,1047,1319][i], 0.3, 'square', 0.2, d)); },
    sad()     { [0,0.2,0.4,0.6].forEach((d,i) => this._tone([400,350,300,200][i], 0.3, 'triangle', 0.2, d)); },
    combo()   { this._tone(440, 0.08, 'square', 0.2); this._tone(554, 0.08, 'square', 0.2, 0.06); this._tone(660, 0.12, 'square', 0.25, 0.12); },
    stomp()   { this._tone(200, 0.06, 'square', 0.3); this._tone(400, 0.1, 'square', 0.2, 0.06); this._tone(600, 0.15, 'square', 0.15, 0.12); },
    meow()    { const t=this.ctx?this.ctx.currentTime:0; if(!this.ctx||this.muted)return; const o=this.ctx.createOscillator(),g=this.ctx.createGain(); o.type='sine'; o.frequency.setValueAtTime(700,t); o.frequency.linearRampToValueAtTime(900,t+0.2); o.frequency.linearRampToValueAtTime(600,t+0.4); g.gain.setValueAtTime(0.2,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.5); o.connect(g); g.connect(this.masterGain); o.start(t); o.stop(t+0.5); },
    hiss()    { if(!this.ctx||this.muted)return; const t=this.ctx.currentTime; this._noise(0.25, 0.2); this._tone(1200, 0.15, 'sawtooth', 0.12); this._tone(900, 0.1, 'sawtooth', 0.08, 0.1); },
    click()   { this._tone(800, 0.05, 'square', 0.15); },
    startMusic(bpmOverride) {
        if (!this.ctx || this.muted) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        this.stopMusic();
        this.musicGain = this.ctx.createGain();
        this.musicGain.gain.value = 0.18;
        this.musicGain.connect(this.masterGain);
        const melody = [523,523,659,784,784,659,523,659, 523,523,659,784,784,659,523,0, 440,440,523,659,659,523,440,523, 392,392,523,659,659,523,440,523];
        const bass =   [131,131,131,131,196,196,196,196, 131,131,131,131,196,196,196,196, 110,110,110,110,131,131,131,131, 98,98,131,131,196,196,196,196];
        const bpm = bpmOverride || 160, noteLen = 60/bpm;
        const loopLen = melody.length * noteLen;
        const scheduleLoop = (startTime) => {
            melody.forEach((freq, i) => {
                if (freq === 0 || !this.musicGain) return;
                const t = startTime + i * noteLen;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                o.type = 'square'; o.frequency.value = freq;
                g.gain.setValueAtTime(0.3, t);
                g.gain.exponentialRampToValueAtTime(0.001, t + noteLen * 0.9);
                o.connect(g); g.connect(this.musicGain);
                o.start(t); o.stop(t + noteLen);
                this.musicOscs.push(o);
            });
            bass.forEach((freq, i) => {
                if (!this.musicGain) return;
                const t = startTime + i * noteLen;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                o.type = 'triangle'; o.frequency.value = freq;
                g.gain.setValueAtTime(0.5, t);
                g.gain.exponentialRampToValueAtTime(0.001, t + noteLen * 0.9);
                o.connect(g); g.connect(this.musicGain);
                o.start(t); o.stop(t + noteLen);
                this.musicOscs.push(o);
            });
            this._musicTimer = setTimeout(() => scheduleLoop(startTime + loopLen), (loopLen - 1) * 1000);
        };
        scheduleLoop(this.ctx.currentTime + 0.1);
    },
    stopMusic() {
        clearTimeout(this._musicTimer);
        this.musicOscs.forEach(o => { try { o.stop(); } catch(e){} });
        this.musicOscs = [];
        if (this.musicGain) { this.musicGain.disconnect(); this.musicGain = null; }
    },
    toggleMute() { this.muted = !this.muted; if (this.muted) this.stopMusic(); return this.muted; },
    // Boss fight sounds
    bossThrow()  { this._noise(0.12, 0.15); this._tone(300, 0.1, 'sine', 0.1, 0.05); this._tone(200, 0.08, 'sine', 0.08, 0.1); },
    bossHurt()   { this._tone(800, 0.05, 'square', 0.3); this._tone(600, 0.08, 'sawtooth', 0.2, 0.05); this._tone(400, 0.15, 'triangle', 0.25, 0.1); this._noise(0.08, 0.15, 0.05); },
    bossAngry()  { this._tone(80, 0.4, 'sawtooth', 0.25); this._tone(60, 0.5, 'triangle', 0.2, 0.1); this._noise(0.3, 0.1, 0.2); },
    bossDefeat() { this._noise(0.3, 0.3); this._tone(200, 0.15, 'sawtooth', 0.3); this._tone(100, 0.3, 'triangle', 0.25, 0.1); [0.4,0.52,0.64,0.76,0.88].forEach((d,i) => this._tone([523,659,784,1047,1319][i], 0.3, 'square', 0.2, d)); },
    startGoHomeMusic() {
        if (!this.ctx || this.muted) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        this.stopMusic();
        this.musicGain = this.ctx.createGain();
        this.musicGain.gain.value = 0.2;
        this.musicGain.connect(this.masterGain);
        // Happy walking-home jingle (major key, bouncy)
        const melody = [392,440,494,523, 523,494,440,392, 440,494,523,587, 659,587,523,0,
                        523,523,587,659, 659,587,523,494, 440,440,494,523, 523,0,392,0];
        const bass =   [131,131,131,131, 165,165,165,165, 175,175,175,175, 196,196,196,196,
                        131,131,131,131, 165,165,165,165, 175,175,175,175, 131,131,131,131];
        const bpm = 180, noteLen = 60/bpm;
        const loopLen = melody.length * noteLen;
        const scheduleLoop = (startTime) => {
            melody.forEach((freq, i) => {
                if (freq === 0 || !this.musicGain) return;
                const t = startTime + i * noteLen;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                o.type = 'square'; o.frequency.value = freq;
                g.gain.setValueAtTime(0.3, t);
                g.gain.exponentialRampToValueAtTime(0.001, t + noteLen * 0.85);
                o.connect(g); g.connect(this.musicGain);
                o.start(t); o.stop(t + noteLen);
                this.musicOscs.push(o);
            });
            bass.forEach((freq, i) => {
                if (!this.musicGain) return;
                const t = startTime + i * noteLen;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                o.type = 'triangle'; o.frequency.value = freq;
                g.gain.setValueAtTime(0.4, t);
                g.gain.exponentialRampToValueAtTime(0.001, t + noteLen * 0.85);
                o.connect(g); g.connect(this.musicGain);
                o.start(t); o.stop(t + noteLen);
                this.musicOscs.push(o);
            });
            this._musicTimer = setTimeout(() => scheduleLoop(startTime + loopLen), (loopLen - 1) * 1000);
        };
        scheduleLoop(this.ctx.currentTime + 0.1);
    },
    playerHit()  { this._tone(200, 0.05, 'square', 0.35); this._tone(100, 0.2, 'triangle', 0.3, 0.05); this._tone(80, 0.15, 'sawtooth', 0.15, 0.15); },
    startBossMusic() {
        if (!this.ctx || this.muted) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        this.stopMusic();
        this.musicGain = this.ctx.createGain();
        this.musicGain.gain.value = 0.18;
        this.musicGain.connect(this.masterGain);
        const melody = [330,330,392,330,294,330,392,440, 330,330,392,330,523,494,440,392, 294,294,330,294,262,294,330,392, 262,262,330,392,440,392,330,294];
        const bass =   [110,110,110,110,147,147,147,147, 110,110,110,110,131,131,131,131, 98,98,98,98,110,110,110,110, 87,87,87,87,98,98,98,98];
        const bpm = 200, noteLen = 60/bpm;
        const loopLen = melody.length * noteLen;
        const scheduleLoop = (startTime) => {
            melody.forEach((freq, i) => {
                if (freq === 0 || !this.musicGain) return;
                const t = startTime + i * noteLen;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                o.type = 'square'; o.frequency.value = freq;
                g.gain.setValueAtTime(0.3, t);
                g.gain.exponentialRampToValueAtTime(0.001, t + noteLen * 0.9);
                o.connect(g); g.connect(this.musicGain);
                o.start(t); o.stop(t + noteLen);
                this.musicOscs.push(o);
            });
            bass.forEach((freq, i) => {
                if (!this.musicGain) return;
                const t = startTime + i * noteLen;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                o.type = 'triangle'; o.frequency.value = freq;
                g.gain.setValueAtTime(0.5, t);
                g.gain.exponentialRampToValueAtTime(0.001, t + noteLen * 0.9);
                o.connect(g); g.connect(this.musicGain);
                o.start(t); o.stop(t + noteLen);
                this.musicOscs.push(o);
            });
            this._musicTimer = setTimeout(() => scheduleLoop(startTime + loopLen), (loopLen - 1) * 1000);
        };
        scheduleLoop(this.ctx.currentTime + 0.1);
    }
};

// === SPRITE HELPERS ===
function genTex(scene, key, w, h, drawFn) {
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    drawFn(ctx, w, h);
    scene.textures.addCanvas(key, canvas);
}

// Color utility: convert 0xRRGGBB to '#RRGGBB'
function hexC(c) { return '#' + (c & 0xFFFFFF).toString(16).padStart(6, '0'); }
function rgba(c, a) { const r = (c>>16)&0xFF, g=(c>>8)&0xFF, b=c&0xFF; return `rgba(${r},${g},${b},${a})`; }
function darken(c, amt) { const r=Math.max(0,((c>>16)&0xFF)-amt), g=Math.max(0,((c>>8)&0xFF)-amt), b=Math.max(0,(c&0xFF)-amt); return '#'+((r<<16)|(g<<8)|b).toString(16).padStart(6,'0'); }
function lighten(c, amt) { const r=Math.min(255,((c>>16)&0xFF)+amt), g=Math.min(255,((c>>8)&0xFF)+amt), b=Math.min(255,(c&0xFF)+amt); return '#'+((r<<16)|(g<<8)|b).toString(16).padStart(6,'0'); }

// === SPRITE GENERATION ===
function generateAllSprites(scene) {
    const C = COLORS;

    // --- BOY (80x120) side view facing right ---
    // Helper: draw a single C-shaped curl
    function drawCurl(ctx, cx, cy, size, angle, color) {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 0, size, -Math.PI * 0.7, Math.PI * 0.7, false);
        ctx.arc(size * 0.4, 0, size * 0.6, Math.PI * 0.7, -Math.PI * 0.7, true);
        ctx.fill();
        ctx.restore();
    }
    // Helper: curl tip that swings outward
    function drawCurlTip(ctx, cx, cy, dir, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(cx, cy - 4);
        ctx.quadraticCurveTo(cx + dir * 6, cy - 1, cx + dir * 5, cy + 3);
        ctx.quadraticCurveTo(cx + dir * 2, cy + 5, cx + dir * 1, cy + 2);
        ctx.quadraticCurveTo(cx + dir * 3, cy, cx + dir * 2, cy - 3);
        ctx.fill();
    }
    function drawBoyBase(ctx, w, h, legFrame, armFrame) {
        const af = armFrame || 0;
        const hOff = legFrame === 1 ? -3 : legFrame === 3 ? 3 : 0;
        ctx.save();
        // Head
        const headX = 38, headY = 22, headR = 14;
        const skinGrad = ctx.createRadialGradient(headX-2, headY-2, 2, headX, headY, headR);
        skinGrad.addColorStop(0, '#FFE0B8');
        skinGrad.addColorStop(1, '#FFD4A3');
        ctx.fillStyle = skinGrad;
        ctx.beginPath(); ctx.arc(headX, headY, headR, 0, Math.PI*2); ctx.fill();
        // Ear (will be covered by hair)
        ctx.fillStyle = '#EEC090';
        ctx.beginPath(); ctx.ellipse(headX-14, headY+2, 4, 5, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#DDB080';
        ctx.beginPath(); ctx.ellipse(headX-13, headY+2, 2, 3, 0, 0, Math.PI*2); ctx.fill();

        // === HAIR (voluminous curly locks - asymmetric, face clear) ===
        const hairBase = '#B8944A', hairLt = '#D4B06A', hairDk = '#8A6E35', hairDk2 = '#7A5E25';
        const hcx = headX + hOff * 0.15, hcy = headY;
        // Asymmetric silhouette - volume on back (left), face side (right) clear
        const hairGrad = ctx.createRadialGradient(hcx - 8, hcy - 4, 4, hcx - 6, hcy, 26);
        hairGrad.addColorStop(0, '#C8A060');
        hairGrad.addColorStop(0.5, hairBase);
        hairGrad.addColorStop(1, hairDk);
        ctx.fillStyle = hairGrad;
        ctx.beginPath();
        ctx.moveTo(hcx + 4, hcy - 18); // Part position (right of center)
        // Face side (right) - minimal, pulls back leaving face visible
        ctx.bezierCurveTo(hcx + 10, hcy - 18, hcx + 12, hcy - 14, hcx + 8, hcy - 8);
        ctx.bezierCurveTo(hcx + 4, hcy - 2, hcx - 2, hcy + 6, hcx - 6, hcy + 10);
        // Bottom curves toward back
        ctx.bezierCurveTo(hcx - 10, hcy + 14, hcx - 16, hcy + 20, hcx - 20, hcy + 18);
        // Back side (left) - very voluminous
        ctx.bezierCurveTo(hcx - 26, hcy + 20, hcx - 28, hcy + 12, hcx - 28, hcy + 4);
        ctx.bezierCurveTo(hcx - 28, hcy - 6, hcx - 26, hcy - 14, hcx - 22, hcy - 18);
        // Top back to part
        ctx.bezierCurveTo(hcx - 14, hcy - 20, hcx - 4, hcy - 20, hcx + 4, hcy - 18);
        ctx.fill();
        // Depth shadows at back side
        ctx.fillStyle = hairDk2;
        ctx.beginPath();
        ctx.moveTo(hcx - 22, hcy + 4);
        ctx.bezierCurveTo(hcx - 26, hcy + 8, hcx - 24, hcy + 14, hcx - 18, hcy + 18);
        ctx.bezierCurveTo(hcx - 16, hcy + 14, hcx - 19, hcy + 8, hcx - 20, hcy + 4);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(hcx - 24, hcy - 4);
        ctx.bezierCurveTo(hcx - 26, hcy + 2, hcx - 26, hcy + 8, hcx - 22, hcy + 12);
        ctx.bezierCurveTo(hcx - 20, hcy + 8, hcx - 22, hcy + 2, hcx - 22, hcy - 4);
        ctx.fill();
        // Individual curls - mostly on back side (left)
        drawCurl(ctx, hcx - 20, hcy + 2, 7, 0.3, hairLt);
        drawCurl(ctx, hcx - 16, hcy + 12, 6, -0.2, '#C8A060');
        drawCurl(ctx, hcx - 24, hcy + 6, 5, 0.6, hairLt);
        drawCurl(ctx, hcx - 12, hcy + 14, 6, -0.4, '#9A7E45');
        drawCurl(ctx, hcx - 22, hcy + 14, 7, 0.1, hairDk);
        drawCurl(ctx, hcx - 8, hcy - 10, 5, -0.3, '#C8A060');
        drawCurl(ctx, hcx - 14, hcy - 12, 6, -0.6, hairLt);
        drawCurl(ctx, hcx - 6, hcy + 8, 5, 0.4, hairLt);
        // One small curl on face side (above eye level only)
        drawCurl(ctx, hcx + 6, hcy - 12, 4, 0.5, '#C8A060');
        // Curl tips at bottom - back side only
        drawCurlTip(ctx, hcx - 18, hcy + 16, -1, '#C8A060');
        drawCurlTip(ctx, hcx - 10, hcy + 18, -1, hairLt);
        drawCurlTip(ctx, hcx - 24, hcy + 16, -1, hairBase);
        drawCurlTip(ctx, hcx - 4, hcy + 10, -1, '#C8A060');
        // Part line (animated - moves with running)
        const fo = hOff;
        ctx.strokeStyle = hairDk; ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(hcx + fo + 4, hcy - 18);
        ctx.quadraticCurveTo(hcx + fo + 2, hcy - 14, hcx + fo - 2, hcy - 8);
        ctx.stroke();
        // Gloss highlights (on top-back area)
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.ellipse(hcx - 8, hcy - 14, 12, 5, -0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#FFF8E0';
        ctx.beginPath(); ctx.arc(hcx - 20, hcy, 3, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(hcx - 12, hcy + 8, 2.5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(hcx - 6, hcy - 10, 2, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1.0;

        // === FACE FEATURES (on top of hair) ===
        // Nose
        ctx.fillStyle = '#FFD4A3';
        ctx.beginPath(); ctx.arc(headX+14, headY+4, 3, -0.5, 1.2); ctx.fill();
        // Eye white
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath(); ctx.ellipse(headX+5, headY-2, 5, 4, 0, 0, Math.PI*2); ctx.fill();
        // Iris
        ctx.fillStyle = '#5577AA';
        ctx.beginPath(); ctx.arc(headX+6, headY-1, 3, 0, Math.PI*2); ctx.fill();
        // Pupil
        ctx.fillStyle = '#222222';
        ctx.beginPath(); ctx.arc(headX+7, headY-1, 1.5, 0, Math.PI*2); ctx.fill();
        // Highlight
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath(); ctx.arc(headX+5, headY-3, 1.2, 0, Math.PI*2); ctx.fill();
        // Eyebrow
        ctx.strokeStyle = '#A08040'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(headX, headY-7); ctx.lineTo(headX+10, headY-6); ctx.stroke();
        // Pink cheek
        ctx.fillStyle = 'rgba(255,180,170,0.4)';
        ctx.beginPath(); ctx.arc(headX+10, headY+5, 4, 0, Math.PI*2); ctx.fill();
        // Mouth
        ctx.strokeStyle = '#CC6644'; ctx.lineWidth = 1.5; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(headX+6, headY+9); ctx.quadraticCurveTo(headX+10, headY+12, headX+13, headY+9); ctx.stroke();

        // === ANIMATED FOREHEAD STRAND (angular, on top of face) ===
        ctx.globalAlpha = 0.7;
        // Main strand - flat angular shape
        ctx.fillStyle = '#B8944A';
        ctx.beginPath();
        ctx.moveTo(headX - 14, headY - 19);
        ctx.lineTo(headX - 4, headY - 20);
        ctx.lineTo(headX + fo + 10, headY - 12);
        ctx.lineTo(headX + fo + 14, headY - 6);
        ctx.lineTo(headX + fo + 12, headY + 4);
        ctx.quadraticCurveTo(headX + fo + 10, headY + 6, headX + fo + 6, headY + 5);
        ctx.lineTo(headX + fo - 2, headY + 2);
        ctx.lineTo(headX + fo - 8, headY - 4);
        ctx.lineTo(headX - 12, headY - 12);
        ctx.closePath();
        ctx.fill();
        // Highlight stripe along the strand
        ctx.fillStyle = '#D4B06A';
        ctx.beginPath();
        ctx.moveTo(headX - 10, headY - 18);
        ctx.lineTo(headX - 2, headY - 19);
        ctx.lineTo(headX + fo + 8, headY - 10);
        ctx.lineTo(headX + fo + 10, headY - 4);
        ctx.lineTo(headX + fo + 6, headY + 2);
        ctx.lineTo(headX + fo, headY);
        ctx.lineTo(headX + fo - 4, headY - 4);
        ctx.lineTo(headX - 8, headY - 12);
        ctx.closePath();
        ctx.fill();
        // Dark edge for definition
        ctx.strokeStyle = '#8A6E35';
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.moveTo(headX + fo + 14, headY - 6);
        ctx.lineTo(headX + fo + 12, headY + 4);
        ctx.quadraticCurveTo(headX + fo + 10, headY + 6, headX + fo + 6, headY + 5);
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        // Neck
        ctx.fillStyle = '#FFD4A3';
        ctx.fillRect(headX-4, headY+12, 10, 6);

        // === PULLOVER (turquoise) ===
        const shirtGrad = ctx.createLinearGradient(20, 40, 55, 75);
        shirtGrad.addColorStop(0, '#22BBBB');
        shirtGrad.addColorStop(1, '#119999');
        ctx.fillStyle = shirtGrad;
        if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(22, 38, 30, 28, 4); ctx.fill(); }
        else { ctx.fillRect(22, 38, 30, 28); }
        // Collar
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(32, 37, 10, 3);

        // === BELT ===
        ctx.fillStyle = '#2A5090';
        ctx.fillRect(22, 65, 30, 3);
        ctx.fillStyle = '#4477BB';
        ctx.fillRect(35, 65, 4, 3);

        // === PANTS ===
        ctx.fillStyle = '#3366AA';
        ctx.fillRect(22, 68, 30, 14);

        // === ARMS ===
        if (af === 1) {
            // Near arm forward
            ctx.fillStyle = '#22BBBB';
            ctx.fillRect(50, 40, 8, 8);
            ctx.fillStyle = '#FFD4A3';
            ctx.fillRect(55, 46, 7, 12);
            // Far arm back
            ctx.fillStyle = '#119999';
            ctx.fillRect(18, 42, 6, 8);
            ctx.fillStyle = '#EEC090';
            ctx.fillRect(12, 48, 6, 10);
        } else if (af === 2) {
            // Near arm back
            ctx.fillStyle = '#22BBBB';
            ctx.fillRect(14, 40, 8, 8);
            ctx.fillStyle = '#FFD4A3';
            ctx.fillRect(8, 46, 7, 12);
            // Far arm forward
            ctx.fillStyle = '#119999';
            ctx.fillRect(52, 42, 6, 8);
            ctx.fillStyle = '#EEC090';
            ctx.fillRect(56, 48, 6, 10);
        } else {
            // Neutral
            ctx.fillStyle = '#22BBBB';
            ctx.fillRect(50, 40, 8, 10);
            ctx.fillStyle = '#FFD4A3';
            ctx.fillRect(50, 50, 8, 12);
        }

        // === LEGS + SHOES ===
        const shoeColor = '#8B5E3C';
        const soleColor = '#FFFFFF';
        if (legFrame === 0) {
            ctx.fillStyle = '#3366AA';
            ctx.fillRect(28, 82, 16, 20);
            ctx.fillStyle = shoeColor;
            if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(24, 100, 22, 10, [0,6,6,0]); ctx.fill(); }
            else ctx.fillRect(24, 100, 22, 10);
            ctx.fillStyle = soleColor;
            ctx.fillRect(24, 108, 22, 3);
        } else if (legFrame === 1) {
            // Far leg back
            ctx.fillStyle = '#2A5090';
            ctx.fillRect(20, 82, 12, 18);
            ctx.fillStyle = '#6B4527';
            ctx.fillRect(14, 98, 18, 8);
            ctx.fillStyle = soleColor;
            ctx.fillRect(14, 105, 18, 3);
            // Near leg forward
            ctx.fillStyle = '#3366AA';
            ctx.fillRect(38, 80, 14, 22);
            ctx.fillStyle = shoeColor;
            if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(36, 100, 22, 10, [0,6,6,0]); ctx.fill(); }
            else ctx.fillRect(36, 100, 22, 10);
            ctx.fillStyle = soleColor;
            ctx.fillRect(36, 108, 22, 3);
        } else if (legFrame === 2) {
            // Far leg forward
            ctx.fillStyle = '#2A5090';
            ctx.fillRect(38, 80, 12, 20);
            ctx.fillStyle = '#6B4527';
            ctx.fillRect(36, 98, 18, 8);
            ctx.fillStyle = soleColor;
            ctx.fillRect(36, 105, 18, 3);
            // Near leg back
            ctx.fillStyle = '#3366AA';
            ctx.fillRect(22, 82, 12, 18);
            ctx.fillStyle = shoeColor;
            if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(16, 98, 20, 10, [0,6,6,0]); ctx.fill(); }
            else ctx.fillRect(16, 98, 20, 10);
            ctx.fillStyle = soleColor;
            ctx.fillRect(16, 106, 20, 3);
        } else if (legFrame === 3) {
            // Wide stride
            ctx.fillStyle = '#2A5090';
            ctx.fillRect(14, 82, 12, 18);
            ctx.fillStyle = '#6B4527';
            ctx.fillRect(8, 98, 18, 8);
            ctx.fillStyle = soleColor;
            ctx.fillRect(8, 105, 18, 3);
            ctx.fillStyle = '#3366AA';
            ctx.fillRect(44, 82, 14, 20);
            ctx.fillStyle = shoeColor;
            if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(42, 100, 22, 10, [0,6,6,0]); ctx.fill(); }
            else ctx.fillRect(42, 100, 22, 10);
            ctx.fillStyle = soleColor;
            ctx.fillRect(42, 108, 22, 3);
        }
        ctx.restore();
    }

    // Boy run frames
    genTex(scene, 'boy_run_0', 80, 120, (ctx,w,h) => drawBoyBase(ctx,w,h,0,0));
    genTex(scene, 'boy_run_1', 80, 120, (ctx,w,h) => drawBoyBase(ctx,w,h,1,1));
    genTex(scene, 'boy_run_2', 80, 120, (ctx,w,h) => drawBoyBase(ctx,w,h,0,0));
    genTex(scene, 'boy_run_3', 80, 120, (ctx,w,h) => drawBoyBase(ctx,w,h,2,2));

    // Boy jump (80x120)
    genTex(scene, 'boy_jump', 80, 120, (ctx,w,h) => {
        ctx.save();
        const headX=38, headY=22, headR=14;
        // Head
        const skinGrad = ctx.createRadialGradient(headX-2,headY-2,2,headX,headY,headR);
        skinGrad.addColorStop(0,'#FFE0B8'); skinGrad.addColorStop(1,'#FFD4A3');
        ctx.fillStyle=skinGrad; ctx.beginPath(); ctx.arc(headX,headY,headR,0,Math.PI*2); ctx.fill();
        // Ear (covered by hair)
        ctx.fillStyle='#EEC090'; ctx.beginPath(); ctx.ellipse(headX-14,headY+2,4,5,0,0,Math.PI*2); ctx.fill();
        // Hair flies up during jump - asymmetric, more volume behind, face clear
        const hairBase='#B8944A',hairLt='#D4B06A',hairDk='#8A6E35';
        const hcx=headX, hcy=headY;
        // Asymmetric silhouette - blown up, back side bigger
        const hg=ctx.createRadialGradient(hcx-6,hcy-8,4,hcx-4,hcy-4,24);
        hg.addColorStop(0,'#C8A060'); hg.addColorStop(0.5,hairBase); hg.addColorStop(1,hairDk);
        ctx.fillStyle=hg;
        ctx.beginPath();
        ctx.moveTo(hcx+4,hcy-16);
        // Face side - minimal, pulled back
        ctx.bezierCurveTo(hcx+10,hcy-16,hcx+12,hcy-12,hcx+8,hcy-6);
        ctx.bezierCurveTo(hcx+4,hcy,hcx,hcy+4,hcx-4,hcy+6);
        // Bottom to back
        ctx.bezierCurveTo(hcx-10,hcy+10,hcx-16,hcy+12,hcx-20,hcy+10);
        // Back side - voluminous, blown upward
        ctx.bezierCurveTo(hcx-26,hcy+8,hcx-26,hcy,hcx-26,hcy-6);
        ctx.bezierCurveTo(hcx-26,hcy-14,hcx-22,hcy-20,hcx-14,hcy-20);
        // Top back to part
        ctx.bezierCurveTo(hcx-6,hcy-20,hcx,hcy-18,hcx+4,hcy-16);
        ctx.fill();
        // Curls - mostly back side
        drawCurl(ctx,hcx-20,hcy-6,7,-0.8,hairLt);
        drawCurl(ctx,hcx-16,hcy+4,6,0.3,'#C8A060');
        drawCurl(ctx,hcx-22,hcy-12,5,0.6,hairLt);
        drawCurl(ctx,hcx-8,hcy-14,6,-0.4,'#C8A060');
        drawCurl(ctx,hcx-12,hcy+8,5,0.2,hairDk);
        drawCurl(ctx,hcx-24,hcy+2,5,-0.3,'#9A7E45');
        drawCurl(ctx,hcx+4,hcy-12,4,0.5,'#C8A060');
        // Curl tips at back edges
        drawCurlTip(ctx,hcx-18,hcy+8,-1,'#C8A060');
        drawCurlTip(ctx,hcx-8,hcy+6,-1,hairBase);
        // Floating wisps
        ctx.fillStyle=hairLt;
        ctx.beginPath(); ctx.arc(hcx-8,hcy-18,3,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(hcx-16,hcy-16,2.5,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(hcx,hcy-16,2,0,Math.PI*2); ctx.fill();
        // Highlight
        ctx.globalAlpha=0.15; ctx.fillStyle='#FFFFFF';
        ctx.beginPath(); ctx.ellipse(hcx-10,hcy-14,10,5,-0.2,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha=1.0;
        // Face features ON TOP of hair
        ctx.fillStyle='#FFD4A3'; ctx.beginPath(); ctx.arc(headX+14,headY+4,3,-0.5,1.2); ctx.fill();
        ctx.fillStyle='#FFFFFF'; ctx.beginPath(); ctx.ellipse(headX+5,headY-2,5,5,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#5577AA'; ctx.beginPath(); ctx.arc(headX+6,headY-1,3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#222222'; ctx.beginPath(); ctx.arc(headX+7,headY-1,1.5,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FFFFFF'; ctx.beginPath(); ctx.arc(headX+5,headY-3,1.2,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#A08040'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(headX,headY-7); ctx.lineTo(headX+10,headY-8); ctx.stroke();
        ctx.fillStyle='rgba(255,180,170,0.4)'; ctx.beginPath(); ctx.arc(headX+10,headY+5,4,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#CC6644'; ctx.beginPath(); ctx.ellipse(headX+10,headY+10,4,3,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FFFFFF'; ctx.fillRect(headX+8,headY+8,3,2);
        // Neck
        ctx.fillStyle='#FFD4A3'; ctx.fillRect(headX-4,headY+12,10,6);
        // Pullover (turquoise)
        const sg=ctx.createLinearGradient(20,40,55,70); sg.addColorStop(0,'#22BBBB'); sg.addColorStop(1,'#119999');
        ctx.fillStyle=sg;
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(22,38,30,28,4);ctx.fill();}else ctx.fillRect(22,38,30,28);
        ctx.fillStyle='#FFFFFF'; ctx.fillRect(32,37,10,3);
        // Arms up
        ctx.fillStyle='#22BBBB'; ctx.fillRect(50,28,8,8);
        ctx.fillStyle='#FFD4A3'; ctx.fillRect(55,18,7,12);
        ctx.fillStyle='#119999'; ctx.fillRect(18,30,6,8);
        ctx.fillStyle='#EEC090'; ctx.fillRect(12,20,6,12);
        // Belt
        ctx.fillStyle='#2A5090'; ctx.fillRect(22,65,30,3);
        // Pants + tucked legs
        ctx.fillStyle='#3366AA'; ctx.fillRect(22,68,30,14);
        ctx.fillRect(30,82,18,14);
        ctx.fillRect(16,82,16,14);
        // Shoes tucked
        ctx.fillStyle='#8B5E3C'; ctx.fillRect(30,94,20,6);ctx.fillRect(14,94,16,6);
        ctx.fillStyle='#FFFFFF'; ctx.fillRect(30,99,20,2);ctx.fillRect(14,99,16,2);
        ctx.restore();
    });

    // Boy collect (90x100)
    genTex(scene, 'boy_collect', 90, 100, (ctx,w,h) => {
        ctx.save();
        const oy=10;
        const headX=42,headY=oy+16,headR=12;
        // Head
        ctx.fillStyle='#FFD4A3'; ctx.beginPath(); ctx.arc(headX,headY,headR,0,Math.PI*2); ctx.fill();
        // Eye focused
        ctx.fillStyle='#FFFFFF'; ctx.beginPath(); ctx.ellipse(headX+4,headY-2,4,3,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(headX+5,headY,2,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FFF'; ctx.beginPath(); ctx.arc(headX+4,headY-2,1,0,Math.PI*2); ctx.fill();
        // Nose
        ctx.fillStyle='#FFD4A3'; ctx.beginPath(); ctx.arc(headX+12,headY+3,3,-0.3,1); ctx.fill();
        // Mouth
        ctx.strokeStyle='#CC6644'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(headX+6,headY+7); ctx.lineTo(headX+10,headY+8); ctx.stroke();
        // Hair hanging down - asymmetric, more volume behind, face clear
        const hairBase='#B8944A',hairLt='#D4B06A',hairDk='#8A6E35';
        const hcx=headX, hcy=headY;
        // Asymmetric silhouette - hanging, back side bigger, face clear
        const hg=ctx.createRadialGradient(hcx-6,hcy,4,hcx-4,hcy+4,22);
        hg.addColorStop(0,'#C8A060'); hg.addColorStop(0.5,hairBase); hg.addColorStop(1,hairDk);
        ctx.fillStyle=hg;
        ctx.beginPath();
        ctx.moveTo(hcx+4,hcy-14);
        // Face side - very minimal
        ctx.bezierCurveTo(hcx+10,hcy-14,hcx+10,hcy-8,hcx+6,hcy-2);
        ctx.bezierCurveTo(hcx+2,hcy+4,hcx-4,hcy+8,hcx-8,hcy+12);
        // Bottom toward back
        ctx.bezierCurveTo(hcx-12,hcy+18,hcx-18,hcy+22,hcx-22,hcy+20);
        // Back side - voluminous, hanging down
        ctx.bezierCurveTo(hcx-26,hcy+18,hcx-24,hcy+10,hcx-24,hcy+2);
        ctx.bezierCurveTo(hcx-24,hcy-6,hcx-20,hcy-14,hcx-14,hcy-16);
        // Top back to part
        ctx.bezierCurveTo(hcx-6,hcy-18,hcx,hcy-16,hcx+4,hcy-14);
        ctx.fill();
        // Curls hanging down - back side
        drawCurl(ctx,hcx-18,hcy+8,6,-0.3,hairLt);
        drawCurl(ctx,hcx-12,hcy+14,5,0.2,'#C8A060');
        drawCurl(ctx,hcx-20,hcy+2,6,0.3,hairDk);
        drawCurl(ctx,hcx-8,hcy+10,5,-0.4,'#9A7E45');
        drawCurl(ctx,hcx-14,hcy-8,5,0.5,'#C8A060');
        drawCurl(ctx,hcx-22,hcy+12,5,-0.2,'#9A7E45');
        drawCurl(ctx,hcx+2,hcy-8,4,0.6,hairLt);
        // Short forehead strand (angular, only to eyebrow)
        ctx.fillStyle='#C8A060';
        ctx.beginPath();
        ctx.moveTo(hcx+2,hcy-12);
        ctx.lineTo(hcx+8,hcy-10);
        ctx.lineTo(hcx+8,hcy-4);
        ctx.lineTo(hcx+5,hcy-3);
        ctx.lineTo(hcx+2,hcy-6);
        ctx.closePath();
        ctx.fill();
        // Curl tips drooping - back side
        drawCurlTip(ctx,hcx-16,hcy+18,-1,'#C8A060');
        drawCurlTip(ctx,hcx-8,hcy+12,-1,hairBase);
        // Highlight
        ctx.globalAlpha=0.12; ctx.fillStyle='#FFFFFF';
        ctx.beginPath(); ctx.ellipse(hcx-8,hcy-10,10,4,-0.2,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha=1.0;
        // Face features on top
        ctx.fillStyle='#FFD4A3'; ctx.beginPath(); ctx.arc(headX+12,headY+3,3,-0.3,1); ctx.fill();
        ctx.fillStyle='#FFFFFF'; ctx.beginPath(); ctx.ellipse(headX+4,headY-2,4,3,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(headX+5,headY,2,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FFF'; ctx.beginPath(); ctx.arc(headX+4,headY-2,1,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#CC6644'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(headX+6,headY+7); ctx.lineTo(headX+10,headY+8); ctx.stroke();
        // Neck
        ctx.fillStyle='#FFD4A3'; ctx.fillRect(headX-3,headY+10,8,5);
        // Pullover (turquoise, hunched)
        ctx.fillStyle='#22BBBB';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(24,oy+28,28,20,3);ctx.fill();}else ctx.fillRect(24,oy+28,28,20);
        // Arm reaching with bag
        ctx.fillStyle='#22BBBB'; ctx.fillRect(52,oy+28,8,8);
        ctx.fillStyle='#FFD4A3'; ctx.fillRect(58,oy+32,10,8);
        // Bag
        ctx.fillStyle='#228822';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(66,oy+34,14,16,3);ctx.fill();}else ctx.fillRect(66,oy+34,14,16);
        ctx.fillStyle='#44AA44'; ctx.beginPath(); ctx.arc(73,oy+40,3,0,Math.PI*2); ctx.fill();
        // Far arm
        ctx.fillStyle='#119999'; ctx.fillRect(20,oy+32,6,8);
        // Belt
        ctx.fillStyle='#2A5090'; ctx.fillRect(24,oy+48,28,3);
        // Pants crouching
        ctx.fillStyle='#3366AA'; ctx.fillRect(22,oy+51,26,14);
        ctx.fillRect(18,oy+62,18,14);
        // Shoes
        ctx.fillStyle='#8B5E3C'; ctx.fillRect(14,oy+74,24,8);
        ctx.fillStyle='#FFFFFF'; ctx.fillRect(14,oy+81,24,3);
        ctx.restore();
    });

    // Boy slide (120x70)
    genTex(scene, 'boy_slide', 120, 70, (ctx,w,h) => {
        ctx.save();
        const oy=20;
        // Shoes (left)
        ctx.fillStyle='#8B5E3C'; ctx.fillRect(0,oy+8,14,10);
        ctx.fillStyle='#FFF'; ctx.fillRect(0,oy+17,14,3);
        // Pants
        ctx.fillStyle='#3366AA'; ctx.fillRect(12,oy+6,22,14);
        // Belt
        ctx.fillStyle='#2A5090'; ctx.fillRect(32,oy+8,3,12);
        // Pullover (turquoise)
        const sg=ctx.createLinearGradient(35,oy+4,70,oy+18); sg.addColorStop(0,'#22BBBB'); sg.addColorStop(1,'#119999');
        ctx.fillStyle=sg; ctx.fillRect(34,oy+4,28,16);
        // Arm forward
        ctx.fillStyle='#FFD4A3'; ctx.fillRect(60,oy+12,12,8);
        // Head
        ctx.fillStyle='#FFD4A3'; ctx.beginPath(); ctx.arc(78,oy+4,12,0,Math.PI*2); ctx.fill();
        // Hair blown backward - curly locks trailing behind, face clear
        const hairBase='#B8944A',hairLt='#D4B06A',hairDk='#8A6E35';
        // Main mass behind head (wind pushes all curls back to the left)
        const hg=ctx.createRadialGradient(68,oy-4,4,66,oy-2,22);
        hg.addColorStop(0,'#C8A060'); hg.addColorStop(0.5,hairBase); hg.addColorStop(1,hairDk);
        ctx.fillStyle=hg;
        ctx.beginPath();
        ctx.moveTo(82,oy-6);
        // Face side (right) - minimal, wind blows hair back
        ctx.bezierCurveTo(84,oy-10,82,oy-14,78,oy-14);
        // Top and back - lots of volume trailing left
        ctx.bezierCurveTo(72,oy-18,64,oy-18,56,oy-14);
        ctx.bezierCurveTo(50,oy-10,48,oy-4,50,oy+2);
        // Bottom back
        ctx.bezierCurveTo(52,oy+6,58,oy+8,66,oy+6);
        // Under head to face side
        ctx.bezierCurveTo(72,oy+4,78,oy+2,82,oy-6);
        ctx.fill();
        // Trailing curls behind (to the left)
        drawCurl(ctx,56,oy-8,6,0.4,hairLt);
        drawCurl(ctx,52,oy,5,-0.3,'#C8A060');
        drawCurl(ctx,62,oy-14,5,0.6,'#C8A060');
        drawCurl(ctx,70,oy-14,4,-0.5,hairLt);
        drawCurl(ctx,58,oy+4,4,0.2,hairDk);
        drawCurl(ctx,66,oy+2,5,0.3,'#9A7E45');
        // Curl tips trailing left
        drawCurlTip(ctx,50,oy-4,-1,'#C8A060');
        drawCurlTip(ctx,52,oy+4,-1,hairBase);
        // Highlight
        ctx.globalAlpha=0.15; ctx.fillStyle='#FFFFFF';
        ctx.beginPath(); ctx.ellipse(66,oy-12,10,4,0,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha=1.0;
        // Face features on top of hair
        ctx.fillStyle='#FFD4A3'; ctx.beginPath(); ctx.arc(90,oy+6,3,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#333'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(80,oy); ctx.lineTo(84,oy+4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(84,oy); ctx.lineTo(80,oy+4); ctx.stroke();
        ctx.strokeStyle='#CC6644'; ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.moveTo(86,oy+8); ctx.lineTo(90,oy+8); ctx.stroke();
        // Poop on face
        ctx.fillStyle='#6B3410';
        ctx.beginPath(); ctx.arc(88,oy+2,5,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#8B5E3C'; ctx.beginPath(); ctx.arc(90,oy,3,0,Math.PI*2); ctx.fill();
        ctx.restore();
    });

    // --- DOGS ---
    // Helper: draw a rounded, thick dog leg with paw
    function drawDogLeg(ctx, x, y, legW, legH, color, pawColor) {
        // Upper leg (thicker)
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.ellipse(x + legW/2, y + legH*0.4, legW/2 + 1, legH*0.45, 0, 0, Math.PI*2);
        ctx.fill();
        // Paw (round)
        ctx.fillStyle = pawColor || color;
        ctx.beginPath();
        ctx.ellipse(x + legW/2, y + legH - 2, legW/2 + 2, 5, 0, 0, Math.PI*2);
        ctx.fill();
    }

    function drawDog(ctx, w, h, breed, frame) {
        const info = DOG_BREEDS.find(d => d.breed === breed);
        const c = info.color;
        const col = hexC(c);
        const dk = darken(c, 40);
        const lt = lighten(c, 35);
        const isPoop = frame === 2;
        const legOff = frame === 1 ? 4 : 0;

        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (breed === 'dackel') {
            // DACHSHUND: Very long sausage body, very short legs, 150x80
            // Shadow on ground
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath(); ctx.ellipse(75, 76, 50, 4, 0, 0, Math.PI*2); ctx.fill();
            // Belly (lighter underside)
            ctx.fillStyle = lt;
            ctx.beginPath(); ctx.ellipse(72, 42, 48, 14, 0, 0, Math.PI*2); ctx.fill();
            // Body - big sausage shape
            const bodyGrad = ctx.createLinearGradient(20, 18, 20, 52);
            bodyGrad.addColorStop(0, dk); bodyGrad.addColorStop(0.3, col); bodyGrad.addColorStop(0.7, col); bodyGrad.addColorStop(1, lt);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath(); ctx.ellipse(72, 36, 48, 18, 0, 0, Math.PI*2); ctx.fill();
            // Chest bump
            ctx.fillStyle = lt;
            ctx.beginPath(); ctx.ellipse(30, 42, 12, 10, 0.2, 0, Math.PI*2); ctx.fill();
            // Legs (short and stumpy!)
            const legY = 48;
            const legH = 20 + legOff;
            const legH2 = 20 - legOff;
            if (isPoop) {
                drawDogLeg(ctx, 26, legY, 12, 18, col, dk);
                drawDogLeg(ctx, 100, legY, 12, 26, col, dk);
                // Poop coming out
                ctx.fillStyle = '#6B3410';
                ctx.beginPath(); ctx.ellipse(118, 68, 7, 5, 0, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(118, 63, 5, 4, 0, 0, Math.PI*2); ctx.fill();
            } else {
                drawDogLeg(ctx, 24, legY, 12, legH, col, dk);
                drawDogLeg(ctx, 38, legY, 12, legH2, col, dk);
                drawDogLeg(ctx, 90, legY, 12, legH2, col, dk);
                drawDogLeg(ctx, 104, legY, 12, legH, col, dk);
            }
            // Neck
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.ellipse(32, 32, 12, 14, -0.2, 0, Math.PI*2); ctx.fill();
            // Head (round)
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.arc(24, 24, 14, 0, Math.PI*2); ctx.fill();
            // Snout (long, wedge shape protruding forward)
            ctx.fillStyle = col;
            ctx.beginPath();
            ctx.moveTo(16, 22); ctx.lineTo(6, 24); ctx.lineTo(4, 28);
            ctx.lineTo(6, 33); ctx.lineTo(16, 34); ctx.closePath(); ctx.fill();
            // Lighter snout underside
            ctx.fillStyle = lt;
            ctx.beginPath();
            ctx.moveTo(16, 28); ctx.lineTo(6, 30); ctx.lineTo(6, 33);
            ctx.lineTo(16, 34); ctx.closePath(); ctx.fill();
            // Nose (round bump at tip)
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.ellipse(5, 26, 4, 3.5, 0, 0, Math.PI*2); ctx.fill();
            // Mouth line
            ctx.strokeStyle = dk; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(6, 33); ctx.lineTo(14, 35); ctx.stroke();
            // Eye
            if (isPoop) {
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(20, 18); ctx.lineTo(28, 24); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(28, 18); ctx.lineTo(20, 24); ctx.stroke();
            } else {
                ctx.fillStyle = '#FFF';
                ctx.beginPath(); ctx.ellipse(23, 20, 5, 4, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#442200';
                ctx.beginPath(); ctx.arc(24, 20, 3, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.beginPath(); ctx.arc(22, 18, 1.5, 0, Math.PI*2); ctx.fill();
            }
            // Floppy ears (big, hanging down)
            ctx.fillStyle = dk;
            ctx.beginPath();
            ctx.moveTo(18, 14);
            ctx.bezierCurveTo(8, 10, 4, 28, 10, 38);
            ctx.bezierCurveTo(14, 32, 16, 22, 18, 14);
            ctx.closePath(); ctx.fill();
            // Eyebrow
            ctx.fillStyle = dk;
            ctx.beginPath(); ctx.ellipse(24, 16, 5, 2, -0.1, 0, Math.PI*2); ctx.fill();
            // Tongue
            if (!isPoop) {
                ctx.fillStyle = '#FF7788';
                ctx.beginPath(); ctx.ellipse(10, 38, 4, 5, 0.3, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#FF5566';
                ctx.beginPath(); ctx.ellipse(10, 40, 3, 3, 0.3, 0, Math.PI*2); ctx.fill();
            }
            // Collar
            ctx.fillStyle = '#CC3333';
            ctx.beginPath(); ctx.ellipse(32, 34, 8, 4, 0.1, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(36, 36, 3, 0, Math.PI*2); ctx.fill();
            // Tail (thin, wagging up)
            ctx.strokeStyle = dk; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(120, 30);
            ctx.bezierCurveTo(128, 22, 134, 14, 140, 8 + (frame===1?4:0));
            ctx.stroke();

        } else if (breed === 'mops') {
            // PUG: Very round body, huge flat face, stubby legs, 130x90
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath(); ctx.ellipse(65, 86, 35, 4, 0, 0, Math.PI*2); ctx.fill();
            // Body - very round and chubby
            const bodyGrad = ctx.createLinearGradient(60, 22, 60, 70);
            bodyGrad.addColorStop(0, dk); bodyGrad.addColorStop(0.3, col); bodyGrad.addColorStop(0.7, lt); bodyGrad.addColorStop(1, dk);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath(); ctx.ellipse(68, 44, 32, 26, 0, 0, Math.PI*2); ctx.fill();
            // Light belly
            ctx.fillStyle = lt;
            ctx.beginPath(); ctx.ellipse(64, 52, 20, 14, 0.1, 0, Math.PI*2); ctx.fill();
            // Legs (short, thick, stumpy)
            if (isPoop) {
                drawDogLeg(ctx, 44, 60, 16, 18, col, dk);
                drawDogLeg(ctx, 78, 60, 16, 24, col, dk);
                ctx.fillStyle = '#6B3410';
                ctx.beginPath(); ctx.ellipse(100, 80, 7, 5, 0, 0, Math.PI*2); ctx.fill();
            } else {
                drawDogLeg(ctx, 42, 60, 16, 18+legOff, col, dk);
                drawDogLeg(ctx, 56, 60, 16, 18-legOff, col, dk);
                drawDogLeg(ctx, 72, 60, 16, 18-legOff, col, dk);
                drawDogLeg(ctx, 86, 60, 16, 18+legOff, col, dk);
            }
            // Neck
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.ellipse(42, 38, 14, 16, -0.1, 0, Math.PI*2); ctx.fill();
            // BIG round head (shifted right so flat face stays in canvas)
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.arc(30, 32, 22, 0, Math.PI*2); ctx.fill();
            // Dark mask around face
            ctx.fillStyle = '#5A4A3A';
            ctx.beginPath(); ctx.ellipse(24, 36, 14, 12, 0, 0, Math.PI*2); ctx.fill();
            // Flat snout (pugs have pushed-in faces)
            ctx.fillStyle = '#5A4A3A';
            ctx.beginPath(); ctx.ellipse(16, 40, 10, 8, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = lt;
            ctx.beginPath(); ctx.ellipse(16, 42, 8, 5, 0, 0, Math.PI*2); ctx.fill();
            // Wrinkles on forehead
            ctx.strokeStyle = dk; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.arc(28, 24, 10, -0.6, 0.6); ctx.stroke();
            ctx.beginPath(); ctx.arc(28, 27, 12, -0.4, 0.4); ctx.stroke();
            // Nose (flat, wide, prominent)
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.ellipse(12, 38, 5, 4, 0, 0, Math.PI*2); ctx.fill();
            // Nostrils
            ctx.fillStyle = '#333';
            ctx.beginPath(); ctx.arc(10, 38, 1.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(14, 38, 1.5, 0, Math.PI*2); ctx.fill();
            // BIG round eyes
            if (isPoop) {
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2.5;
                ctx.beginPath(); ctx.moveTo(20, 28); ctx.lineTo(26, 34); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(26, 28); ctx.lineTo(20, 34); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(32, 28); ctx.lineTo(38, 34); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(38, 28); ctx.lineTo(32, 34); ctx.stroke();
            } else {
                // Big googly eyes
                ctx.fillStyle = '#FFF';
                ctx.beginPath(); ctx.arc(22, 30, 7, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(36, 30, 7, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#222';
                ctx.beginPath(); ctx.arc(24, 31, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(38, 31, 4, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.beginPath(); ctx.arc(22, 28, 2, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(36, 28, 2, 0, Math.PI*2); ctx.fill();
            }
            // Droopy jowls
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.ellipse(14, 46, 6, 4, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(24, 48, 5, 3, 0, 0, Math.PI*2); ctx.fill();
            // Tongue (hanging out, drooling)
            if (!isPoop) {
                ctx.fillStyle = '#FF7788';
                ctx.beginPath(); ctx.ellipse(16, 50, 5, 6, 0.1, 0, Math.PI); ctx.fill();
                ctx.fillStyle = '#FF5566';
                ctx.beginPath(); ctx.ellipse(16, 52, 3, 4, 0, 0, Math.PI); ctx.fill();
            }
            // Small floppy ears
            ctx.fillStyle = dk;
            ctx.beginPath();
            ctx.moveTo(12, 16); ctx.bezierCurveTo(4, 12, 2, 24, 8, 28);
            ctx.bezierCurveTo(10, 22, 10, 18, 12, 16); ctx.closePath(); ctx.fill();
            ctx.beginPath();
            ctx.moveTo(46, 18); ctx.bezierCurveTo(52, 14, 52, 26, 48, 28);
            ctx.bezierCurveTo(46, 24, 46, 20, 46, 18); ctx.closePath(); ctx.fill();
            // Collar
            ctx.fillStyle = '#CC3333';
            ctx.beginPath(); ctx.ellipse(38, 42, 8, 5, 0.2, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(42, 46, 3, 0, Math.PI*2); ctx.fill();
            // Curly tail
            ctx.strokeStyle = col; ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(100, 36);
            ctx.bezierCurveTo(108, 28, 112, 22, 108, 18);
            ctx.bezierCurveTo(104, 16, 102, 20, 104, 26);
            ctx.stroke();

        } else if (breed === 'labrador') {
            // LABRADOR: Athletic, friendly, golden, 130x90
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath(); ctx.ellipse(65, 86, 40, 4, 0, 0, Math.PI*2); ctx.fill();
            // Body - athletic, slightly barrel-chested
            const bodyGrad = ctx.createLinearGradient(60, 16, 60, 66);
            bodyGrad.addColorStop(0, dk); bodyGrad.addColorStop(0.3, col); bodyGrad.addColorStop(0.7, col); bodyGrad.addColorStop(1, lt);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath(); ctx.ellipse(65, 40, 36, 22, 0, 0, Math.PI*2); ctx.fill();
            // Lighter belly
            ctx.fillStyle = lt;
            ctx.beginPath(); ctx.ellipse(58, 50, 22, 12, 0.1, 0, Math.PI*2); ctx.fill();
            // Chest
            ctx.fillStyle = lighten(c, 50);
            ctx.beginPath(); ctx.ellipse(36, 46, 14, 14, -0.2, 0, Math.PI*2); ctx.fill();
            // Legs (strong, medium length)
            if (isPoop) {
                drawDogLeg(ctx, 34, 56, 14, 22, col, dk);
                drawDogLeg(ctx, 82, 56, 14, 28, col, dk);
                ctx.fillStyle = '#6B3410';
                ctx.beginPath(); ctx.ellipse(104, 80, 7, 5, 0, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(104, 75, 5, 4, 0, 0, Math.PI*2); ctx.fill();
            } else {
                drawDogLeg(ctx, 32, 56, 14, 22+legOff, col, dk);
                drawDogLeg(ctx, 48, 56, 14, 22-legOff, col, dk);
                drawDogLeg(ctx, 72, 56, 14, 22-legOff, col, dk);
                drawDogLeg(ctx, 88, 56, 14, 22+legOff, col, dk);
            }
            // Neck
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.ellipse(36, 32, 14, 16, -0.15, 0, Math.PI*2); ctx.fill();
            // Head (broad, friendly)
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.ellipse(30, 24, 18, 16, 0, 0, Math.PI*2); ctx.fill();
            // Broad muzzle (protruding forward)
            ctx.fillStyle = lighten(c, 50);
            ctx.beginPath();
            ctx.moveTo(20, 24); ctx.lineTo(10, 26); ctx.lineTo(8, 30);
            ctx.lineTo(10, 35); ctx.lineTo(20, 36); ctx.closePath(); ctx.fill();
            // Lighter muzzle underside
            ctx.fillStyle = lighten(c, 70);
            ctx.beginPath();
            ctx.moveTo(20, 30); ctx.lineTo(10, 32); ctx.lineTo(10, 35);
            ctx.lineTo(20, 36); ctx.closePath(); ctx.fill();
            // Nose (big, black, round)
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.ellipse(9, 28, 5, 3.5, 0, 0, Math.PI*2); ctx.fill();
            // Nostrils
            ctx.fillStyle = '#333';
            ctx.beginPath(); ctx.arc(7, 28, 1.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(11, 28, 1.5, 0, Math.PI*2); ctx.fill();
            // Mouth line
            ctx.strokeStyle = dk; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(10, 35); ctx.lineTo(18, 37); ctx.stroke();
            // Eye
            if (isPoop) {
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2.5;
                ctx.beginPath(); ctx.moveTo(26, 18); ctx.lineTo(34, 24); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(34, 18); ctx.lineTo(26, 24); ctx.stroke();
            } else {
                ctx.fillStyle = '#FFF';
                ctx.beginPath(); ctx.ellipse(29, 20, 5, 4, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#442200';
                ctx.beginPath(); ctx.arc(30, 20, 3, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.beginPath(); ctx.arc(28, 18, 1.5, 0, Math.PI*2); ctx.fill();
            }
            // Friendly eyebrow
            ctx.fillStyle = dk;
            ctx.beginPath(); ctx.ellipse(30, 16, 6, 2, -0.15, 0, Math.PI*2); ctx.fill();
            // Big floppy ears
            ctx.fillStyle = dk;
            ctx.beginPath();
            ctx.moveTo(20, 12);
            ctx.bezierCurveTo(8, 6, 6, 26, 14, 34);
            ctx.bezierCurveTo(18, 28, 18, 18, 20, 12);
            ctx.closePath(); ctx.fill();
            ctx.beginPath();
            ctx.moveTo(40, 14);
            ctx.bezierCurveTo(48, 8, 48, 28, 44, 32);
            ctx.bezierCurveTo(42, 26, 40, 20, 40, 14);
            ctx.closePath(); ctx.fill();
            // Big smile/tongue
            if (!isPoop) {
                ctx.fillStyle = '#FF7788';
                ctx.beginPath(); ctx.ellipse(16, 38, 5, 7, 0.2, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#FF5566';
                ctx.beginPath(); ctx.ellipse(16, 40, 3, 4, 0.2, 0, Math.PI*2); ctx.fill();
            }
            // Collar
            ctx.fillStyle = '#CC3333';
            ctx.beginPath(); ctx.ellipse(32, 36, 8, 5, 0.1, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(36, 40, 3, 0, Math.PI*2); ctx.fill();
            // Thick wagging tail
            ctx.strokeStyle = col; ctx.lineWidth = 7;
            ctx.beginPath(); ctx.moveTo(100, 28);
            ctx.bezierCurveTo(108, 18, 116, 8, 122, 4 + (frame===1?6:0));
            ctx.stroke();
            ctx.strokeStyle = dk; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(100, 28);
            ctx.bezierCurveTo(108, 18, 116, 8, 122, 4 + (frame===1?6:0));
            ctx.stroke();

        } else if (breed === 'pudel') {
            // POODLE: Elegant with big fluffy puffs, 130x90
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath(); ctx.ellipse(65, 86, 35, 4, 0, 0, Math.PI*2); ctx.fill();
            // Body - slim center, big puffs
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.ellipse(65, 40, 28, 16, 0, 0, Math.PI*2); ctx.fill();
            // Fluffy body puffs (lots of overlapping circles)
            ctx.fillStyle = col;
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(44 + i * 7, 36 + Math.sin(i * 1.2) * 5, 12, 0, Math.PI*2);
                ctx.fill();
            }
            // Curly highlights
            ctx.fillStyle = lt;
            for (let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.arc(40 + i * 7, 34 + Math.sin(i * 1.5) * 4, 5, 0, Math.PI*2);
                ctx.fill();
            }
            // Legs (thin with pom-pom paws)
            ctx.fillStyle = '#CCBBAA';
            if (isPoop) {
                // Thin shaved legs
                ctx.fillRect(46, 52, 8, 24);
                ctx.fillRect(82, 52, 8, 30);
                // Pom-pom paws
                ctx.fillStyle = col;
                ctx.beginPath(); ctx.arc(50, 76, 8, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(86, 82, 8, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = lt;
                ctx.beginPath(); ctx.arc(50, 74, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(86, 80, 4, 0, Math.PI*2); ctx.fill();
                // Poop
                ctx.fillStyle = '#6B3410';
                ctx.beginPath(); ctx.ellipse(100, 78, 7, 5, 0, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.fillRect(44, 52, 8, 22+legOff);
                ctx.fillRect(56, 52, 8, 22-legOff);
                ctx.fillRect(76, 52, 8, 22-legOff);
                ctx.fillRect(88, 52, 8, 22+legOff);
                // Pom-pom paws
                ctx.fillStyle = col;
                ctx.beginPath(); ctx.arc(48, 74+legOff, 8, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(60, 74-legOff, 8, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(80, 74-legOff, 8, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(92, 74+legOff, 8, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = lt;
                ctx.beginPath(); ctx.arc(48, 72+legOff, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(92, 72+legOff, 4, 0, Math.PI*2); ctx.fill();
            }
            // Slim neck
            ctx.fillStyle = '#CCBBAA';
            ctx.beginPath(); ctx.ellipse(38, 32, 8, 14, -0.15, 0, Math.PI*2); ctx.fill();
            // Big fluffy head poof
            ctx.fillStyle = col;
            for (let i = 0; i < 7; i++) {
                ctx.beginPath();
                ctx.arc(20 + i * 5, 22 + Math.sin(i * 1.3) * 3, 10, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.fillStyle = lt;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(22 + i * 5, 18 + Math.sin(i) * 2, 4, 0, Math.PI*2);
                ctx.fill();
            }
            // Pink bow on top
            ctx.fillStyle = '#FF66BB';
            ctx.beginPath(); ctx.moveTo(24, 6); ctx.bezierCurveTo(12, 0, 12, 14, 24, 10); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(24, 6); ctx.bezierCurveTo(36, 0, 36, 14, 24, 10); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#FF3399'; ctx.beginPath(); ctx.arc(24, 8, 3, 0, Math.PI*2); ctx.fill();
            // Long elegant snout
            ctx.fillStyle = '#CCBBAA';
            ctx.beginPath(); ctx.ellipse(14, 30, 10, 5, -0.2, 0, Math.PI*2); ctx.fill();
            // Nose
            ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(7, 28, 3, 0, Math.PI*2); ctx.fill();
            // Eyes (elegant)
            if (isPoop) {
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(20, 24); ctx.lineTo(26, 30); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(26, 24); ctx.lineTo(20, 30); ctx.stroke();
            } else {
                ctx.fillStyle = '#222';
                ctx.beginPath(); ctx.ellipse(22, 26, 4, 3, 0.1, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#5577CC';
                ctx.beginPath(); ctx.arc(22, 25, 2, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.beginPath(); ctx.arc(21, 24, 1, 0, Math.PI*2); ctx.fill();
            }
            // Dainty mouth
            if (!isPoop) {
                ctx.fillStyle = '#FF8899';
                ctx.beginPath(); ctx.arc(14, 34, 3, 0, Math.PI); ctx.fill();
            }
            // Collar (fancy)
            ctx.fillStyle = '#CC3399';
            ctx.beginPath(); ctx.ellipse(36, 36, 8, 4, 0.1, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(40, 38, 3, 0, Math.PI*2); ctx.fill();
            // Pompom tail (big puff on thin stem)
            ctx.strokeStyle = '#CCBBAA'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(96, 30); ctx.bezierCurveTo(102, 22, 108, 16, 112, 12); ctx.stroke();
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.arc(114, 10, 10, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = lt;
            ctx.beginPath(); ctx.arc(114, 8, 5, 0, Math.PI*2); ctx.fill();

        } else {
            // GERMAN SHEPHERD: Large, powerful, black-and-tan, 130x90
            const tan = '#B8860B';
            const tanLt = '#D4A832';
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath(); ctx.ellipse(65, 86, 42, 4, 0, 0, Math.PI*2); ctx.fill();
            // Body - large, muscular
            const bodyGrad = ctx.createLinearGradient(60, 12, 60, 62);
            bodyGrad.addColorStop(0, '#1A1A1A'); bodyGrad.addColorStop(0.4, col); bodyGrad.addColorStop(0.7, col); bodyGrad.addColorStop(1, tan);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath(); ctx.ellipse(65, 38, 36, 24, 0, 0, Math.PI*2); ctx.fill();
            // Black saddle marking on back
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath(); ctx.ellipse(70, 28, 30, 12, 0.05, 0, Math.PI*2); ctx.fill();
            // Tan belly
            ctx.fillStyle = tan;
            ctx.beginPath(); ctx.ellipse(62, 52, 24, 10, 0.1, 0, Math.PI*2); ctx.fill();
            // Strong legs (black and tan)
            if (isPoop) {
                drawDogLeg(ctx, 36, 54, 14, 24, tan, '#222');
                drawDogLeg(ctx, 82, 54, 14, 30, tan, '#222');
                ctx.fillStyle = '#6B3410';
                ctx.beginPath(); ctx.ellipse(104, 80, 7, 5, 0, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(104, 75, 5, 4, 0, 0, Math.PI*2); ctx.fill();
            } else {
                drawDogLeg(ctx, 34, 54, 14, 24+legOff, tan, '#222');
                drawDogLeg(ctx, 50, 54, 14, 24-legOff, tan, '#222');
                drawDogLeg(ctx, 72, 54, 14, 24-legOff, tan, '#222');
                drawDogLeg(ctx, 88, 54, 14, 24+legOff, tan, '#222');
            }
            // Strong neck
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.ellipse(38, 30, 14, 18, -0.15, 0, Math.PI*2); ctx.fill();
            // Head (wedge-shaped, long snout)
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.ellipse(32, 22, 18, 16, -0.1, 0, Math.PI*2); ctx.fill();
            // Tan face mask
            ctx.fillStyle = tan;
            ctx.beginPath(); ctx.ellipse(26, 28, 14, 10, -0.1, 0, Math.PI*2); ctx.fill();
            // Long muzzle (wedge-shaped, protruding)
            ctx.fillStyle = tanLt;
            ctx.beginPath();
            ctx.moveTo(20, 24); ctx.lineTo(8, 26); ctx.lineTo(6, 30);
            ctx.lineTo(8, 35); ctx.lineTo(20, 36); ctx.closePath(); ctx.fill();
            // Lighter muzzle underside
            ctx.fillStyle = lighten(tan, 30);
            ctx.beginPath();
            ctx.moveTo(20, 30); ctx.lineTo(8, 32); ctx.lineTo(8, 35);
            ctx.lineTo(20, 36); ctx.closePath(); ctx.fill();
            // Nose (big, prominent)
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.ellipse(7, 28, 5, 3.5, 0, 0, Math.PI*2); ctx.fill();
            // Mouth line
            ctx.strokeStyle = darken(tan, 40); ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(8, 35); ctx.lineTo(18, 37); ctx.stroke();
            // Eye
            if (isPoop) {
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2.5;
                ctx.beginPath(); ctx.moveTo(30, 18); ctx.lineTo(38, 24); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(38, 18); ctx.lineTo(30, 24); ctx.stroke();
            } else {
                ctx.fillStyle = '#FFF';
                ctx.beginPath(); ctx.ellipse(33, 20, 5, 4, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#442200';
                ctx.beginPath(); ctx.arc(34, 20, 3, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#FFF';
                ctx.beginPath(); ctx.arc(32, 18, 1.5, 0, Math.PI*2); ctx.fill();
            }
            // Alert/stern eyebrow
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath(); ctx.ellipse(34, 16, 6, 2.5, -0.2, 0, Math.PI*2); ctx.fill();
            // BIG pointed erect ears
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath(); ctx.moveTo(24, 10); ctx.lineTo(16, -4); ctx.lineTo(32, 6); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(40, 10); ctx.lineTo(48, -4); ctx.lineTo(36, 6); ctx.closePath(); ctx.fill();
            // Inner ear (tan)
            ctx.fillStyle = tan;
            ctx.beginPath(); ctx.moveTo(24, 8); ctx.lineTo(19, 0); ctx.lineTo(30, 6); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(40, 8); ctx.lineTo(45, 0); ctx.lineTo(38, 6); ctx.closePath(); ctx.fill();
            // Tongue
            if (!isPoop) {
                ctx.fillStyle = '#FF7788';
                ctx.beginPath(); ctx.ellipse(14, 38, 5, 7, 0.2, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#FF5566';
                ctx.beginPath(); ctx.ellipse(14, 40, 3, 4, 0.2, 0, Math.PI*2); ctx.fill();
            }
            // Collar
            ctx.fillStyle = '#CC3333';
            ctx.beginPath(); ctx.ellipse(34, 34, 8, 5, 0.1, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(38, 38, 3, 0, Math.PI*2); ctx.fill();
            // Bushy tail (thick, fluffy)
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.moveTo(100, 30);
            ctx.bezierCurveTo(108, 18, 116, 12, 120, 18);
            ctx.bezierCurveTo(118, 28, 110, 34, 100, 30);
            ctx.closePath(); ctx.fill();
            ctx.fillStyle = col;
            ctx.beginPath();
            ctx.moveTo(100, 32);
            ctx.bezierCurveTo(106, 22, 112, 16, 116, 20);
            ctx.bezierCurveTo(114, 28, 108, 32, 100, 32);
            ctx.closePath(); ctx.fill();
        }
        ctx.restore();
    }

    DOG_BREEDS.forEach(info => {
        genTex(scene, info.breed + '_run_0', info.w, info.h, (ctx,w,h) => drawDog(ctx,w,h,info.breed,0));
        genTex(scene, info.breed + '_run_1', info.w, info.h, (ctx,w,h) => drawDog(ctx,w,h,info.breed,1));
        genTex(scene, info.breed + '_poop', info.w, info.h, (ctx,w,h) => drawDog(ctx,w,h,info.breed,2));
    });

    // --- POOP ---
    function drawPoopShape(ctx, w, h, color, lightColor) {
        const cx=w/2, base=h*0.85;
        // Bottom ellipse
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.ellipse(cx, base, w*0.4, h*0.12, 0, 0, Math.PI*2); ctx.fill();
        // Middle ellipse
        ctx.beginPath(); ctx.ellipse(cx, base-h*0.18, w*0.3, h*0.1, 0, 0, Math.PI*2); ctx.fill();
        // Top ellipse
        ctx.beginPath(); ctx.ellipse(cx+1, base-h*0.33, w*0.2, h*0.08, 0, 0, Math.PI*2); ctx.fill();
        // Tip swirl
        ctx.beginPath();
        ctx.moveTo(cx+w*0.1, base-h*0.38);
        ctx.bezierCurveTo(cx+w*0.15, base-h*0.5, cx-w*0.05, base-h*0.55, cx-w*0.02, base-h*0.42);
        ctx.fill();
        // Highlight
        ctx.fillStyle = lightColor;
        ctx.beginPath(); ctx.arc(cx+w*0.12, base-h*0.22, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx+w*0.08, base-h*0.38, 2, 0, Math.PI*2); ctx.fill();
        // Shadow
        ctx.fillStyle = darken(color.startsWith && color.startsWith('#') ? parseInt(color.slice(1),16) : 0x6B3410, 30);
        ctx.beginPath(); ctx.ellipse(cx, base+h*0.06, w*0.42, h*0.05, 0, 0, Math.PI*2); ctx.fill();
    }

    // Small poop (35x40)
    genTex(scene, 'poop_small', 35, 40, (ctx,w,h) => {
        drawPoopShape(ctx, w, h, '#6B3410', '#8B5E3C');
        // Stink lines
        ctx.strokeStyle = 'rgba(120,160,80,0.3)';
        ctx.lineWidth = 1.5; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(12,6); ctx.bezierCurveTo(10,2,14,0,12,4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(22,4); ctx.bezierCurveTo(24,0,20,2,22,6); ctx.stroke();
    });
    // Big poop (50x55)
    genTex(scene, 'poop_big', 50, 55, (ctx,w,h) => {
        drawPoopShape(ctx, w, h, '#6B3410', '#8B5E3C');
        // Flies
        ctx.fillStyle='#222';
        ctx.beginPath(); ctx.arc(8,8,2,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(40,6,2,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4,16,1.5,0,Math.PI*2); ctx.fill();
        // Wings
        ctx.fillStyle='rgba(200,200,200,0.5)';
        ctx.beginPath(); ctx.ellipse(6,6,3,1.5,0.5,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(42,4,3,1.5,-0.5,0,Math.PI*2); ctx.fill();
        // Stink
        ctx.strokeStyle = 'rgba(120,160,80,0.3)';
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(18,6); ctx.bezierCurveTo(16,0,20,-2,18,4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(30,4); ctx.bezierCurveTo(32,-2,28,0,30,6); ctx.stroke();
    });
    // Gold poop (50x55)
    genTex(scene, 'poop_gold', 50, 55, (ctx,w,h) => {
        drawPoopShape(ctx, w, h, '#FFD700', '#FFF8DC');
        // Sparkles
        ctx.fillStyle='#FFFFFF';
        [[6,4],[38,8],[44,20],[4,28],[20,2]].forEach(([x,y]) => {
            ctx.beginPath(); ctx.arc(x,y,2,0,Math.PI*2); ctx.fill();
        });
        // Glow
        ctx.fillStyle='rgba(255,255,200,0.3)';
        ctx.beginPath(); ctx.arc(25,30,15,0,Math.PI*2); ctx.fill();
    });

    // Steam (15x15)
    genTex(scene, 'steam', 15, 15, (ctx,w,h) => {
        const grad = ctx.createRadialGradient(7,7,0,7,7,7);
        grad.addColorStop(0, 'rgba(200,200,200,0.6)');
        grad.addColorStop(1, 'rgba(200,200,200,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(7,7,7,0,Math.PI*2); ctx.fill();
    });
    // Sparkle (15x15) - 4-pointed star
    genTex(scene, 'sparkle', 15, 15, (ctx,w,h) => {
        ctx.fillStyle='#FFD700';
        ctx.beginPath();
        ctx.moveTo(7.5,0); ctx.lineTo(9,5); ctx.lineTo(15,7.5); ctx.lineTo(9,10);
        ctx.lineTo(7.5,15); ctx.lineTo(6,10); ctx.lineTo(0,7.5); ctx.lineTo(6,5);
        ctx.closePath(); ctx.fill();
        ctx.fillStyle='#FFFFFF';
        ctx.beginPath(); ctx.arc(7.5,7.5,2,0,Math.PI*2); ctx.fill();
    });

    // --- OBSTACLES ---
    // Puddle (80x25)
    genTex(scene, 'puddle', 80, 25, (ctx,w,h) => {
        const grad = ctx.createRadialGradient(40,12,5,40,12,38);
        grad.addColorStop(0, '#88CCEE');
        grad.addColorStop(0.7, '#4488CC');
        grad.addColorStop(1, '#3377BB');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.ellipse(40,14,38,10,0,0,Math.PI*2); ctx.fill();
        // Reflections
        ctx.fillStyle='rgba(170,220,255,0.5)';
        ctx.beginPath(); ctx.ellipse(30,10,8,3,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(200,240,255,0.4)';
        ctx.beginPath(); ctx.ellipse(50,12,5,2,0,0,Math.PI*2); ctx.fill();
        // Ripples
        ctx.strokeStyle='rgba(100,180,220,0.4)'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.arc(25,14,4,0,Math.PI); ctx.stroke();
        ctx.beginPath(); ctx.arc(55,13,3,0,Math.PI); ctx.stroke();
    });
    // Hole (70x30)
    genTex(scene, 'hole', 70, 30, (ctx,w,h) => {
        // Edge
        ctx.fillStyle='#777';
        ctx.beginPath(); ctx.ellipse(35,8,34,8,0,0,Math.PI*2); ctx.fill();
        // Depth
        const grad = ctx.createLinearGradient(35,6,35,28);
        grad.addColorStop(0, '#333'); grad.addColorStop(1, '#080808');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.ellipse(35,14,30,12,0,0,Math.PI*2); ctx.fill();
        // Crack lines
        ctx.strokeStyle='#555'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(8,6); ctx.lineTo(4,2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(58,4); ctx.lineTo(64,1); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(30,3); ctx.lineTo(28,0); ctx.stroke();
    });
    // Bicycle (120x90) - classic city bike, side view
    genTex(scene, 'bicycle', 120, 90, (ctx,w,h) => {
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        // Key geometry points - centered in wider canvas with margin for wheels
        const rearX = 26, frontX = 88, wheelY = 65, wheelR = 19;
        const bbX = 48, bbY = 65;            // bottom bracket (pedals)
        const seatTopX = 42, seatTopY = 30;  // top of seat tube
        const headTopX = 78, headTopY = 28;  // top of head tube

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.12)';
        ctx.beginPath(); ctx.ellipse(57, 86, 46, 4, 0, 0, Math.PI*2); ctx.fill();

        // --- WHEELS (draw first, frame goes on top) ---
        [rearX, frontX].forEach(wx => {
            // Tire
            ctx.strokeStyle = '#2A2A2A'; ctx.lineWidth = 6;
            ctx.beginPath(); ctx.arc(wx, wheelY, wheelR, 0, Math.PI*2); ctx.stroke();
            // Rim
            ctx.strokeStyle = '#C0C0C0'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.arc(wx, wheelY, wheelR - 3, 0, Math.PI*2); ctx.stroke();
            // Spokes
            ctx.strokeStyle = '#AAAAAA'; ctx.lineWidth = 0.7;
            for (let a = 0; a < 12; a++) {
                const ang = a * Math.PI / 6;
                ctx.beginPath();
                ctx.moveTo(wx + 3 * Math.cos(ang), wheelY + 3 * Math.sin(ang));
                ctx.lineTo(wx + (wheelR-4) * Math.cos(ang), wheelY + (wheelR-4) * Math.sin(ang));
                ctx.stroke();
            }
            // Hub
            ctx.fillStyle = '#888'; ctx.beginPath(); ctx.arc(wx, wheelY, 3, 0, Math.PI*2); ctx.fill();
        });

        // --- FRAME (classic diamond) ---
        const fc = '#2288DD', fd = '#1166AA';
        ctx.lineWidth = 4.5; ctx.strokeStyle = fc;
        // Seat tube: BB up to seat top
        ctx.beginPath(); ctx.moveTo(bbX, bbY); ctx.lineTo(seatTopX, seatTopY); ctx.stroke();
        // Top tube: seat top to head top (nearly horizontal)
        ctx.beginPath(); ctx.moveTo(seatTopX, seatTopY); ctx.lineTo(headTopX, headTopY); ctx.stroke();
        // Down tube: head top diagonally down to BB
        ctx.beginPath(); ctx.moveTo(headTopX, headTopY); ctx.lineTo(bbX, bbY); ctx.stroke();
        // Chain stays: BB backward to rear wheel hub
        ctx.strokeStyle = fd; ctx.lineWidth = 3.5;
        ctx.beginPath(); ctx.moveTo(bbX, bbY); ctx.lineTo(rearX, wheelY); ctx.stroke();
        // Seat stays: seat top back/down to rear wheel hub
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(seatTopX, seatTopY + 4); ctx.lineTo(rearX, wheelY); ctx.stroke();
        // Fork: head top down to front wheel hub
        ctx.strokeStyle = fc; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(headTopX, headTopY); ctx.lineTo(frontX, wheelY); ctx.stroke();

        // --- CHAIN ---
        ctx.strokeStyle = '#555'; ctx.lineWidth = 1.5;
        // Chain top (BB to rear hub, straight)
        ctx.beginPath(); ctx.moveTo(bbX - 5, bbY + 1); ctx.lineTo(rearX, wheelY + 1); ctx.stroke();
        // Chain bottom
        ctx.beginPath(); ctx.moveTo(bbX - 5, bbY + 5); ctx.lineTo(rearX, wheelY + 5); ctx.stroke();
        // Chainring
        ctx.strokeStyle = '#666'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(bbX, bbY, 7, 0, Math.PI*2); ctx.stroke();
        // Rear sprocket
        ctx.beginPath(); ctx.arc(rearX, wheelY, 4, 0, Math.PI*2); ctx.stroke();

        // --- PEDALS + CRANKS ---
        ctx.strokeStyle = '#555'; ctx.lineWidth = 2.5;
        // Crank arms
        ctx.beginPath(); ctx.moveTo(bbX, bbY); ctx.lineTo(bbX - 8, bbY + 8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(bbX, bbY); ctx.lineTo(bbX + 8, bbY - 5); ctx.stroke();
        // Pedals
        ctx.fillStyle = '#444';
        ctx.fillRect(bbX - 12, bbY + 6, 8, 3);
        ctx.fillRect(bbX + 5, bbY - 8, 8, 3);

        // --- SEAT ---
        ctx.strokeStyle = '#555'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(seatTopX, seatTopY); ctx.lineTo(seatTopX - 1, seatTopY - 10); ctx.stroke();
        // Saddle
        ctx.fillStyle = '#3A2A1A';
        ctx.beginPath();
        ctx.moveTo(seatTopX - 10, seatTopY - 10);
        ctx.bezierCurveTo(seatTopX - 8, seatTopY - 16, seatTopX + 6, seatTopY - 16, seatTopX + 8, seatTopY - 12);
        ctx.bezierCurveTo(seatTopX + 4, seatTopY - 9, seatTopX - 6, seatTopY - 8, seatTopX - 10, seatTopY - 10);
        ctx.closePath(); ctx.fill();
        // Saddle highlight
        ctx.fillStyle = '#5A4A3A';
        ctx.beginPath();
        ctx.ellipse(seatTopX - 1, seatTopY - 13, 6, 2, -0.1, 0, Math.PI*2);
        ctx.fill();

        // --- HANDLEBAR + STEM ---
        ctx.strokeStyle = '#555'; ctx.lineWidth = 3;
        // Stem going up from head tube
        ctx.beginPath(); ctx.moveTo(headTopX, headTopY); ctx.lineTo(headTopX + 4, headTopY - 14); ctx.stroke();
        // Handlebar (curved)
        ctx.strokeStyle = '#333'; ctx.lineWidth = 3.5;
        ctx.beginPath();
        ctx.moveTo(headTopX - 2, headTopY - 12);
        ctx.bezierCurveTo(headTopX + 2, headTopY - 18, headTopX + 8, headTopY - 18, headTopX + 10, headTopY - 10);
        ctx.stroke();
        // Grips
        ctx.strokeStyle = '#111'; ctx.lineWidth = 5;
        ctx.beginPath(); ctx.moveTo(headTopX - 2, headTopY - 12); ctx.lineTo(headTopX - 4, headTopY - 10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(headTopX + 10, headTopY - 10); ctx.lineTo(headTopX + 12, headTopY - 8); ctx.stroke();

        // --- FRONT BASKET ---
        ctx.fillStyle = '#CC9955';
        ctx.beginPath();
        ctx.moveTo(frontX + 2, headTopY - 4);
        ctx.lineTo(frontX + 18, headTopY - 2);
        ctx.lineTo(frontX + 16, headTopY + 14);
        ctx.lineTo(frontX + 0, headTopY + 12);
        ctx.closePath(); ctx.fill();
        // Weave
        ctx.strokeStyle = '#AA7733'; ctx.lineWidth = 0.8;
        for (let i = 0; i < 4; i++) {
            const yy = headTopY + i * 4;
            ctx.beginPath(); ctx.moveTo(frontX + 2, yy); ctx.lineTo(frontX + 17, yy + 0.5); ctx.stroke();
        }
        // Basket rim
        ctx.strokeStyle = '#8B6633'; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(frontX + 2, headTopY - 4);
        ctx.lineTo(frontX + 18, headTopY - 2);
        ctx.lineTo(frontX + 16, headTopY + 14);
        ctx.lineTo(frontX + 0, headTopY + 12);
        ctx.closePath(); ctx.stroke();

        // --- KICKSTAND ---
        ctx.strokeStyle = '#777'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(bbX - 2, bbY); ctx.lineTo(bbX - 10, 84); ctx.stroke();

        // --- REFLECTOR ---
        ctx.fillStyle = '#FF3333';
        ctx.beginPath(); ctx.arc(rearX - wheelR + 2, wheelY, 3, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#FF7777';
        ctx.beginPath(); ctx.arc(rearX - wheelR + 2, wheelY - 1, 1.5, 0, Math.PI*2); ctx.fill();
    });
    // Barrier (70x65)
    genTex(scene, 'barrier', 70, 65, (ctx,w,h) => {
        // Posts
        ctx.fillStyle='#888';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(0,0,8,65,2);ctx.fill();ctx.beginPath();ctx.roundRect(62,0,8,65,2);ctx.fill();}
        else{ctx.fillRect(0,0,8,65);ctx.fillRect(62,0,8,65);}
        // Warning lights
        ctx.fillStyle='#FFAA00';
        ctx.beginPath(); ctx.arc(4,4,4,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(66,4,4,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FFCC44';
        ctx.beginPath(); ctx.arc(4,4,2,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(66,4,2,0,Math.PI*2); ctx.fill();
        // Upper bar with stripes
        for(let i=0;i<8;i++){
            ctx.fillStyle=i%2===0?'#FF6600':'#FFFFFF';
            ctx.fillRect(7+i*7,18,7,10);
        }
        // Lower bar
        for(let i=0;i<8;i++){
            ctx.fillStyle=i%2===0?'#FFFFFF':'#FF6600';
            ctx.fillRect(7+i*7,36,7,10);
        }
    });
    // Car (130x60)
    // Car - multiple color variants
    ['#CC3333','#3366CC','#33AA33','#CCCC33','#FF6600','#8833AA'].forEach((cc, ci) => {
        genTex(scene, 'car' + ci, 160, 80, (ctx,w,h) => {
            ctx.lineCap = 'round';
            const cd = darken(parseInt(cc.slice(1),16), 30);
            const cl = lighten(parseInt(cc.slice(1),16), 25);
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath(); ctx.ellipse(80, 76, 70, 4, 0, 0, Math.PI*2); ctx.fill();
            // Wheel wells (dark recesses)
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath(); ctx.arc(36, 58, 16, Math.PI, 0); ctx.fill();
            ctx.beginPath(); ctx.arc(124, 58, 16, Math.PI, 0); ctx.fill();
            // Main body (lower half)
            const bodyGrad = ctx.createLinearGradient(0, 22, 0, 58);
            bodyGrad.addColorStop(0, hexC(cl)); bodyGrad.addColorStop(0.4, cc); bodyGrad.addColorStop(1, hexC(cd));
            ctx.fillStyle = bodyGrad;
            if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(8, 22, 144, 36, 8); ctx.fill(); }
            else ctx.fillRect(8, 22, 144, 36);
            // Roof/Cabin (trapezoid with curved top)
            ctx.fillStyle = cc;
            ctx.beginPath();
            ctx.moveTo(34, 22); ctx.lineTo(28, 6); ctx.bezierCurveTo(30, 2, 110, 2, 112, 6);
            ctx.lineTo(106, 22); ctx.closePath(); ctx.fill();
            // Windows (glass)
            const glassGrad = ctx.createLinearGradient(30, 4, 30, 20);
            glassGrad.addColorStop(0, '#AADDFF'); glassGrad.addColorStop(1, '#5599CC');
            ctx.fillStyle = glassGrad;
            // Front window
            ctx.beginPath();
            ctx.moveTo(36, 20); ctx.lineTo(32, 7); ctx.lineTo(56, 6); ctx.lineTo(56, 20); ctx.closePath(); ctx.fill();
            // Rear window
            ctx.beginPath();
            ctx.moveTo(60, 20); ctx.lineTo(60, 6); ctx.lineTo(90, 6); ctx.lineTo(90, 20); ctx.closePath(); ctx.fill();
            // Back window
            ctx.beginPath();
            ctx.moveTo(94, 20); ctx.lineTo(94, 6); ctx.lineTo(108, 7); ctx.lineTo(104, 20); ctx.closePath(); ctx.fill();
            // Pillars
            ctx.fillStyle = hexC(cd);
            ctx.fillRect(56, 5, 4, 16); ctx.fillRect(90, 5, 4, 16);
            // Window reflection
            ctx.fillStyle = 'rgba(220,240,255,0.4)';
            ctx.beginPath(); ctx.moveTo(38, 8); ctx.lineTo(40, 18); ctx.lineTo(48, 18); ctx.lineTo(46, 8); ctx.closePath(); ctx.fill();
            // Chrome trim line
            ctx.strokeStyle = '#CCCCCC'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(12, 38); ctx.lineTo(148, 38); ctx.stroke();
            // Door handle
            ctx.fillStyle = '#AAA';
            ctx.fillRect(62, 32, 8, 3);
            ctx.fillRect(98, 32, 8, 3);
            // Bumper front
            ctx.fillStyle = '#BBB';
            if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(2, 48, 14, 10, 4); ctx.fill(); }
            else ctx.fillRect(2, 48, 14, 10);
            // Bumper rear
            if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(144, 48, 14, 10, 4); ctx.fill(); }
            else ctx.fillRect(144, 48, 14, 10);
            // Headlights
            ctx.fillStyle = '#FFFFAA';
            ctx.beginPath(); ctx.ellipse(8, 32, 5, 7, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath(); ctx.ellipse(7, 30, 2, 3, 0, 0, Math.PI*2); ctx.fill();
            // Taillights
            ctx.fillStyle = '#FF2222';
            ctx.beginPath(); ctx.ellipse(152, 32, 5, 7, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FF6666';
            ctx.beginPath(); ctx.ellipse(151, 30, 2, 3, 0, 0, Math.PI*2); ctx.fill();
            // Wheels - tires
            ctx.fillStyle = '#222';
            ctx.beginPath(); ctx.arc(36, 60, 14, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(124, 60, 14, 0, Math.PI*2); ctx.fill();
            // Wheels - rims
            ctx.fillStyle = '#999';
            ctx.beginPath(); ctx.arc(36, 60, 8, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(124, 60, 8, 0, Math.PI*2); ctx.fill();
            // Rim spokes
            ctx.strokeStyle = '#BBB'; ctx.lineWidth = 1.5;
            for (let a = 0; a < 5; a++) {
                const ang = a * Math.PI * 2 / 5;
                [36, 124].forEach(wx => {
                    ctx.beginPath();
                    ctx.moveTo(wx + 3*Math.cos(ang), 60 + 3*Math.sin(ang));
                    ctx.lineTo(wx + 7*Math.cos(ang), 60 + 7*Math.sin(ang));
                    ctx.stroke();
                });
            }
            // Rim center
            ctx.fillStyle = '#777';
            ctx.beginPath(); ctx.arc(36, 60, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(124, 60, 3, 0, Math.PI*2); ctx.fill();
            // Side trim / door sill
            ctx.fillStyle = '#888';
            ctx.fillRect(20, 52, 120, 2);
        });
    });
    window.NUM_CAR_COLORS = 6;
    // Traffic light (30x90)
    genTex(scene, 'traffic_light', 30, 90, (ctx,w,h) => {
        // Pole
        ctx.fillStyle='#555';
        ctx.fillRect(11,40,8,50);
        // Box
        ctx.fillStyle='#333';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(0,0,30,42,4);ctx.fill();}else ctx.fillRect(0,0,30,42);
        // Red
        ctx.fillStyle='#FF0000'; ctx.beginPath(); ctx.arc(15,10,6,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FF4444'; ctx.beginPath(); ctx.arc(14,8,2,0,Math.PI*2); ctx.fill();
        // Yellow
        ctx.fillStyle='#FFAA00'; ctx.beginPath(); ctx.arc(15,22,6,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FFCC44'; ctx.beginPath(); ctx.arc(14,20,2,0,Math.PI*2); ctx.fill();
        // Green
        ctx.fillStyle='#00CC00'; ctx.beginPath(); ctx.arc(15,34,6,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#44EE44'; ctx.beginPath(); ctx.arc(14,32,2,0,Math.PI*2); ctx.fill();
    });

    // --- NPCs ---
    // Oma (80x120) facing LEFT - with walk frames
    function drawOma(ctx, w, h, frame) {
        ctx.save();
        const headX=40, headY=22, headR=13;
        // Walk offsets: frame 0 = neutral, frame 1 = stride
        const nearStep = frame === 1 ? -8 : 0;
        const farStep = frame === 1 ? 8 : 0;
        // Legs/shoes (drawn first, behind dress)
        ctx.fillStyle='#663399';
        ctx.fillRect(28 + nearStep, 90, 14, 18);
        ctx.fillRect(42 + farStep, 90, 12, 16);
        ctx.fillStyle='#222';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(18 + nearStep,104,24,10,[6,0,0,6]);ctx.fill();}else ctx.fillRect(18 + nearStep,104,24,10);
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(40 + farStep,102,18,10,[6,0,0,6]);ctx.fill();}else ctx.fillRect(40 + farStep,102,18,10);
        // Gray hair with bun
        ctx.fillStyle='#CCC';
        ctx.beginPath(); ctx.arc(headX,headY,headR+2,0,Math.PI*2); ctx.fill();
        // Bun
        ctx.beginPath(); ctx.arc(headX+2,headY-16,7,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#DDD'; ctx.beginPath(); ctx.arc(headX+2,headY-17,4,0,Math.PI*2); ctx.fill();
        // Face
        ctx.fillStyle='#FFD4A3'; ctx.beginPath(); ctx.arc(headX,headY,headR,0,Math.PI*2); ctx.fill();
        // Nose (left)
        ctx.beginPath(); ctx.arc(headX-14,headY+3,3,-2.5,0.5); ctx.fill();
        // Glasses
        ctx.strokeStyle='#666'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(headX-5,headY-1,6,0,Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(headX+1,headY-1); ctx.lineTo(headX+12,headY-2); ctx.stroke();
        // Lens reflection
        ctx.fillStyle='rgba(140,200,255,0.3)'; ctx.beginPath(); ctx.arc(headX-5,headY-2,4,0,Math.PI*2); ctx.fill();
        // Angry eye
        ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(headX-5,headY,2,0,Math.PI*2); ctx.fill();
        // Angry brow
        ctx.strokeStyle='#333'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(headX-10,headY-6); ctx.lineTo(headX-2,headY-4); ctx.stroke();
        // Angry mouth
        ctx.strokeStyle='#CC3333'; ctx.lineWidth=2; ctx.lineCap='round';
        ctx.beginPath(); ctx.moveTo(headX-10,headY+8); ctx.lineTo(headX-4,headY+10); ctx.stroke();
        // Neck
        ctx.fillStyle='#FFD4A3'; ctx.fillRect(headX-4,headY+12,10,5);
        // Purple dress (slight sway)
        const dressSkew = frame === 1 ? 2 : 0;
        const dg = ctx.createLinearGradient(20,38,58,95);
        dg.addColorStop(0,'#773399'); dg.addColorStop(1,'#552277');
        ctx.fillStyle = dg;
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(22 - dressSkew,37,34 + dressSkew,55,4);ctx.fill();}else ctx.fillRect(22 - dressSkew,37,34 + dressSkew,55);
        // Apron
        ctx.fillStyle='#FFFFFF';
        ctx.fillRect(24 - dressSkew,42,14,48);
        ctx.fillStyle='#EEE'; ctx.fillRect(26 - dressSkew,46,10,6);
        // Near arm raised with pan (slight swing)
        const armSwing = frame === 1 ? -3 : 0;
        ctx.fillStyle='#663399'; ctx.fillRect(16,37 + armSwing,8,8);
        ctx.fillStyle='#FFD4A3'; ctx.fillRect(12,22 + armSwing,8,18);
        // Far arm (swings opposite)
        ctx.fillStyle='#552277'; ctx.fillRect(54,42 - armSwing,6,12);
        ctx.fillStyle='#EEC090'; ctx.fillRect(54,54 - armSwing,6,6);
        ctx.restore();
    }
    genTex(scene, 'oma', 80, 120, (ctx,w,h) => drawOma(ctx,w,h,0));
    genTex(scene, 'oma_run_0', 80, 120, (ctx,w,h) => drawOma(ctx,w,h,0));
    genTex(scene, 'oma_run_1', 80, 120, (ctx,w,h) => drawOma(ctx,w,h,1));
    // Pan (50x60)
    genTex(scene, 'pan', 50, 60, (ctx,w,h) => {
        // Handle
        ctx.fillStyle='#664422';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(18,28,14,30,4);ctx.fill();}else ctx.fillRect(18,28,14,30);
        ctx.fillStyle='#775533'; ctx.fillRect(20,30,10,4);
        // Pan head
        ctx.fillStyle='#666';
        ctx.beginPath(); ctx.ellipse(25,14,20,12,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#888';
        ctx.beginPath(); ctx.ellipse(25,14,16,8,0,0,Math.PI*2); ctx.fill();
        // Reflections
        ctx.fillStyle='#AAA'; ctx.beginPath(); ctx.arc(20,10,3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#999'; ctx.beginPath(); ctx.arc(30,12,2,0,Math.PI*2); ctx.fill();
    });
    // Ordnungsamt (80x120) facing LEFT - with walk frames
    function drawOrdnungsamt(ctx, w, h, frame) {
        ctx.save();
        const headX=40, headY=24, headR=13;
        // Walk offsets
        const nearStep = frame === 1 ? -8 : 0;
        const farStep = frame === 1 ? 8 : 0;
        // Legs (drawn first, behind uniform)
        ctx.fillStyle='#333366';
        ctx.fillRect(28 + nearStep, 75, 14, 30);
        ctx.fillRect(42 + farStep, 75, 12, 28);
        // Shoes
        ctx.fillStyle='#222';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(18 + nearStep,102,24,10,[6,0,0,6]);ctx.fill();}else ctx.fillRect(18 + nearStep,102,24,10);
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(40 + farStep,100,18,10,[6,0,0,6]);ctx.fill();}else ctx.fillRect(40 + farStep,100,18,10);
        ctx.fillStyle='#444'; ctx.beginPath(); ctx.arc(30 + nearStep,106,2,0,Math.PI*2); ctx.fill();
        // Cap
        ctx.fillStyle='#333366';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(headX-14,headY-16,26,12,3);ctx.fill();}else ctx.fillRect(headX-14,headY-16,26,12);
        // Brim
        ctx.fillRect(headX-20,headY-6,18,5);
        ctx.fillStyle='#222244'; ctx.fillRect(headX-20,headY-6,18,2);
        // Badge
        ctx.fillStyle='#FFD700'; ctx.beginPath(); ctx.arc(headX-8,headY-12,3,0,Math.PI*2); ctx.fill();
        // Face
        ctx.fillStyle='#FFD4A3'; ctx.beginPath(); ctx.arc(headX,headY,headR,0,Math.PI*2); ctx.fill();
        // Nose
        ctx.beginPath(); ctx.arc(headX-14,headY+2,3,-2.5,0.5); ctx.fill();
        // Eye
        ctx.fillStyle='#FFF'; ctx.beginPath(); ctx.ellipse(headX-5,headY-2,4,3,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(headX-5,headY-1,2,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FFF'; ctx.beginPath(); ctx.arc(headX-6,headY-3,1,0,Math.PI*2); ctx.fill();
        // Stern brow
        ctx.strokeStyle='#333'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(headX-10,headY-7); ctx.lineTo(headX-1,headY-5); ctx.stroke();
        // Mustache
        ctx.fillStyle='#222';
        ctx.beginPath();
        ctx.moveTo(headX-12,headY+4);
        ctx.bezierCurveTo(headX-10,headY+2,headX-4,headY+2,headX-2,headY+4);
        ctx.bezierCurveTo(headX-4,headY+6,headX-10,headY+6,headX-12,headY+4);
        ctx.closePath(); ctx.fill();
        // Mouth
        ctx.strokeStyle='#CC6644'; ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.moveTo(headX-8,headY+8); ctx.lineTo(headX-3,headY+8); ctx.stroke();
        // Neck
        ctx.fillStyle='#FFD4A3'; ctx.fillRect(headX-4,headY+12,10,5);
        // Uniform
        ctx.fillStyle='#333366';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(22,40,34,32,3);ctx.fill();}else ctx.fillRect(22,40,34,32);
        // Tie
        ctx.fillStyle='#222'; ctx.fillRect(26,40,4,14);
        // Gold buttons
        ctx.fillStyle='#FFD700';
        ctx.beginPath(); ctx.arc(32,46,2,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(32,52,2,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(32,58,2,0,Math.PI*2); ctx.fill();
        // Badge
        ctx.fillStyle='#FFD700';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(36,44,8,8,2);ctx.fill();}else ctx.fillRect(36,44,8,8);
        ctx.fillStyle='#FFEC80'; ctx.beginPath(); ctx.arc(40,48,2,0,Math.PI*2); ctx.fill();
        // Belt
        ctx.fillStyle='#222'; ctx.fillRect(22,70,34,5);
        ctx.fillStyle='#FFD700'; ctx.fillRect(32,70,6,5);
        // Near arm + clipboard (slight swing)
        const armSwing = frame === 1 ? -3 : 0;
        ctx.fillStyle='#333366'; ctx.fillRect(14,42 + armSwing,8,12);
        ctx.fillStyle='#FFD4A3'; ctx.fillRect(10,52 + armSwing,8,10);
        // Clipboard
        ctx.fillStyle='#FFF';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(4,46 + armSwing,12,18,2);ctx.fill();}else ctx.fillRect(4,46 + armSwing,12,18);
        ctx.fillStyle='#DD3333'; ctx.fillRect(6,48 + armSwing,8,3);
        ctx.fillStyle='#222'; ctx.fillRect(6,53 + armSwing,6,1); ctx.fillRect(6,56 + armSwing,6,1);
        // Far arm (swings opposite)
        ctx.fillStyle='#222244'; ctx.fillRect(54,44 - armSwing,6,12);
        ctx.fillStyle='#EEC090'; ctx.fillRect(54,56 - armSwing,6,6);
        ctx.restore();
    }
    genTex(scene, 'ordnungsamt', 80, 120, (ctx,w,h) => drawOrdnungsamt(ctx,w,h,0));
    genTex(scene, 'ordnungsamt_run_0', 80, 120, (ctx,w,h) => drawOrdnungsamt(ctx,w,h,0));
    genTex(scene, 'ordnungsamt_run_1', 80, 120, (ctx,w,h) => drawOrdnungsamt(ctx,w,h,1));

    // Cat (70x55)
    genTex(scene, 'cat', 70, 55, (ctx,w,h) => {
        ctx.save();
        // Body
        ctx.fillStyle='#FF8833';
        ctx.beginPath(); ctx.ellipse(32,30,20,12,0,0,Math.PI*2); ctx.fill();
        // Stripes
        ctx.strokeStyle='#DD6622'; ctx.lineWidth=2;
        for(let i=0;i<4;i++){ctx.beginPath();ctx.moveTo(20+i*8,20);ctx.lineTo(22+i*8,40);ctx.stroke();}
        // Belly
        ctx.fillStyle='#FFAA55'; ctx.beginPath(); ctx.ellipse(32,36,14,6,0,0,Math.PI*2); ctx.fill();
        // Head
        ctx.fillStyle='#FF8833'; ctx.beginPath(); ctx.arc(10,20,12,0,Math.PI*2); ctx.fill();
        // Ears
        ctx.beginPath(); ctx.moveTo(2,10); ctx.lineTo(-2,0); ctx.lineTo(8,6); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(16,10); ctx.lineTo(20,0); ctx.lineTo(12,6); ctx.closePath(); ctx.fill();
        ctx.fillStyle='#FF6622';
        ctx.beginPath(); ctx.moveTo(3,9); ctx.lineTo(0,2); ctx.lineTo(7,6); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(15,9); ctx.lineTo(18,2); ctx.lineTo(13,6); ctx.closePath(); ctx.fill();
        // Eyes
        ctx.fillStyle='#33CC33';
        ctx.beginPath(); ctx.ellipse(6,18,3,4,0,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(14,18,3,4,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#111';
        ctx.beginPath(); ctx.ellipse(6,18,1.5,3,0,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(14,18,1.5,3,0,0,Math.PI*2); ctx.fill();
        // Nose
        ctx.fillStyle='#FF6688'; ctx.beginPath(); ctx.arc(10,22,2,0,Math.PI*2); ctx.fill();
        // Whiskers
        ctx.strokeStyle='#FFCCAA'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(0,20); ctx.lineTo(-6,18); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,22); ctx.lineTo(-6,24); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(20,20); ctx.lineTo(26,18); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(20,22); ctx.lineTo(26,24); ctx.stroke();
        // Legs
        ctx.fillStyle='#FF8833';
        ctx.fillRect(18,38,8,14); ctx.fillRect(42,38,8,14);
        ctx.fillStyle='#FFAA55'; ctx.fillRect(19,50,6,3); ctx.fillRect(43,50,6,3);
        // Bushy tail
        ctx.fillStyle='#FF8833';
        ctx.beginPath();
        ctx.moveTo(52,24); ctx.bezierCurveTo(58,18,64,14,66,10);
        ctx.bezierCurveTo(68,8,66,12,62,18);
        ctx.bezierCurveTo(58,24,54,28,52,30);
        ctx.closePath(); ctx.fill();
        ctx.fillStyle='#DD6622'; ctx.beginPath(); ctx.arc(64,12,2,0,Math.PI*2); ctx.fill();
        ctx.restore();
    });

    // Strange dog (100x75) - mean-looking mutt
    genTex(scene, 'strange_dog', 100, 75, (ctx,w,h) => {
        ctx.save();
        ctx.lineCap = 'round';
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.beginPath(); ctx.ellipse(50, 72, 32, 4, 0, 0, Math.PI*2); ctx.fill();
        // Body (muscular, scruffy)
        const bodyGrad = ctx.createLinearGradient(50, 16, 50, 54);
        bodyGrad.addColorStop(0, '#664422'); bodyGrad.addColorStop(0.5, '#996633'); bodyGrad.addColorStop(1, '#886622');
        ctx.fillStyle = bodyGrad;
        ctx.beginPath(); ctx.ellipse(52, 34, 30, 20, 0, 0, Math.PI*2); ctx.fill();
        // Scruffy fur patches
        ctx.fillStyle = '#774422';
        ctx.beginPath(); ctx.ellipse(58, 26, 12, 6, 0.3, 0, Math.PI*2); ctx.fill();
        // Belly
        ctx.fillStyle = '#AA8844';
        ctx.beginPath(); ctx.ellipse(48, 44, 18, 8, 0.1, 0, Math.PI*2); ctx.fill();
        // Legs (thick, strong)
        drawDogLeg(ctx, 30, 48, 14, 20, '#996633', '#664422');
        drawDogLeg(ctx, 62, 48, 14, 20, '#996633', '#664422');
        // Neck
        ctx.fillStyle = '#996633';
        ctx.beginPath(); ctx.ellipse(26, 28, 12, 16, -0.15, 0, Math.PI*2); ctx.fill();
        // Head (angular, aggressive)
        ctx.fillStyle = '#996633';
        ctx.beginPath(); ctx.ellipse(24, 20, 16, 14, -0.05, 0, Math.PI*2); ctx.fill();
        // Snout
        ctx.fillStyle = '#AA8844';
        ctx.beginPath(); ctx.ellipse(12, 26, 10, 7, -0.2, 0, Math.PI*2); ctx.fill();
        // Angry V-brows
        ctx.strokeStyle = '#222'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(14, 10); ctx.lineTo(22, 14); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(32, 10); ctx.lineTo(24, 14); ctx.stroke();
        // Red angry eyes
        ctx.fillStyle = '#CC3333'; ctx.beginPath(); ctx.arc(20, 16, 4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(21, 16, 2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#CC3333'; ctx.beginPath(); ctx.arc(30, 16, 4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(31, 16, 2, 0, Math.PI*2); ctx.fill();
        // Snarling mouth with teeth
        ctx.fillStyle = '#AA2222';
        ctx.beginPath(); ctx.ellipse(14, 30, 8, 5, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#FFF';
        ctx.beginPath(); ctx.moveTo(9, 28); ctx.lineTo(11, 25); ctx.lineTo(13, 28); ctx.fill();
        ctx.beginPath(); ctx.moveTo(15, 28); ctx.lineTo(17, 25); ctx.lineTo(19, 28); ctx.fill();
        ctx.beginPath(); ctx.moveTo(9, 32); ctx.lineTo(11, 35); ctx.lineTo(13, 32); ctx.fill();
        ctx.beginPath(); ctx.moveTo(15, 32); ctx.lineTo(17, 35); ctx.lineTo(19, 32); ctx.fill();
        // Drool
        ctx.fillStyle = 'rgba(130,180,220,0.5)';
        ctx.beginPath(); ctx.ellipse(12, 38, 3, 4, 0, 0, Math.PI*2); ctx.fill();
        // Nose
        ctx.fillStyle = '#222'; ctx.beginPath(); ctx.ellipse(6, 24, 4, 3, 0, 0, Math.PI*2); ctx.fill();
        // Pointed alert ears
        ctx.fillStyle = '#774422';
        ctx.beginPath(); ctx.moveTo(16, 8); ctx.lineTo(10, -2); ctx.lineTo(24, 6); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(32, 8); ctx.lineTo(38, -2); ctx.lineTo(28, 6); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#996633';
        ctx.beginPath(); ctx.moveTo(17, 6); ctx.lineTo(13, 1); ctx.lineTo(22, 5); ctx.closePath(); ctx.fill();
        // Bristled tail (raised, aggressive)
        ctx.strokeStyle = '#996633'; ctx.lineWidth = 6;
        ctx.beginPath(); ctx.moveTo(82, 26); ctx.bezierCurveTo(88, 14, 92, 6, 94, 2); ctx.stroke();
        ctx.strokeStyle = '#774422'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(90, 8); ctx.lineTo(96, 2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(88, 12); ctx.lineTo(94, 8); ctx.stroke();
        ctx.restore();
    });

    // Ticket (35x45)
    genTex(scene, 'ticket', 35, 45, (ctx,w,h) => {
        ctx.fillStyle='#FFF';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(0,0,35,45,3);ctx.fill();}else ctx.fillRect(0,0,35,45);
        ctx.fillStyle='#DDD'; ctx.fillRect(33,0,2,45);
        // Red header
        ctx.fillStyle='#DD3333';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(2,2,31,8,2);ctx.fill();}else ctx.fillRect(2,2,31,8);
        // Text lines
        ctx.fillStyle='#222';
        ctx.fillRect(3,14,22,2); ctx.fillRect(3,20,18,2);
        ctx.fillRect(3,26,22,2); ctx.fillRect(3,32,15,2);
        // Stamp
        ctx.fillStyle='#DD3333';
        ctx.beginPath(); ctx.arc(27,36,5,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FF4444';
        ctx.beginPath(); ctx.arc(27,36,3,0,Math.PI*2); ctx.fill();
    });

    // Coin (28x28)
    genTex(scene, 'coin', 28, 28, (ctx,w,h) => {
        const grad = ctx.createRadialGradient(12,10,2,14,14,14);
        grad.addColorStop(0, '#FFEC80');
        grad.addColorStop(0.7, '#FFD700');
        grad.addColorStop(1, '#B8860B');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(14,14,13,0,Math.PI*2); ctx.fill();
        // Euro symbol
        ctx.strokeStyle='#B8860B'; ctx.lineWidth=2.5; ctx.lineCap='round';
        ctx.beginPath(); ctx.arc(14,14,6,0.5,5.8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(8,12); ctx.lineTo(16,12); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(8,16); ctx.lineTo(16,16); ctx.stroke();
        // Shine
        ctx.fillStyle='rgba(255,255,255,0.4)';
        ctx.beginPath(); ctx.arc(10,8,4,0,Math.PI*2); ctx.fill();
    });

    // Bag (30x40)
    genTex(scene, 'bag', 30, 40, (ctx,w,h) => {
        const bg = ctx.createLinearGradient(0,8,30,40);
        bg.addColorStop(0,'#2A9922'); bg.addColorStop(1,'#1A6618');
        ctx.fillStyle = bg;
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(2,10,26,28,4);ctx.fill();}else ctx.fillRect(2,10,26,28);
        // Drawstring
        ctx.fillStyle='#228822'; ctx.fillRect(8,2,14,10);
        ctx.fillStyle='#44AA44';
        ctx.beginPath(); ctx.arc(10,8,4,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(20,8,4,0,Math.PI*2); ctx.fill();
        // Recycling hint
        ctx.fillStyle='#44AA44';
        ctx.beginPath(); ctx.arc(15,26,5,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#55BB55';
        ctx.strokeStyle='#55BB55'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(12,24); ctx.lineTo(15,20); ctx.lineTo(18,24); ctx.stroke();
    });

    // --- BACKGROUND ELEMENTS ---
    // House (150x140)
    genTex(scene, 'house', 150, 140, (ctx,w,h) => {
        const wallColors=['#CC8866','#AAAA88','#BBBB99','#DDAA77'];
        const wc=wallColors[Math.floor(Math.random()*4)];
        // Wall
        const wg=ctx.createLinearGradient(10,40,140,140);
        wg.addColorStop(0, wc); wg.addColorStop(1, darken(parseInt(wc.slice(1),16),20));
        ctx.fillStyle=wg;
        ctx.fillRect(10,40,130,100);
        // Brick lines
        ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.lineWidth=1;
        for(let y=50;y<140;y+=12){ctx.beginPath();ctx.moveTo(10,y);ctx.lineTo(140,y);ctx.stroke();}
        for(let x=20;x<140;x+=24){ctx.beginPath();ctx.moveTo(x,40);ctx.lineTo(x,140);ctx.stroke();}
        // Roof
        ctx.fillStyle='#883333';
        ctx.beginPath(); ctx.moveTo(0,42); ctx.lineTo(75,8); ctx.lineTo(150,42); ctx.closePath(); ctx.fill();
        ctx.fillStyle='#993344';
        ctx.beginPath(); ctx.moveTo(0,42); ctx.lineTo(75,8); ctx.lineTo(75,42); ctx.closePath(); ctx.fill();
        // Gutter
        ctx.fillStyle='#888'; ctx.fillRect(0,40,150,3);
        // Chimney
        ctx.fillStyle='#884433'; ctx.fillRect(110,12,16,30);
        // Door
        ctx.fillStyle='#664422';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(58,85,34,55,[6,6,0,0]);ctx.fill();}else ctx.fillRect(58,85,34,55);
        ctx.fillStyle='#FFD700'; ctx.beginPath(); ctx.arc(84,112,3,0,Math.PI*2); ctx.fill();
        // Windows
        ctx.fillStyle='#88CCFF';
        ctx.fillRect(20,58,24,18); ctx.fillRect(106,58,24,18);
        // Crossbars
        ctx.fillStyle='#664422';
        ctx.fillRect(20,66,24,2); ctx.fillRect(31,58,2,18);
        ctx.fillRect(106,66,24,2); ctx.fillRect(117,58,2,18);
        // Window shine
        ctx.fillStyle='rgba(255,255,255,0.3)';
        ctx.fillRect(22,60,8,6); ctx.fillRect(108,60,8,6);
        // Flower boxes
        ctx.fillStyle='#664422';
        ctx.fillRect(18,76,28,5); ctx.fillRect(104,76,28,5);
        ctx.fillStyle='#FF6688'; ctx.beginPath(); ctx.arc(24,74,3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FFAA33'; ctx.beginPath(); ctx.arc(34,74,3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FF6688'; ctx.beginPath(); ctx.arc(110,74,3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FFAA33'; ctx.beginPath(); ctx.arc(120,74,3,0,Math.PI*2); ctx.fill();
    });
    // Tree (80x130)
    genTex(scene, 'tree', 80, 130, (ctx,w,h) => {
        // Trunk (starts higher, overlaps with foliage)
        ctx.fillStyle='#664422';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(30,55,20,73,4);ctx.fill();}else ctx.fillRect(30,55,20,73);
        // Bark texture
        ctx.strokeStyle='#553311'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(34,60); ctx.lineTo(36,85); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(44,65); ctx.lineTo(42,90); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(38,90); ctx.lineTo(40,115); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(36,105); ctx.lineTo(38,125); ctx.stroke();
        // Roots at base
        ctx.fillStyle='#553311';
        ctx.beginPath(); ctx.ellipse(32, 126, 8, 3, -0.2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(48, 126, 8, 3, 0.2, 0, Math.PI*2); ctx.fill();
        // Foliage (overlapping circles - bigger, connected to trunk)
        const greens=['#338833','#44AA44','#55BB55','#449944'];
        const circles=[
            [40,55,20],[20,55,14],[58,55,14],  // bottom row - covers trunk top
            [40,35,22],[20,42,18],[58,40,16],   // middle row
            [30,20,16],[50,22,14],               // upper row
            [14,30,12],[64,32,12],               // sides
            [40,12,12],[25,10,10],[55,12,10],    // top
        ];
        circles.forEach(([cx,cy,r],i)=>{
            ctx.fillStyle=greens[i%greens.length];
            ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
        });
        // Highlight circles
        ctx.fillStyle='#66CC66';
        ctx.beginPath(); ctx.arc(30,18,6,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(50,14,5,0,Math.PI*2); ctx.fill();
        // Fruits
        ctx.fillStyle='#FF4444'; ctx.beginPath(); ctx.arc(22,42,3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FF6666'; ctx.beginPath(); ctx.arc(56,30,3,0,Math.PI*2); ctx.fill();
    });
    // Bush (55x40)
    genTex(scene, 'bush', 55, 40, (ctx,w,h) => {
        ctx.fillStyle='#338833';
        ctx.beginPath(); ctx.arc(28,24,18,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#44AA44';
        ctx.beginPath(); ctx.arc(16,26,14,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(40,22,14,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#55BB55';
        ctx.beginPath(); ctx.arc(22,16,10,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(36,16,8,0,Math.PI*2); ctx.fill();
        // Flowers
        ctx.fillStyle='#FF88AA'; ctx.beginPath(); ctx.arc(12,16,3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FFDD44'; ctx.beginPath(); ctx.arc(38,12,3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FF88AA'; ctx.beginPath(); ctx.arc(44,28,2,0,Math.PI*2); ctx.fill();
    });
    // Cloud (120x50)
    genTex(scene, 'cloud', 120, 50, (ctx,w,h) => {
        ctx.fillStyle='rgba(220,220,238,0.6)';
        ctx.beginPath(); ctx.ellipse(60,34,56,14,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FFFFFF';
        ctx.beginPath(); ctx.ellipse(60,22,40,14,0,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(30,28,22,12,0,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(90,26,20,10,0,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(45,14,16,10,0,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(75,16,14,8,0,0,Math.PI*2); ctx.fill();
    });
    // Fog cloud (200x80)
    genTex(scene, 'fog_cloud', 200, 80, (ctx,w,h) => {
        ctx.fillStyle='rgba(200,200,200,0.5)';
        ctx.beginPath(); ctx.ellipse(100,50,96,28,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(180,180,180,0.4)';
        ctx.beginPath(); ctx.ellipse(100,36,80,22,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(210,210,210,0.45)';
        ctx.beginPath(); ctx.ellipse(60,44,50,20,0,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(140,44,50,20,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(190,190,190,0.35)';
        ctx.beginPath(); ctx.ellipse(100,24,60,16,0,0,Math.PI*2); ctx.fill();
    });
    // Fence (80x45)
    genTex(scene, 'fence', 80, 45, (ctx,w,h) => {
        // Rails
        ctx.fillStyle='#CCAA77';
        if(ctx.roundRect){ctx.beginPath();ctx.roundRect(0,12,80,5,2);ctx.fill();ctx.beginPath();ctx.roundRect(0,30,80,5,2);ctx.fill();}
        else{ctx.fillRect(0,12,80,5);ctx.fillRect(0,30,80,5);}
        // Posts
        ctx.fillStyle='#BB9966';
        for(let i=0;i<80;i+=16){
            if(ctx.roundRect){ctx.beginPath();ctx.roundRect(i,0,6,45,2);ctx.fill();}else ctx.fillRect(i,0,6,45);
            ctx.fillStyle='#AA8855'; ctx.fillRect(i+1,8,4,2);ctx.fillRect(i+1,26,4,2);
            ctx.fillStyle='#666'; ctx.beginPath();ctx.arc(i+3,14,1.5,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.arc(i+3,32,1.5,0,Math.PI*2);ctx.fill();
            ctx.fillStyle='#BB9966';
        }
    });

    // Raindrop (6x15)
    genTex(scene, 'raindrop', 6, 15, (ctx,w,h) => {
        const grad=ctx.createLinearGradient(3,0,3,15);
        grad.addColorStop(0,'#4466AA');grad.addColorStop(1,'#99BBEE');
        ctx.fillStyle=grad;
        ctx.beginPath();
        ctx.moveTo(3,0);
        ctx.bezierCurveTo(0,6,0,12,3,15);
        ctx.bezierCurveTo(6,12,6,6,3,0);
        ctx.closePath(); ctx.fill();
    });
    // Snowflake (10x10)
    genTex(scene, 'snowflake', 10, 10, (ctx,w,h) => {
        ctx.strokeStyle='#FFFFFF'; ctx.lineWidth=1.5; ctx.lineCap='round';
        ctx.beginPath(); ctx.moveTo(5,0); ctx.lineTo(5,10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,5); ctx.lineTo(10,5); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(1.5,1.5); ctx.lineTo(8.5,8.5); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(8.5,1.5); ctx.lineTo(1.5,8.5); ctx.stroke();
        ctx.fillStyle='#DDEEFF'; ctx.beginPath(); ctx.arc(5,5,2,0,Math.PI*2); ctx.fill();
    });

    // Ground tiles (100x20 each)
    genTex(scene, 'sidewalk_tile', 100, 20, (ctx,w,h) => {
        ctx.fillStyle='#BBBBBB'; ctx.fillRect(0,0,100,20);
        ctx.fillStyle='#DDDDDD'; ctx.fillRect(0,0,100,2);
        // Grid
        ctx.strokeStyle='#AAAAAA'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(0,10); ctx.lineTo(100,10); ctx.stroke();
        for(let x=0;x<100;x+=25){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,20);ctx.stroke();}
        // Texture
        ctx.fillStyle='#A5A5A5';
        [15,42,68,85].forEach(x=>{ctx.beginPath();ctx.arc(x,6,1,0,Math.PI*2);ctx.fill();});
        [8,35,58,78].forEach(x=>{ctx.beginPath();ctx.arc(x,14,1,0,Math.PI*2);ctx.fill();});
        ctx.fillStyle='#999'; ctx.fillRect(0,18,100,2);
    });
    genTex(scene, 'road_tile', 100, 80, (ctx,w,h) => {
        // Full road surface
        ctx.fillStyle='#555555'; ctx.fillRect(0,0,100,80);
        // Slight gradient for depth
        const grad = ctx.createLinearGradient(0,0,0,80);
        grad.addColorStop(0, '#666666'); grad.addColorStop(0.5, '#555555'); grad.addColorStop(1, '#4A4A4A');
        ctx.fillStyle = grad; ctx.fillRect(0,0,100,80);
        // Curb at top (lighter edge)
        ctx.fillStyle='#888'; ctx.fillRect(0,0,100,3);
        ctx.fillStyle='#999'; ctx.fillRect(0,0,100,1);
        // Dashed white lane marking
        ctx.fillStyle='#DDDDDD';
        ctx.fillRect(15,36,22,3); ctx.fillRect(55,36,22,3);
        // Asphalt texture spots
        ctx.fillStyle='#4A4A4A';
        [8,22,38,55,72,88].forEach(x=>{ctx.beginPath();ctx.arc(x,12+Math.random()*55,1.5,0,Math.PI*2);ctx.fill();});
        [15,30,48,65,80].forEach(x=>{ctx.beginPath();ctx.arc(x,8+Math.random()*60,1,0,Math.PI*2);ctx.fill();});
    });
    genTex(scene, 'grass_tile', 100, 20, (ctx,w,h) => {
        ctx.fillStyle='#55AA55'; ctx.fillRect(0,0,100,20);
        ctx.fillStyle='#449944'; ctx.fillRect(0,0,100,2);
        ctx.strokeStyle='#66BB66'; ctx.lineWidth=1;
        for(let x=4;x<100;x+=6){
            ctx.beginPath();ctx.moveTo(x,Math.random()*6);ctx.lineTo(x+1,8+Math.random()*4);ctx.stroke();
        }
        ctx.fillStyle='#FFDD44'; ctx.beginPath();ctx.arc(15,6,2,0,Math.PI*2);ctx.fill();
        ctx.fillStyle='#FF88AA'; ctx.beginPath();ctx.arc(45,12,2,0,Math.PI*2);ctx.fill();
        ctx.fillStyle='#FFDD44'; ctx.beginPath();ctx.arc(72,4,2,0,Math.PI*2);ctx.fill();
        ctx.fillStyle='#FF88AA'; ctx.beginPath();ctx.arc(90,10,2,0,Math.PI*2);ctx.fill();
        ctx.fillStyle='#998866';
        [10,30,55,80].forEach(x=>{ctx.beginPath();ctx.arc(x,16,1,0,Math.PI*2);ctx.fill();});
    });

    // Heart (22x20)
    genTex(scene, 'heart', 22, 20, (ctx,w,h) => {
        ctx.fillStyle='#DD3333';
        ctx.beginPath();
        ctx.moveTo(11,18);
        ctx.bezierCurveTo(0,12,0,2,6,2);
        ctx.bezierCurveTo(9,2,11,5,11,5);
        ctx.bezierCurveTo(11,5,13,2,16,2);
        ctx.bezierCurveTo(22,2,22,12,11,18);
        ctx.closePath(); ctx.fill();
        ctx.fillStyle='rgba(255,100,100,0.4)';
        ctx.beginPath(); ctx.arc(7,6,3,0,Math.PI*2); ctx.fill();
    });

    // Buttons (40x40)
    genTex(scene, 'btn_jump', 40, 40, (ctx,w,h) => {
        ctx.strokeStyle='#FFFFFF'; ctx.lineWidth=4; ctx.lineCap='round';
        ctx.beginPath(); ctx.moveTo(20,30); ctx.lineTo(20,10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(10,18); ctx.lineTo(20,8); ctx.lineTo(30,18); ctx.stroke();
    });
    genTex(scene, 'btn_collect', 40, 40, (ctx,w,h) => {
        ctx.strokeStyle='#FFFFFF'; ctx.lineWidth=3; ctx.lineCap='round';
        // Hand/grab icon
        ctx.beginPath(); ctx.arc(20,18,8,Math.PI,0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(12,18); ctx.lineTo(12,28); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(28,18); ctx.lineTo(28,28); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(12,28); ctx.lineTo(28,28); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(16,28); ctx.lineTo(16,34); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(24,28); ctx.lineTo(24,34); ctx.stroke();
    });

    // === BOSS FIGHT SPRITES ===

    // Boss Tonne helper
    function drawBossTonne(ctx, w, h, phase, state, opts) {
      opts = opts || {};
      const colors = {
        1: { body: 0x4A8C3F, eye: 0xFFDD00, lid: 0x3A6C2F },
        2: { body: 0xC4A832, eye: 0xFF8800, lid: 0x9A8222 },
        3: { body: 0x8B2020, eye: 0xFF2200, lid: 0x6B1010 }
      };
      const c = colors[phase];
      const bx = 15, by = 30, bw = w - 30, bh = h - 50;

      // Wheels
      ctx.fillStyle = '#333';
      ctx.beginPath(); ctx.arc(35, h - 8, 8, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(w - 35, h - 8, 8, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#555';
      ctx.beginPath(); ctx.arc(35, h - 8, 4, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(w - 35, h - 8, 4, 0, Math.PI * 2); ctx.fill();

      // Body (rounded rect)
      const r = 12;
      ctx.fillStyle = hexC(c.body);
      ctx.beginPath();
      ctx.moveTo(bx + r, by + bh); ctx.lineTo(bx + bw - r, by + bh);
      ctx.quadraticCurveTo(bx + bw + 4, by + bh, bx + bw + 2, by + bh - r);
      ctx.lineTo(bx + bw - 4, by + r); ctx.quadraticCurveTo(bx + bw - 5, by, bx + bw - r - 5, by);
      ctx.lineTo(bx + r + 5, by); ctx.quadraticCurveTo(bx + 5, by, bx + 4, by + r);
      ctx.lineTo(bx - 2, by + bh - r); ctx.quadraticCurveTo(bx - 4, by + bh, bx + r, by + bh);
      ctx.fill();

      // Body highlight
      ctx.fillStyle = rgba(0xFFFFFF, 0.15);
      ctx.fillRect(bx + 8, by + 10, 14, bh - 20);
      // Body shadow
      ctx.fillStyle = rgba(0x000000, 0.15);
      ctx.fillRect(bx + bw - 18, by + 10, 12, bh - 20);

      // Ridges on body
      ctx.strokeStyle = darken(c.body, 30);
      ctx.lineWidth = 1;
      for (let i = 1; i <= 3; i++) {
        const ry = by + (bh * i) / 4;
        ctx.beginPath(); ctx.moveTo(bx + 6, ry); ctx.lineTo(bx + bw - 6, ry); ctx.stroke();
      }

      // Arms/handles
      if (!opts.skipArms) {
        ctx.strokeStyle = darken(c.body, 40);
        ctx.lineWidth = 4; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(bx - 2, by + 40); ctx.lineTo(bx - 10, by + 55); ctx.lineTo(bx - 6, by + 70); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(bx + bw + 2, by + 40); ctx.lineTo(bx + bw + 10, by + 55); ctx.lineTo(bx + bw + 6, by + 70); ctx.stroke();
      }

      if (opts.skipLid) {
        // Body-only mode: draw flat top (no lid, no interior hole)
        // The separate lid sprite covers this; interior sprite shows when lid opens
        ctx.fillStyle = darken(c.body, 20);
        ctx.beginPath(); ctx.ellipse(w / 2, by + 4, bw / 2 - 2, 10, 0, 0, Math.PI * 2); ctx.fill();
      } else if (state === 'open') {
        // Dark interior
        ctx.fillStyle = '#1a1a0a';
        ctx.beginPath(); ctx.ellipse(w / 2, by + 10, bw / 2 - 6, 16, 0, 0, Math.PI * 2); ctx.fill();
        // Green glow
        const grd = ctx.createRadialGradient(w / 2, by + 6, 2, w / 2, by + 6, 30);
        grd.addColorStop(0, rgba(0x44FF44, 0.5)); grd.addColorStop(1, rgba(0x44FF44, 0));
        ctx.fillStyle = grd; ctx.fillRect(bx, by - 10, bw, 30);
        // Lid open (tilted back)
        ctx.save(); ctx.translate(w / 2, by - 2); ctx.rotate(-0.8);
        ctx.fillStyle = hexC(c.lid);
        ctx.beginPath(); ctx.ellipse(0, -6, bw / 2 + 2, 10, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillRect(-bw / 2, -14, bw, 10);
        ctx.fillStyle = darken(c.lid, 20); ctx.fillRect(-12, -20, 24, 8);
        ctx.restore();
      } else {
        // Lid closed
        ctx.fillStyle = hexC(c.lid);
        ctx.beginPath(); ctx.ellipse(w / 2, by + 2, bw / 2 + 3, 10, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = darken(c.lid, 10); ctx.fillRect(w / 2 - 14, by - 10, 28, 10);
        ctx.fillStyle = darken(c.lid, 30); ctx.fillRect(w / 2 - 10, by - 12, 20, 6);
      }

      // Eyes
      const eyeY = by + bh * 0.35, eyeS = 12, exL = w / 2 - 16, exR = w / 2 + 16;
      ctx.fillStyle = '#FFF';
      ctx.beginPath(); ctx.ellipse(exL, eyeY, eyeS, eyeS - 2, 0, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(exR, eyeY, eyeS, eyeS - 2, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = hexC(c.eye);
      ctx.beginPath(); ctx.arc(exL, eyeY + 1, 7, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(exR, eyeY + 1, 7, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath(); ctx.arc(exL, eyeY + 2, 3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(exR, eyeY + 2, 3, 0, Math.PI * 2); ctx.fill();
      // Angry brows
      ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(exL - 12, eyeY - 14); ctx.lineTo(exL + 8, eyeY - 8); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(exR + 12, eyeY - 14); ctx.lineTo(exR - 8, eyeY - 8); ctx.stroke();
      // Mouth
      ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(w / 2 - 18, by + bh * 0.6);
      ctx.quadraticCurveTo(w / 2, by + bh * 0.55, w / 2 + 18, by + bh * 0.6); ctx.stroke();
      if (phase >= 2) {
        ctx.fillStyle = '#FFF';
        for (let t = 0; t < 4; t++) {
          const tx = w / 2 - 12 + t * 8, ty = by + bh * 0.58;
          ctx.beginPath(); ctx.moveTo(tx, ty); ctx.lineTo(tx + 3, ty + 5); ctx.lineTo(tx + 6, ty); ctx.fill();
        }
      }
    }

    // Phase variants
    for (let p = 1; p <= 3; p++) {
      for (const st of ['closed', 'open']) {
        genTex(scene, `boss_tonne_${p}_${st}`, 120, 160, (ctx, w, h) => {
          drawBossTonne(ctx, w, h, p, st);
        });
      }
    }

    // === Body-only sprites (no arms, no lid - for composite boss) ===
    for (let p = 1; p <= 3; p++) {
      genTex(scene, `boss_body_${p}`, 120, 160, (ctx, w, h) => {
        drawBossTonne(ctx, w, h, p, 'closed', { skipArms: true, skipLid: true });
      });
    }

    // === Interior sprite (dark hole visible when lid opens) ===
    genTex(scene, 'boss_interior', 84, 28, (ctx, w, h) => {
      // Dark interior hole
      ctx.fillStyle = '#1a1a0a';
      ctx.beginPath(); ctx.ellipse(w/2, h/2 + 2, w/2 - 3, 12, 0, 0, Math.PI * 2); ctx.fill();
      // Trash bits inside
      ctx.fillStyle = '#333320';
      ctx.fillRect(w/2 - 15, h/2, 8, 6);
      ctx.fillRect(w/2 + 5, h/2 - 2, 10, 5);
      ctx.fillRect(w/2 - 5, h/2 + 3, 6, 4);
      // Rim highlight
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.ellipse(w/2, h/2, w/2 - 5, 10, 0, Math.PI, Math.PI * 2); ctx.stroke();
    });

    // === Arm sprites (one for each phase color) ===
    const armColors = { 1: 0x4A8C3F, 2: 0xC4A832, 3: 0x8B2020 };
    for (let p = 1; p <= 3; p++) {
      genTex(scene, `boss_arm_${p}`, 24, 40, (ctx, w, h) => {
        const baseCol = armColors[p];
        // Upper arm
        ctx.strokeStyle = darken(baseCol, 40);
        ctx.lineWidth = 5; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(w/2, 4);       // shoulder
        ctx.lineTo(w/2 + 6, 18);  // elbow
        ctx.lineTo(w/2 + 3, 32);  // wrist
        ctx.stroke();
        // Hand/gripper
        ctx.fillStyle = darken(baseCol, 30);
        ctx.beginPath(); ctx.arc(w/2 + 3, 33, 5, 0, Math.PI * 2); ctx.fill();
        // Fingers
        ctx.strokeStyle = darken(baseCol, 50);
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(w/2, 36); ctx.lineTo(w/2 - 2, 39); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(w/2 + 3, 37); ctx.lineTo(w/2 + 3, 40); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(w/2 + 6, 36); ctx.lineTo(w/2 + 8, 39); ctx.stroke();
      });
    }

    // === Lid sprites (one for each phase color) ===
    const lidColorsMap = { 1: 0x3A6C2F, 2: 0x9A8222, 3: 0x6B1010 };
    for (let p = 1; p <= 3; p++) {
      genTex(scene, `boss_lid_${p}`, 100, 36, (ctx, w, h) => {
        const lc = lidColorsMap[p];
        // Main lid body (elliptical) - positioned at bottom of sprite
        ctx.fillStyle = hexC(lc);
        ctx.beginPath(); ctx.ellipse(w/2, h - 8, 48, 12, 0, 0, Math.PI * 2); ctx.fill();
        // Bottom edge shadow
        ctx.fillStyle = darken(lc, 25);
        ctx.beginPath(); ctx.ellipse(w/2, h - 5, 46, 6, 0, 0, Math.PI); ctx.fill();
        // Highlight
        ctx.fillStyle = rgba(0xFFFFFF, 0.15);
        ctx.beginPath(); ctx.ellipse(w/2 - 10, h - 12, 20, 5, 0, 0, Math.PI * 2); ctx.fill();
        // Handle on top
        ctx.fillStyle = darken(lc, 15);
        ctx.fillRect(w/2 - 14, 2, 28, 14);
        ctx.fillStyle = darken(lc, 30);
        ctx.fillRect(w/2 - 10, 0, 20, 8);
        // Handle highlight
        ctx.fillStyle = rgba(0xFFFFFF, 0.2);
        ctx.fillRect(w/2 - 8, 2, 8, 5);
      });
    }

    // Hurt variant
    genTex(scene, 'boss_tonne_hurt', 120, 160, (ctx, w, h) => {
      ctx.save(); ctx.globalAlpha = 0.8;
      drawBossTonne(ctx, w, h, 1, 'closed');
      ctx.restore();
      ctx.fillStyle = rgba(0xFF0000, 0.35); ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = '#FFD700';
      const drawStar = (cx, cy, s) => {
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const a = -Math.PI / 2 + (i * 2 * Math.PI) / 5, ai = a + Math.PI / 5;
          ctx.lineTo(cx + Math.cos(a) * s, cy + Math.sin(a) * s);
          ctx.lineTo(cx + Math.cos(ai) * s * 0.4, cy + Math.sin(ai) * s * 0.4);
        }
        ctx.closePath(); ctx.fill();
      };
      drawStar(30, 14, 8); drawStar(60, 8, 6); drawStar(90, 14, 8);
    });

    // Defeat variant
    genTex(scene, 'boss_tonne_defeat', 120, 160, (ctx, w, h) => {
      const cx = w / 2, cy = h / 2;
      const grd = ctx.createRadialGradient(cx, cy, 5, cx, cy, 60);
      grd.addColorStop(0, '#FFFF00'); grd.addColorStop(0.5, '#FF8800'); grd.addColorStop(1, rgba(0xFF4400, 0));
      ctx.fillStyle = grd; ctx.fillRect(0, 0, w, h);
      [[20,30,0.3],[80,25,-0.4],[30,110,0.5],[85,105,-0.2],[55,20,0.1],[50,130,-0.3]].forEach(([px,py,rot]) => {
        ctx.save(); ctx.translate(px, py); ctx.rotate(rot);
        ctx.fillStyle = hexC(0x4A8C3F); ctx.fillRect(-10, -8, 20, 16);
        ctx.fillStyle = darken(0x4A8C3F, 30); ctx.fillRect(-10, -8, 20, 4);
        ctx.restore();
      });
      ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2;
      [cx - 15, cx + 15].forEach(ex => {
        ctx.beginPath(); ctx.moveTo(ex - 6, cy - 16); ctx.lineTo(ex + 6, cy - 8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ex + 6, cy - 16); ctx.lineTo(ex - 6, cy - 8); ctx.stroke();
      });
    });

    // === PROJECTILES 32x32 ===
    genTex(scene, 'throw_banana', 32, 32, (ctx) => {
      ctx.strokeStyle = '#C8A800'; ctx.fillStyle = '#F5D800'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(8, 24); ctx.quadraticCurveTo(4, 12, 12, 6);
      ctx.quadraticCurveTo(20, 2, 26, 10); ctx.quadraticCurveTo(22, 16, 14, 20);
      ctx.quadraticCurveTo(10, 22, 8, 24); ctx.fill(); ctx.stroke();
      ctx.fillStyle = '#8B6914'; ctx.fillRect(12, 4, 3, 4);
    });
    genTex(scene, 'throw_apple', 32, 32, (ctx) => {
      ctx.fillStyle = '#8B6B3E';
      ctx.beginPath(); ctx.moveTo(12, 8); ctx.lineTo(16, 12); ctx.lineTo(20, 8);
      ctx.lineTo(22, 16); ctx.lineTo(20, 26); ctx.lineTo(12, 26); ctx.lineTo(10, 16); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#6B4B2E'; ctx.beginPath(); ctx.ellipse(16, 18, 3, 2, 0, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = '#5A3A1A'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(16, 8); ctx.lineTo(16, 3); ctx.stroke();
      ctx.fillStyle = '#4A8C3F'; ctx.beginPath(); ctx.ellipse(19, 4, 4, 2, 0.4, 0, Math.PI * 2); ctx.fill();
    });
    genTex(scene, 'throw_eggshell', 32, 32, (ctx) => {
      ctx.fillStyle = '#F5F0E0';
      ctx.beginPath(); ctx.moveTo(4, 20); ctx.quadraticCurveTo(4, 10, 10, 8);
      ctx.lineTo(14, 12); ctx.lineTo(11, 16); ctx.lineTo(15, 20); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(18, 20); ctx.lineTo(20, 16); ctx.lineTo(17, 12);
      ctx.quadraticCurveTo(22, 8, 28, 10); ctx.quadraticCurveTo(28, 20, 26, 22); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#FFB800'; ctx.beginPath(); ctx.ellipse(16, 24, 5, 3, 0, 0, Math.PI * 2); ctx.fill();
    });
    genTex(scene, 'throw_shoe', 32, 32, (ctx) => {
      ctx.fillStyle = '#6B4226';
      ctx.beginPath(); ctx.moveTo(4, 22); ctx.lineTo(4, 14); ctx.quadraticCurveTo(6, 8, 14, 8);
      ctx.lineTo(18, 8); ctx.lineTo(18, 12); ctx.lineTo(28, 14);
      ctx.quadraticCurveTo(30, 18, 28, 22); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#4A2E16'; ctx.fillRect(4, 20, 26, 4);
    });
    genTex(scene, 'throw_fishbone', 32, 32, (ctx) => {
      ctx.strokeStyle = '#AAA'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(4, 16); ctx.lineTo(28, 16); ctx.stroke();
      for (let i = 0; i < 5; i++) {
        const rx = 8 + i * 4;
        ctx.beginPath(); ctx.moveTo(rx, 16); ctx.lineTo(rx - 1, 10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(rx, 16); ctx.lineTo(rx - 1, 22); ctx.stroke();
      }
      ctx.fillStyle = '#BBB'; ctx.beginPath(); ctx.arc(4, 16, 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(3, 15, 1.5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#AAA'; ctx.beginPath(); ctx.moveTo(28, 16); ctx.lineTo(32, 10); ctx.lineTo(32, 22); ctx.closePath(); ctx.fill();
      ctx.strokeStyle = rgba(0x88AA44, 0.6); ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(12, 6); ctx.quadraticCurveTo(14, 3, 12, 0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(18, 7); ctx.quadraticCurveTo(20, 4, 18, 1); ctx.stroke();
    });
    genTex(scene, 'throw_trashbag', 32, 32, (ctx) => {
      ctx.fillStyle = '#2A2A2A';
      ctx.beginPath(); ctx.moveTo(8, 10); ctx.quadraticCurveTo(4, 16, 6, 28);
      ctx.lineTo(26, 28); ctx.quadraticCurveTo(28, 16, 24, 10); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#3A3A3A';
      ctx.beginPath(); ctx.moveTo(10, 10); ctx.quadraticCurveTo(16, 6, 22, 10);
      ctx.lineTo(24, 10); ctx.lineTo(8, 10); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#555'; ctx.fillRect(14, 5, 4, 6);
    });
    genTex(scene, 'throw_paintcan', 32, 32, (ctx) => {
      ctx.fillStyle = '#888'; ctx.fillRect(8, 8, 16, 18);
      ctx.fillStyle = '#FF4444'; ctx.fillRect(8, 10, 16, 6);
      ctx.fillStyle = '#44AAFF'; ctx.fillRect(8, 16, 16, 6);
      ctx.fillStyle = '#999'; ctx.fillRect(7, 7, 18, 3);
      ctx.strokeStyle = '#777'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(16, 6, 6, Math.PI, 0); ctx.stroke();
      ctx.fillStyle = '#FF4444'; ctx.fillRect(10, 26, 3, 4);
      ctx.fillStyle = '#44AAFF'; ctx.fillRect(20, 26, 3, 5);
      ctx.fillStyle = '#FFDD00'; ctx.fillRect(15, 26, 3, 3);
    });
    genTex(scene, 'throw_toiletseat', 32, 32, (ctx) => {
      ctx.fillStyle = '#FFF';
      ctx.beginPath(); ctx.ellipse(16, 18, 13, 11, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#D0D0D0';
      ctx.beginPath(); ctx.ellipse(16, 19, 8, 7, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = rgba(0x88CCFF, 0.3);
      ctx.beginPath(); ctx.ellipse(16, 19, 8, 7, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#BBB'; ctx.fillRect(11, 6, 4, 4); ctx.fillRect(17, 6, 4, 4);
      ctx.strokeStyle = '#BBBBAA'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.ellipse(16, 18, 13, 11, 0, 0, Math.PI * 2); ctx.stroke();
    });

    // === PLAYER PROJECTILES 24x24 ===
    genTex(scene, 'bag_flying', 24, 24, (ctx) => {
      ctx.fillStyle = '#3A9A2F';
      ctx.beginPath(); ctx.moveTo(6, 8); ctx.quadraticCurveTo(3, 14, 5, 20);
      ctx.lineTo(19, 20); ctx.quadraticCurveTo(21, 14, 18, 8); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#2E7A24';
      ctx.beginPath(); ctx.moveTo(8, 8); ctx.quadraticCurveTo(12, 4, 16, 8);
      ctx.lineTo(18, 8); ctx.lineTo(6, 8); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#4AB83F'; ctx.fillRect(10, 3, 4, 6);
      ctx.strokeStyle = rgba(0xFFFFFF, 0.4); ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(1, 10); ctx.lineTo(4, 10); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, 14); ctx.lineTo(3, 14); ctx.stroke();
    });
    genTex(scene, 'bag_splat', 24, 24, (ctx) => {
      ctx.fillStyle = '#6B4226';
      ctx.beginPath(); ctx.ellipse(12, 12, 10, 8, 0, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(4, 8, 3, 2, -0.3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(20, 7, 3, 2, 0.4, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(6, 18, 2, 2, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#5A3216';
      ctx.beginPath(); ctx.ellipse(12, 12, 6, 4, 0, 0, Math.PI * 2); ctx.fill();
    });

    // === EFFECTS ===
    genTex(scene, 'stink_cloud', 48, 48, (ctx) => {
      const cx = 24, cy = 24;
      const grd = ctx.createRadialGradient(cx, cy, 2, cx, cy, 22);
      grd.addColorStop(0, rgba(0x88BB44, 0.45)); grd.addColorStop(0.5, rgba(0x88BB44, 0.25)); grd.addColorStop(1, rgba(0x88BB44, 0));
      ctx.fillStyle = grd;
      [[cx,cy,14],[cx-10,cy-4,10],[cx+10,cy-4,10],[cx-6,cy+6,9],[cx+6,cy+6,9]].forEach(([x,y,r]) => {
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
      });
    });
    genTex(scene, 'paint_splash', 40, 20, (ctx) => {
      ['#FF4444','#44AAFF','#FFDD00','#44DD44','#FF88FF'].forEach((col, i) => {
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.ellipse(4 + i * 7 + Math.sin(i) * 2, 8 + Math.cos(i*2) * 3, 5 + Math.sin(i) * 2, 3, i * 0.3, 0, Math.PI * 2); ctx.fill();
      });
    });
    genTex(scene, 'confetti_piece', 8, 8, (ctx) => {
      ctx.fillStyle = '#FFD700';
      ctx.save(); ctx.translate(4, 4); ctx.rotate(0.3);
      ctx.fillRect(-3, -2, 6, 4);
      ctx.fillStyle = rgba(0xFFFFFF, 0.3); ctx.fillRect(-3, -2, 6, 2);
      ctx.restore();
    });

    // Tire (spinning special attack Phase 3)
    genTex(scene, 'throw_tire', 40, 40, (ctx) => {
      ctx.fillStyle = '#222';
      ctx.beginPath(); ctx.arc(20, 20, 18, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#444';
      ctx.beginPath(); ctx.arc(20, 20, 12, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#888';
      ctx.beginPath(); ctx.arc(20, 20, 6, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#AAA';
      ctx.beginPath(); ctx.arc(20, 20, 3, 0, Math.PI * 2); ctx.fill();
      // Tread marks
      ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
      for (let a = 0; a < 8; a++) {
        const ang = a * Math.PI / 4;
        ctx.beginPath();
        ctx.moveTo(20 + Math.cos(ang) * 13, 20 + Math.sin(ang) * 13);
        ctx.lineTo(20 + Math.cos(ang) * 17, 20 + Math.sin(ang) * 17);
        ctx.stroke();
      }
    });

    // Liquid blob (special attack Phase 2)
    genTex(scene, 'throw_liquid', 28, 28, (ctx) => {
      ctx.fillStyle = '#44BB44';
      ctx.beginPath(); ctx.arc(14, 16, 10, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(10, 10, 5, 4, -0.3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(20, 9, 4, 3, 0.4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = rgba(0xFFFFFF, 0.25);
      ctx.beginPath(); ctx.arc(11, 13, 3, 0, Math.PI * 2); ctx.fill();
      // Drip
      ctx.fillStyle = '#44BB44';
      ctx.beginPath(); ctx.moveTo(14, 26); ctx.lineTo(12, 22); ctx.lineTo(16, 22); ctx.closePath(); ctx.fill();
    });

    // Liquid puddle on ground
    genTex(scene, 'liquid_puddle', 50, 16, (ctx) => {
      ctx.fillStyle = rgba(0x44BB44, 0.6);
      ctx.beginPath(); ctx.ellipse(25, 8, 24, 7, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = rgba(0x66DD66, 0.3);
      ctx.beginPath(); ctx.ellipse(20, 6, 10, 4, -0.2, 0, Math.PI * 2); ctx.fill();
    });

    // Ground bag pickup
    genTex(scene, 'bag_ground', 20, 16, (ctx) => {
      ctx.fillStyle = '#3A9A2F';
      ctx.beginPath(); ctx.moveTo(3, 4); ctx.quadraticCurveTo(1, 8, 2, 14);
      ctx.lineTo(18, 14); ctx.quadraticCurveTo(19, 8, 17, 4); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#2E7A24';
      ctx.beginPath(); ctx.moveTo(5, 4); ctx.quadraticCurveTo(10, 1, 15, 4);
      ctx.lineTo(17, 4); ctx.lineTo(3, 4); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#4AB83F'; ctx.fillRect(8, 0, 4, 5);
    });
}
// === BOOT SCENE ===
class BootScene extends Phaser.Scene {
    constructor() { super('Boot'); }
    create() {
        generateAllSprites(this);
        this.scene.start('Menu');
    }
}

// === MENU SCENE ===
class MenuScene extends Phaser.Scene {
    constructor() { super('Menu'); }
    create() {
        SndMgr.init();
        const save = SaveMgr.load();

        // Sky background
        this.cameras.main.setBackgroundColor(COLORS.SKY);

        // Animated clouds
        for (let i = 0; i < 5; i++) {
            const c = this.add.image(Math.random() * GW, 40 + Math.random() * 80, 'cloud').setAlpha(0.7);
            this.tweens.add({ targets: c, x: GW + 100, duration: 8000 + Math.random()*5000, repeat: -1,
                onRepeat: () => { c.x = -80; c.y = 40 + Math.random() * 80; }
            });
        }

        // Ground
        this.add.rectangle(GW/2, GROUND_Y + 60, GW, 120, 0x555555);
        for (let x = 0; x < GW; x += 100) {
            this.add.image(x + 50, GROUND_Y + 10, 'sidewalk_tile');
            this.add.image(x + 50, GROUND_Y + 60, 'road_tile');
        }

        // Animated dog running across
        const runDog = this.add.image(-50, GROUND_Y - 24, 'dackel_run_0').setScale(0.8);
        this.tweens.add({
            targets: runDog, x: GW + 50, duration: 6000, repeat: -1, delay: 1000,
            onRepeat: () => { runDog.x = -50; }
        });
        this.time.addEvent({ delay: 300, loop: true, callback: () => {
            runDog.setTexture(runDog.texture.key === 'dackel_run_0' ? 'dackel_run_1' : 'dackel_run_0');
        }});

        // Title
        const titleStyle = { fontFamily: 'monospace', fontSize: '42px', color: '#FFDD00',
            stroke: '#663300', strokeThickness: 6, align: 'center' };
        const title = this.add.text(GW/2, 100, 'ACHTUNG\nKACKHAUFEN!', titleStyle).setOrigin(0.5);
        this.tweens.add({ targets: title, scaleX: 1.05, scaleY: 1.05, duration: 500, yoyo: true, repeat: -1 });

        // Steaming poop logo
        const poopLogo = this.add.image(GW/2, 200, 'poop_big').setScale(2);
        this.time.addEvent({ delay: 400, loop: true, callback: () => {
            const s = this.add.image(poopLogo.x + Phaser.Math.Between(-10, 10), poopLogo.y - 20, 'steam').setScale(2).setAlpha(0.6);
            this.tweens.add({ targets: s, y: s.y - 30, alpha: 0, duration: 800, onComplete: () => s.destroy() });
        }});

        // Tip text
        const tip = this.add.text(GW/2, 255, TIPS[Math.floor(Math.random()*TIPS.length)],
            { fontFamily: 'monospace', fontSize: '13px', color: '#665533' }).setOrigin(0.5);

        // Buttons
        const btnStyle = { fontFamily: 'monospace', fontSize: '24px', color: '#FFFFFF',
            backgroundColor: '#44AA44', padding: { x: 20, y: 10 }, align: 'center' };
        const btnPlay = this.add.text(GW/2, 310, '  SPIELEN!  ', btnStyle).setOrigin(0.5).setInteractive({ useHandCursor: true });
        const btnHS = this.add.text(GW/2, 360, ' HIGHSCORES ', { ...btnStyle, fontSize: '18px', backgroundColor: '#3377AA' }).setOrigin(0.5).setInteractive({ useHandCursor: true });
        const btnHelp = this.add.text(GW/2, 400, ' ANLEITUNG  ', { ...btnStyle, fontSize: '18px', backgroundColor: '#AA7733' }).setOrigin(0.5).setInteractive({ useHandCursor: true });

        // Sound toggle
        const sndBtn = this.add.text(GW - 50, 20, SndMgr.muted ? '🔇' : '🔊',
            { fontSize: '28px' }).setOrigin(0.5).setInteractive({ useHandCursor: true });
        sndBtn.on('pointerdown', () => {
            SndMgr.resume();
            const m = SndMgr.toggleMute();
            sndBtn.setText(m ? '🔇' : '🔊');
            if (!m) SndMgr.click();
        });

        // Money display
        if (save.totalMoney > 0) {
            this.add.text(20, 20, `Taschengeld: ${save.totalMoney}€`,
                { fontFamily: 'monospace', fontSize: '16px', color: '#FFDD00', stroke: '#333', strokeThickness: 2 });
        }

        // Button actions
        btnPlay.on('pointerdown', () => {
            SndMgr.resume(); SndMgr.click();
            this.scene.start('Game', { level: 1 });
        });
        btnHS.on('pointerdown', () => { SndMgr.resume(); SndMgr.click(); this.scene.start('Highscore'); });
        btnHelp.on('pointerdown', () => {
            SndMgr.resume(); SndMgr.click();
            this.showHelp();
        });

        // Boss test button
        const btnBoss = this.add.text(GW/2, GH - 40, '  BOSS TESTEN  ', {
            fontFamily: 'monospace', fontSize: '16px', color: '#FFF',
            backgroundColor: '#CC2222', padding: { x: 12, y: 6 }
        }).setOrigin(0.5).setInteractive({ useHandCursor: true });
        btnBoss.on('pointerdown', () => {
            SndMgr.resume(); SndMgr.click();
            this.scene.start('Boss', { level: 5, bags: 15, money: 50 });
        });

        // Hover effects
        [btnPlay, btnHS, btnHelp, btnBoss].forEach(b => {
            b.on('pointerover', () => b.setScale(1.1));
            b.on('pointerout', () => b.setScale(1));
        });
    }
    showHelp() {
        const bg = this.add.rectangle(GW/2, GH/2, GW-60, GH-60, 0x000000, 0.85).setInteractive();
        const txt = this.add.text(GW/2, GH/2, [
            'ACHTUNG KACKHAUFEN! - Anleitung',
            '',
            'Du führst Hunde Gassi.',
            'Die Hunde machen Haufen auf den Gehweg!',
            '',
            'LINKS tippen = SPRINGEN',
            'RECHTS tippen = HAUFEN EINSAMMELN',
            '',
            'Eingesammelte Haufen = Taschengeld!',
            'Liegengelassene Haufen = Ärger!',
            'Du hast 3 Leben - Hindernisse kosten eins!',
            'Bei 3 Strafzetteln ist GAME OVER!',
            'Die Oma klaut dein ganzes Geld!',
            '',
            'Tastatur: Leertaste=Springen, E=Sammeln',
            '',
            '[ Tippen zum Schließen ]',
        ].join('\n'), { fontFamily: 'monospace', fontSize: '14px', color: '#FFFFFF', align: 'center', lineSpacing: 4 }).setOrigin(0.5);
        bg.on('pointerdown', () => { bg.destroy(); txt.destroy(); });
    }
}

// === GAME SCENE ===
class GameScene extends Phaser.Scene {
    constructor() { super('Game'); }

    init(data) {
        this.levelNum = data.level || 1;
        this.levelCfg = LEVELS[Math.min(this.levelNum - 1, LEVELS.length - 1)];
        this.carryMoney = data.money || 0;
        this.isBonus = data.bonus || false; // Hundepark Bonus-Level
    }

    create() {
        SndMgr.init(); SndMgr.resume();
        this.cameras.main.setBackgroundColor(COLORS.SKY);

        // State
        this.money = this.carryMoney;
        this.poopsCollected = 0;
        this.goldenCollected = 0;
        this.poopsMissed = 0;
        this.missedSinceLastEvent = 0;
        this.tickets = 0;
        this.combo = 0;
        this.comboTimer = 0;
        this.comboMultiplier = 1;
        this.distanceTraveled = 0;
        this.gameSpeed = this.isBonus ? this.levelCfg.speed * 0.8 : this.levelCfg.speed;
        this.bonusTimer = this.isBonus ? 20000 : 0; // 20 Sekunden Bonus-Level
        this.isGameOver = false;
        this.isPaused = false;
        this.playerOnGround = true;
        this.isCollecting = false;
        this.collectCooldown = 0;
        this.canCollect = true;
        this.dogs = [];
        this.activePoops = [];
        this.obstacles = [];
        this.npcs = [];
        this.weatherParticles = [];
        this.tutorialShown = this.levelNum > 1;
        this.leashLength = 1.0; // 0.3 to 1.0 — affects dog distance + collect range
        this.leashTarget = 1.0;
        this.stompBounce = false;
        this.isSliding = false; // snow belly-slide
        this.slideTimer = 0;
        this.lives = 3;
        this.invincible = false; // brief invincibility after hit
        this.catSpawned = false; // cat spawns once per level
        this.catTriggerDist = 0.3 + Math.random() * 0.4; // spawn at 30-70% of level distance
        this.dogsChasing = false; // dogs chasing cat
        this.dogChaseTimer = 0;

        // === BONUS LEVEL SETUP ===
        if (this.isBonus) {
            this.cameras.main.setBackgroundColor(0x88CCEE); // bright sky
        }

        // === PARALLAX BACKGROUND ===
        this.bgElements = { far: [], mid: [], near: [] };
        // Sky gradient is camera bg color
        // Far: clouds
        for (let i = 0; i < 6; i++) {
            const sc = 1.5 + Math.random() * 1.0;
            const c = this.add.image(i * 160, 40 + Math.random()*50, 'cloud').setAlpha(0.75).setScale(sc).setDepth(0);
            this.bgElements.far.push(c);
        }
        // Mid: houses and trees (bonus = only trees for park feel)
        for (let i = 0; i < 8; i++) {
            const type = this.isBonus ? 'tree' : (Math.random() > 0.5 ? 'house' : 'tree');
            const yPos = type === 'house' ? GROUND_Y - 70 : GROUND_Y - 65;
            const el = this.add.image(i * 150, yPos, type).setDepth(1);
            this.bgElements.mid.push(el);
        }
        // Near: bushes, fences (bonus = only bushes)
        for (let i = 0; i < 10; i++) {
            const type = this.isBonus ? 'bush' : (Math.random() > 0.5 ? 'bush' : 'fence');
            const el = this.add.image(i * 100, GROUND_Y - 20, type).setDepth(2);
            this.bgElements.near.push(el);
        }

        // === GROUND ===
        // Road fills everything below sidewalk to bottom
        this.add.rectangle(GW/2, GROUND_Y + 60, GW, 120, 0x555555).setDepth(2.5);
        this.groundTiles = [];
        for (let x = 0; x < GW + 120; x += 100) {
            // Sidewalk on top (where player walks)
            const sw = this.add.image(x, GROUND_Y + 10, 'sidewalk_tile').setDepth(3);
            // Road below sidewalk (80px tall tile, center at GROUND_Y+60)
            const rd = this.add.image(x, GROUND_Y + 60, 'road_tile').setDepth(3);
            this.groundTiles.push({ sw, rd });
        }

        // Sidewalk top edge line
        this.add.rectangle(GW/2, GROUND_Y, GW, 2, 0x999999).setDepth(3);

        // === PLAYER ===
        this.player = this.add.sprite(PLAYER_X, GROUND_Y - 50, 'boy_run_0').setDepth(10);
        this.playerVelY = 0;
        this.playerBaseY = GROUND_Y - 50;
        this.runFrame = 0;
        this.runTimer = 0;

        // === DOGS ===
        const dogCount = this.levelCfg.dogs;
        for (let i = 0; i < dogCount; i++) {
            const info = DOG_BREEDS[i % DOG_BREEDS.length];
            const dog = {
                sprite: this.add.sprite(PLAYER_X + 220 + i * 80, GROUND_Y - 24, info.breed + '_run_0').setDepth(9).setFlipX(true).setScale(0.8),
                info: info,
                poopTimer: this.isBonus ? (1500 + Math.random() * 2000) : (3000 + Math.random() * 4000),
                isPooping: false,
                poopCooldown: 0,
                frame: 0,
                baseOffsetX: 220 + i * 80,
                offsetX: 220 + i * 80,
                offsetY: 0,
                bobTimer: Math.random() * Math.PI * 2,
            };
            this.dogs.push(dog);
        }

        // === LEASH GRAPHICS ===
        this.leashGfx = this.add.graphics().setDepth(9);

        // === HUD ===
        // Top HUD bar background
        this.add.rectangle(GW/2, 0, GW, 54, 0x000000, 0.45).setOrigin(0.5, 0).setDepth(99);
        // Bottom HUD bar background
        this.add.rectangle(GW/2, GH - 50, GW, 50, 0x000000, 0.45).setOrigin(0.5, 0).setDepth(99);

        const hudStyle = { fontFamily: 'monospace', fontSize: '18px', color: '#FFFFFF', stroke: '#333333', strokeThickness: 3 };
        this.add.image(30, 18, 'coin').setDepth(100).setScale(0.8);
        this.hudMoney = this.add.text(50, 10, '0€', hudStyle).setDepth(100);
        this.hudLevel = this.add.text(GW/2, 10, this.isBonus ? 'BONUS!' : `Level ${this.levelNum}`, { ...hudStyle, fontSize: '16px' }).setOrigin(0.5, 0).setDepth(100);
        // Bonus timer HUD
        this.hudBonusTimer = this.add.text(GW/2, 52, '', { fontFamily: 'monospace', fontSize: '20px', color: '#FFD700', stroke: '#333', strokeThickness: 3 }).setOrigin(0.5, 0).setDepth(100).setAlpha(this.isBonus ? 1 : 0);
        this.add.image(GW - 140, 18, 'bag').setDepth(100).setScale(0.7);
        this.hudPoops = this.add.text(GW - 120, 10, '0', hudStyle).setDepth(100);

        // Progress bar
        this.progressBg = this.add.rectangle(GW/2, 38, 200, 8, 0x333333).setDepth(100);
        this.progressBar = this.add.rectangle(GW/2 - 99, 38, 2, 6, 0x44CC44).setDepth(100).setOrigin(0, 0.5);

        // Leash indicator
        this.add.text(GW - 70, 34, 'Leine:', { fontFamily: 'monospace', fontSize: '10px', color: '#CCC', stroke: '#333', strokeThickness: 2 }).setDepth(100);
        this.leashBarBg = this.add.rectangle(GW - 30, 38, 40, 6, 0x333333).setDepth(100);
        this.leashBar = this.add.rectangle(GW - 49, 38, 38, 4, 0x44CC44).setDepth(100).setOrigin(0, 0.5);

        // Lives display (hearts) - bottom bar left
        this.add.text(8, GH - 44, 'Leben:', { fontFamily: 'monospace', fontSize: '11px', color: '#FFF', stroke: '#333', strokeThickness: 2 }).setDepth(100);
        this.hudHearts = [];
        for (let i = 0; i < 3; i++) {
            const h = this.add.image(68 + i * 22, GH - 38, 'heart').setDepth(100).setScale(0.8);
            this.hudHearts.push(h);
        }

        // Ticket display - bottom bar right
        this.add.text(8, GH - 22, 'Strafzettel:', { fontFamily: 'monospace', fontSize: '11px', color: '#FFF', stroke: '#333', strokeThickness: 2 }).setDepth(100);
        this.hudTickets = [];
        for (let i = 0; i < 3; i++) {
            const t = this.add.image(110 + i * 24, GH - 16, 'ticket').setDepth(100).setScale(0.55).setAlpha(0.3);
            this.hudTickets.push(t);
        }

        // Combo text
        this.comboText = this.add.text(GW/2, GH/2 - 50, '', { fontFamily: 'monospace', fontSize: '32px', color: '#FFDD00', stroke: '#663300', strokeThickness: 4 }).setOrigin(0.5).setDepth(100).setAlpha(0);

        // Touch buttons (semi-transparent)
        if (this.isBonus) {
            // Bonus: left = move left, center = collect, right = move right
            this.add.text(GW/6, GH - 25, '← LINKS', { fontFamily: 'monospace', fontSize: '10px', color: '#FFFFFF' }).setOrigin(0.5).setAlpha(0.3).setDepth(99);
            this.add.image(GW/2, GH - 35, 'btn_collect').setScale(1).setAlpha(0.25).setDepth(99);
            this.add.text(GW/2, GH - 12, 'SAMMELN', { fontFamily: 'monospace', fontSize: '10px', color: '#FFFFFF' }).setOrigin(0.5).setAlpha(0.3).setDepth(99);
            this.add.text(GW*5/6, GH - 25, 'RECHTS →', { fontFamily: 'monospace', fontSize: '10px', color: '#FFFFFF' }).setOrigin(0.5).setAlpha(0.3).setDepth(99);
        } else {
            this.add.rectangle(0, GH - 70, GW/2, 70, 0x000000, 0).setOrigin(0, 0).setDepth(99);
            this.add.rectangle(GW/2, GH - 70, GW/2, 70, 0x000000, 0).setOrigin(0, 0).setDepth(99);
            this.add.image(GW/4, GH - 35, 'btn_jump').setScale(1).setAlpha(0.25).setDepth(99);
            this.add.image(GW*3/4, GH - 35, 'btn_collect').setScale(1).setAlpha(0.25).setDepth(99);
            this.add.text(GW/4, GH - 12, 'SPRINGEN', { fontFamily: 'monospace', fontSize: '10px', color: '#FFFFFF' }).setOrigin(0.5).setAlpha(0.3).setDepth(99);
            this.add.text(GW*3/4, GH - 12, 'SAMMELN', { fontFamily: 'monospace', fontSize: '10px', color: '#FFFFFF' }).setOrigin(0.5).setAlpha(0.3).setDepth(99);
        }

        // === WEATHER ===
        this.weather = this.isBonus ? 'sunny' : this.levelCfg.weather; // Bonus = always sunny
        this.applyWeatherVisuals();
        this.weatherTimer = 0;
        // Weather changes once mid-level
        this.weatherChanged = false;
        const weathers = ['sunny', 'rain', 'snow', 'fog'];
        const others = weathers.filter(w => w !== this.weather);
        this.nextWeather = others[Math.floor(Math.random() * others.length)];
        this.weatherChangeDist = 0.4 + Math.random() * 0.2; // change at 40-60% of level
        this.fogClouds = [];

        // === INPUT ===
        this.bonusMoveDir = 0; // -1 left, 0 none, 1 right (bonus only)
        this.activeTouchId = null; // track touch for bonus movement
        if (this.isBonus) {
            // Bonus: touch left half = move left, right half = move right, tap = collect
            this.input.on('pointerdown', (pointer) => {
                SndMgr.resume();
                if (this.isGameOver) return;
                this.activeTouchId = pointer.id;
                if (pointer.x < GW / 3) {
                    this.bonusMoveDir = -1;
                } else if (pointer.x > GW * 2 / 3) {
                    this.bonusMoveDir = 1;
                } else {
                    this.doCollect();
                }
            });
            this.input.on('pointerup', (pointer) => {
                if (pointer.id === this.activeTouchId) this.bonusMoveDir = 0;
            });
            this.input.on('pointermove', (pointer) => {
                if (!pointer.isDown || pointer.id !== this.activeTouchId) return;
                if (pointer.x < GW / 3) {
                    this.bonusMoveDir = -1;
                } else if (pointer.x > GW * 2 / 3) {
                    this.bonusMoveDir = 1;
                } else {
                    this.bonusMoveDir = 0;
                }
            });
        } else {
            // Normal: left half = jump, right half = collect
            this.input.on('pointerdown', (pointer) => {
                SndMgr.resume();
                if (this.isGameOver) return;
                if (pointer.x < GW / 2) {
                    this.doJump();
                } else {
                    this.doCollect();
                }
            });
        }

        this.cursors = this.input.keyboard.createCursorKeys();
        this.keyE = this.input.keyboard.addKey('E');
        this.keyP = this.input.keyboard.addKey('P');
        this.keySpace = this.input.keyboard.addKey('SPACE');
        this.keyA = this.input.keyboard.addKey('A');
        this.keyD = this.input.keyboard.addKey('D');
        this.input.keyboard.on('keydown-P', () => this.togglePause());

        // === SPAWN TIMERS ===
        this.obstacleTimer = 2000;
        this.nextObstacleTime = 2000 + Math.random() * 2000;

        // === Level start text ===
        this.showLevelStart();

        // Start music
        SndMgr.startMusic();
    }

    showLevelStart() {
        const dogNames = this.dogs.map(d => d.info.name).join(', ');
        const lines = this.isBonus ? [
            'BONUS-LEVEL!',
            '',
            'HUNDEPARK!',
            '',
            'Die Hunde laufen frei!',
            'Lauf hin und sammle die Haufen ein!',
            'Beeil dich - sie verschwinden!',
            'Goldene Haufen = 10x Punkte!',
            '',
            `Du hast 20 Sekunden!`,
        ] : [
            `Level ${this.levelNum}`,
            '',
            this.levelNum === 1 ? 'Erster Arbeitstag!' : `${this.dogs.length} Hunde, ${this.levelCfg.weather === 'sunny' ? 'sonnig' : this.levelCfg.weather === 'rain' ? 'Regen' : this.levelCfg.weather === 'snow' ? 'Schnee' : 'Nebel'}!`,
            '',
            `Heute gehst du mit\n${dogNames} Gassi!`,
            '',
            'Auf die Haufen, fertig, LOS!',
        ];
        const bg = this.add.rectangle(GW/2, GH/2, GW, GH, 0x000000, 0.7).setDepth(200);
        const txt = this.add.text(GW/2, GH/2, lines.join('\n'),
            { fontFamily: 'monospace', fontSize: '18px', color: '#FFDD00', align: 'center', lineSpacing: 4, stroke: '#333', strokeThickness: 2 }
        ).setOrigin(0.5).setDepth(200);
        this.isPaused = true;
        this.time.delayedCall(2500, () => {
            bg.destroy(); txt.destroy();
            this.isPaused = false;
            if (this.levelNum === 1 && !this.tutorialShown) this.showTutorial();
        });
    }

    showTutorial() {
        this.tutorialShown = true;
        const t1 = this.add.text(GW/4, GH - 100, '← LINKS tippen\n= SPRINGEN',
            { fontFamily: 'monospace', fontSize: '14px', color: '#FFFF00', align: 'center', stroke: '#333', strokeThickness: 2 }).setOrigin(0.5).setDepth(150);
        const t2 = this.add.text(GW*3/4, GH - 100, 'RECHTS tippen →\n= SAMMELN',
            { fontFamily: 'monospace', fontSize: '14px', color: '#FFFF00', align: 'center', stroke: '#333', strokeThickness: 2 }).setOrigin(0.5).setDepth(150);
        this.tweens.add({ targets: [t1, t2], alpha: 0, duration: 500, delay: 4000, onComplete: () => { t1.destroy(); t2.destroy(); }});
    }

    applyWeatherVisuals() {
        if (this.weather === 'rain') {
            this.cameras.main.setBackgroundColor(0x667788);
        } else if (this.weather === 'snow') {
            this.cameras.main.setBackgroundColor(0xCCDDEE);
        } else if (this.weather === 'fog') {
            this.cameras.main.setBackgroundColor(0xAABBCC);
        } else {
            this.cameras.main.setBackgroundColor(COLORS.SKY);
        }
    }

    changeWeather(newWeather) {
        this.weather = newWeather;
        this.applyWeatherVisuals();
        // Remove old fog clouds when leaving fog
        if (newWeather !== 'fog') {
            this.fogClouds.forEach(c => { if (c.active) c.destroy(); });
            this.fogClouds = [];
        }
        const names = { sunny: 'Sonne!', rain: 'Regen!', snow: 'Schnee!', fog: 'Nebel!' };
        this.showFloatingText(GW/2, 80, '🌤️ Wetterwechsel: ' + names[newWeather], '#FFFFFF');
    }

    doJump() {
        if (!this.playerOnGround || this.isPaused || this.isSliding) return;
        this.playerVelY = -10;
        this.playerOnGround = false;
        SndMgr.jump();
    }

    doCollect() {
        if (this.isPaused || !this.canCollect || this.isSliding) return;

        // SNOW: ducking can cause a slip!
        if (this.weather === 'snow' && this.playerOnGround && Math.random() < 0.30) {
            this.startBellySlide();
            return;
        }

        this.isCollecting = true;
        this.canCollect = false;
        this.collectCooldown = 300;
        this.player.setTexture('boy_collect');
        this.player.y = GROUND_Y - 45; // duck down (shorter sprite)

        // Only collect poops the player figure is directly touching (body proximity)
        const collectRange = 35;
        let nearest = null, nearDist = collectRange;
        this.activePoops.forEach(p => {
            if (p.collected) return;
            const dist = Math.abs(p.sprite.x - this.player.x);
            if (dist < nearDist) { nearDist = dist; nearest = p; }
        });

        if (nearest) {
            nearest.collected = true;
            const value = nearest.type === 'gold' ? 10 : nearest.type === 'big' ? 2 : 1;

            // Combo
            this.combo++;
            this.comboTimer = 2000;
            if (this.combo >= 2) {
                this.comboMultiplier = Math.min(5, 1 + Math.floor(this.combo / 2));
                const ctxt = COMBO_TEXTS[Math.min(this.comboMultiplier, COMBO_TEXTS.length - 1)] || `x${this.comboMultiplier}!`;
                this.comboText.setText(ctxt).setAlpha(1).setScale(0.5);
                this.tweens.add({ targets: this.comboText, scaleX: 1.2, scaleY: 1.2, alpha: 0, duration: 800 });
                SndMgr.combo();
            }

            const earned = value * this.comboMultiplier;
            this.money += earned;
            this.poopsCollected++;
            if (nearest.type === 'gold') this.goldenCollected++;

            // Visual feedback
            const ft = this.add.text(nearest.sprite.x, nearest.sprite.y - 20, `+${earned}€`,
                { fontFamily: 'monospace', fontSize: '18px', color: '#FFDD00', stroke: '#333', strokeThickness: 3 }).setOrigin(0.5).setDepth(50);
            this.tweens.add({ targets: ft, y: ft.y - 40, alpha: 0, duration: 700, onComplete: () => ft.destroy() });

            // Sparkle effect
            for (let i = 0; i < 5; i++) {
                const sp = this.add.image(nearest.sprite.x + Phaser.Math.Between(-15,15), nearest.sprite.y + Phaser.Math.Between(-15,5), 'sparkle').setDepth(50).setScale(Phaser.Math.FloatBetween(0.5, 1.5));
                this.tweens.add({ targets: sp, y: sp.y - 20, alpha: 0, scaleX: 0, scaleY: 0, duration: 400 + Math.random()*200, onComplete: () => sp.destroy() });
            }

            // Remove poop sprite
            if (nearest.steam) nearest.steam.destroy();
            nearest.sprite.destroy();

            SndMgr.collect();
        }

        this.time.delayedCall(200, () => {
            this.isCollecting = false;
            this.player.setTexture('boy_run_0');
            if (this.playerOnGround) this.player.y = this.playerBaseY;
        });
        this.time.delayedCall(300, () => { this.canCollect = true; });
    }

    startBellySlide() {
        this.isSliding = true;
        this.slideTimer = 1500;
        this.canCollect = false;
        this.player.setTexture('boy_slide');
        this.player.y = GROUND_Y - 30;
        this.cameras.main.shake(200, 0.01);
        SndMgr.bonk();

        // Check if sliding into a poop (face first!)
        const nearPoop = this.activePoops.find(p =>
            !p.collected && Math.abs(p.sprite.x - this.player.x) < 80 && p.sprite.x > this.player.x
        );
        if (nearPoop) {
            this.showFloatingText(this.player.x + 30, this.player.y - 30, 'VOLL INS GESICHT!', '#8B4513');
        } else {
            this.showFloatingText(this.player.x, this.player.y - 30, 'AUSGERUTSCHT!', '#88BBEE');
        }

        // Combo reset
        this.combo = 0;
        this.comboMultiplier = 1;
    }

    togglePause() {
        this.isPaused = !this.isPaused;
        if (this.isPaused) {
            this.pauseOverlay = this.add.rectangle(GW/2, GH/2, GW, GH, 0x000000, 0.6).setDepth(200);
            this.pauseText = this.add.text(GW/2, GH/2, 'PAUSE\n\nTippen zum Fortfahren',
                { fontFamily: 'monospace', fontSize: '24px', color: '#FFFFFF', align: 'center' }).setOrigin(0.5).setDepth(200);
            this.pauseOverlay.setInteractive();
            this.pauseOverlay.on('pointerdown', () => this.togglePause());
        } else {
            if (this.pauseOverlay) { this.pauseOverlay.destroy(); this.pauseText.destroy(); }
        }
    }

    update(time, delta) {
      try {
        if (this.isPaused || this.isGameOver) return;
        const dt = delta / 1000;
        const spd = this.gameSpeed;

        // === SCROLL BACKGROUND (not in bonus - static park) ===
        if (!this.isBonus) {
            this.bgElements.far.forEach(el => {
                el.x -= spd * 0.1 * dt;
                if (el.x < -100) el.x += GW + 200;
            });
            this.bgElements.mid.forEach(el => {
                el.x -= spd * 0.3 * dt;
                if (el.x < -100) el.x += GW + 200 + Math.random() * 100;
            });
            this.bgElements.near.forEach(el => {
                el.x -= spd * 0.6 * dt;
                if (el.x < -80) el.x += GW + 160 + Math.random() * 60;
            });

            // Ground scroll
            this.groundTiles.forEach(t => {
                t.sw.x -= spd * dt;
                t.rd.x -= spd * dt;
                if (t.sw.x < -100) {
                    t.sw.x += (this.groundTiles.length) * 100;
                    t.rd.x = t.sw.x;
                }
            });
        }

        // Distance
        if (!this.isBonus) this.distanceTraveled += spd * dt;

        // Progress bar (hide in bonus, use timer instead)
        if (this.isBonus) {
            const bonusProgress = Math.max(0, this.bonusTimer / 20000);
            this.progressBar.width = bonusProgress * 198;
        } else {
            const progress = Math.min(1, this.distanceTraveled / this.levelCfg.distance);
            this.progressBar.width = progress * 198;
        }

        // === PLAYER PHYSICS ===
        if (!this.playerOnGround) {
            this.playerVelY += 25 * dt; // gravity
            this.player.y += this.playerVelY;
            if (this.player.y >= this.playerBaseY) {
                this.player.y = this.playerBaseY;
                this.playerVelY = 0;
                this.playerOnGround = true;
            }
        }

        // === PLAYER MOVES LEFT/RIGHT (always, Mario-style) ===
        if (!this.isBonus) {
            const moveSpeed = this.playerOnGround ? 150 : 180;
            let moveDir = 0;
            if (this.cursors.left.isDown || this.keyA.isDown) moveDir = -1;
            else if (this.cursors.right.isDown || this.keyD.isDown) moveDir = 1;
            if (moveDir !== 0) {
                this.player.x += moveDir * moveSpeed * dt;
                this.player.x = Phaser.Math.Clamp(this.player.x, 30, GW - 30);
            } else if (this.playerOnGround && Math.abs(this.player.x - PLAYER_X) > 2) {
                // Drift back to default position when no key pressed
                this.player.x += (PLAYER_X - this.player.x) * 3 * dt;
            }
        }

        // === BONUS: player moves left/right ===
        if (this.isBonus) {
            const moveSpeed = 250;
            // Keyboard: arrow keys or A/D
            if (this.cursors.left.isDown || this.keyA.isDown) {
                this.bonusMoveDir = -1;
            } else if (this.cursors.right.isDown || this.keyD.isDown) {
                this.bonusMoveDir = 1;
            } else if (!this.input.activePointer.isDown) {
                this.bonusMoveDir = 0;
            }
            this.player.x += this.bonusMoveDir * moveSpeed * dt;
            this.player.x = Phaser.Math.Clamp(this.player.x, 30, GW - 30);
            // Flip player sprite based on direction
            if (this.bonusMoveDir < 0) this.player.setFlipX(true);
            else if (this.bonusMoveDir > 0) this.player.setFlipX(false);
        }

        // Belly slide recovery
        if (this.isSliding) {
            this.slideTimer -= delta;
            this.player.setTexture('boy_slide');
            this.player.y = GROUND_Y - 30;
            if (this.slideTimer <= 0) {
                this.isSliding = false;
                this.canCollect = true;
                this.player.y = this.playerBaseY;
                this.player.setTexture('boy_run_0');
                this.showFloatingText(this.player.x, this.player.y - 20, 'Bäh!', '#8B4513');
            }
        }

        // Player run animation
        if (this.playerOnGround && !this.isCollecting && !this.isSliding) {
            this.runTimer += delta;
            if (this.runTimer > 120) {
                this.runTimer = 0;
                this.runFrame = (this.runFrame + 1) % 4;
                this.player.setTexture('boy_run_' + this.runFrame);
            }
        }
        if (!this.playerOnGround && !this.isSliding) {
            this.player.setTexture('boy_jump');
        }

        // === LEASH ===
        this.leashLength += (this.leashTarget - this.leashLength) * 0.03;
        this.leashLength = Phaser.Math.Clamp(this.leashLength, 0.3, 1.0);
        // Slowly recover leash
        if (this.leashTarget < 1.0) this.leashTarget += dt * 0.05;
        this.leashTarget = Phaser.Math.Clamp(this.leashTarget, 0.3, 1.0);
        // Leash bar color
        const lc = this.leashLength > 0.6 ? 0x44CC44 : this.leashLength > 0.4 ? 0xCCCC44 : 0xCC4444;
        this.leashBar.width = this.leashLength * 38;
        this.leashBar.fillColor = lc;

        // === DOG CHASE TIMER ===
        if (this.dogsChasing) {
            this.dogChaseTimer -= delta;
            if (this.dogChaseTimer <= 0) {
                this.dogsChasing = false;
                this.gameSpeed = this.levelCfg.speed; // Speed zurück auf normal
                SndMgr.startMusic(); // Normale Musik wieder
                this.dogs.forEach(d => { delete d.chaseOffsetX; });
                this.showFloatingText(GW/2, 120, 'Hunde kommen zurück!', '#44AA44');
            }
        }

        // === DOGS ===
        this.dogs.forEach((dog, idx) => {
            dog.bobTimer += dt * 3;

            let targetX, targetY;
            if (this.isBonus) {
                // Bonus: dogs roam freely across the screen
                if (!dog.roamTargetX || Math.abs(dog.sprite.x - dog.roamTargetX) < 10) {
                    dog.roamTargetX = 60 + Math.random() * (GW - 120);
                }
                targetX = dog.roamTargetX;
                targetY = GROUND_Y - 24 + Math.sin(dog.bobTimer) * 3;
                dog.sprite.x += (targetX - dog.sprite.x) * 0.02;
                // Flip dog based on movement direction
                dog.sprite.setFlipX(targetX > dog.sprite.x);
            } else {
                // Normal: leash-based positioning
                const baseOff = this.dogsChasing && dog.chaseOffsetX ? dog.chaseOffsetX : dog.baseOffsetX;
                dog.offsetX = baseOff * this.leashLength;
                targetX = this.player.x + dog.offsetX;
                targetY = GROUND_Y - 24 + Math.sin(dog.bobTimer) * 2;
                dog.sprite.x += (targetX - dog.sprite.x) * 0.1;
            }
            // Auto-jump over holes only (dogs walk past other obstacles)
            if (!dog.isPooping) {
                const nearObs = this.obstacles.find(obs =>
                    obs.sprite && obs.sprite.active &&
                    obs.type === 'hole' &&
                    Math.abs(obs.sprite.x - dog.sprite.x) < 90 &&
                    obs.sprite.x >= dog.sprite.x - 10
                );
                if (nearObs && !dog.jumping) {
                    dog.jumping = true;
                    dog.jumpVel = -9;
                    dog.jumpY = dog.sprite.y;
                }
            }
            if (dog.jumping) {
                dog.jumpVel += 0.35;
                dog.sprite.y += dog.jumpVel;
                if (dog.sprite.y >= targetY) {
                    dog.sprite.y = targetY;
                    dog.jumping = false;
                    dog.jumpVel = 0;
                }
            } else {
                dog.sprite.y += (targetY - dog.sprite.y) * 0.1;
            }

            // Animate
            dog.poopCooldown -= delta;
            if (!dog.isPooping) {
                if (Math.floor(time / 250) % 2 === idx % 2) {
                    dog.sprite.setTexture(dog.info.breed + '_run_0');
                } else {
                    dog.sprite.setTexture(dog.info.breed + '_run_1');
                }
            }

            // Poop timer — only one dog poops at a time!
            dog.poopTimer -= delta;
            const anyonePooping = this.dogs.some(d => d.isPooping);
            if (dog.poopTimer <= 0 && !dog.isPooping && dog.poopCooldown <= 0 && !anyonePooping) {
                this.dogPoop(dog);
                // More dogs = faster frequency (divide timer by dog count)
                const baseCooldown = (2500 + Math.random() * 4000) / dog.info.poopRate;
                dog.poopTimer = this.isBonus
                    ? (2000 + Math.random() * 2500) // Bonus: weniger Haufen
                    : baseCooldown / Math.max(1, this.dogs.length * 0.6);
                dog.poopCooldown = 1500;
            }
        });

        // === LEASH (hidden in bonus - dogs roam free!) ===
        this.leashGfx.clear();
        if (!this.isBonus) {
            this.leashGfx.lineStyle(2, COLORS.LEASH, 0.7);
            this.dogs.forEach(dog => {
                this.leashGfx.beginPath();
                this.leashGfx.moveTo(this.player.x + 5, this.player.y + 10);
                this.leashGfx.lineTo(dog.sprite.x - 10, dog.sprite.y);
                this.leashGfx.strokePath();
            });
        }

        // === ACTIVE POOPS ===
        this.activePoops = this.activePoops.filter(p => {
            if (p.collected || !p.sprite || !p.sprite.active) return false;

            if (this.isBonus) {
                // Bonus: poops stay in place but fade and disappear after 3.5 seconds
                p.bonusLife = (p.bonusLife === undefined ? 3500 : p.bonusLife) - delta;
                const lifeRatio = Math.max(0, p.bonusLife / 3500);
                // Start blinking when <30% life left
                if (lifeRatio < 0.3) {
                    const blink = Math.sin(time * 0.02) > 0;
                    p.sprite.setAlpha(blink ? 0.8 : 0.2);
                } else {
                    p.sprite.setAlpha(lifeRatio * 0.5 + 0.5);
                }
                if (p.bonusLife <= 0) {
                    p.sprite.destroy();
                    if (p.steam) p.steam.destroy();
                    this.showFloatingText(p.sprite.x, GROUND_Y - 20, 'Weg!', '#999999');
                    this.poopsMissed++;
                    return false;
                }
            } else {
                // Normal: poops scroll left
                p.sprite.x -= spd * dt;
                if (p.steam && p.steam.active) p.steam.x = p.sprite.x;

                // RAIN: poops dissolve!
                if (this.weather === 'rain') {
                    p.dissolveTimer = (p.dissolveTimer || 4000) - delta;
                    const dissolveProgress = 1 - Math.max(0, p.dissolveTimer) / 4000;
                    p.sprite.setAlpha(1 - dissolveProgress * 0.8);
                    p.sprite.setScale(1 - dissolveProgress * 0.3);
                    if (p.dissolveTimer <= 0) {
                        const px = p.sprite.x;
                        p.sprite.destroy();
                        if (p.steam) p.steam.destroy();
                        this.poopsMissed++;
                        this.missedSinceLastEvent++;
                        this.checkMissedPoopEvents();
                        this.showFloatingText(px, GROUND_Y - 20, 'Aufgelöst!', '#4488CC');
                        return false;
                    }
                }

                if (p.sprite.x < -30) {
                    p.sprite.destroy();
                    if (p.steam) p.steam.destroy();
                    this.poopsMissed++;
                    this.missedSinceLastEvent++;
                    this.checkMissedPoopEvents();
                    return false;
                }
            }
            // Collision with player (stepping on it)
            if (!p.collected && Math.abs(p.sprite.x - this.player.x) < 20 && this.playerOnGround && this.player.y > GROUND_Y - 50) {
                if (!p.steppedOn) {
                    p.steppedOn = true;
                    this.showFloatingText(this.player.x, this.player.y - 30, 'Igitt!', '#CC6600');
                }
            }
            return true;
        });

        // === CAT SPAWN (once per level, from level 2+, NOT in bonus) ===
        if (!this.isBonus && !this.catSpawned && this.levelNum >= 2) {
            const catProgress = this.distanceTraveled / this.levelCfg.distance;
            if (catProgress >= this.catTriggerDist) {
                this.spawnCat();
                this.catSpawned = true;
            }
        }

        // === OBSTACLES (disabled in bonus level) ===
        if (!this.isBonus) {
            this.obstacleTimer -= delta;
            if (this.obstacleTimer <= 0) {
                this.spawnObstacle();
                this.obstacleTimer = (2500 + Math.random() * 3000) / (1 + this.levelNum * 0.1);
            }
        }
        this.obstacles = this.obstacles.filter(obs => {
            if (!obs.sprite || !obs.sprite.active) return false;
            obs.sprite.x -= spd * dt;
            if (obs.sprite.x < -60) { obs.sprite.destroy(); return false; }
            // Collision
            if (!obs.hit && Math.abs(obs.sprite.x - this.player.x) < 25 && this.playerOnGround && !this.invincible && !this.isSliding) {
                obs.hit = true;
                this.loseLife();
                if (obs.type === 'puddle') {
                    // Hinfallen-Animation: Spieler rutscht und dreht sich
                    this.showFloatingText(this.player.x, this.player.y - 30, 'Rutsch!', '#4488CC');
                    this.player.setTexture('boy_slide');
                    this.player.y = GROUND_Y - 30;
                    this.tweens.add({
                        targets: this.player, angle: 360, x: this.player.x + 30,
                        duration: 500, ease: 'Cubic.easeOut',
                        onComplete: () => {
                            this.player.setAngle(0);
                            this.player.x = PLAYER_X;
                            this.player.y = this.playerBaseY;
                            this.player.setTexture('boy_run_0');
                        }
                    });
                    // Wasser-Spritzer
                    for (let i = 0; i < 6; i++) {
                        const sp = this.add.image(obs.sprite.x + Phaser.Math.Between(-15, 15), GROUND_Y - 5, 'raindrop').setDepth(15).setScale(2).setAlpha(0.8);
                        this.tweens.add({ targets: sp, y: sp.y - 30 - Math.random()*20, x: sp.x + Phaser.Math.Between(-20, 20), alpha: 0, duration: 400, onComplete: () => sp.destroy() });
                    }
                } else if (obs.type === 'hole') {
                    // Reinfallen-Animation: Spieler sackt nach unten weg
                    this.showFloatingText(this.player.x, this.player.y - 30, 'LOCH!', '#FF4444');
                    const savedY = this.playerBaseY;
                    this.tweens.add({
                        targets: this.player, y: GROUND_Y + 15, scaleX: 0.7, scaleY: 0.3,
                        duration: 300, ease: 'Cubic.easeIn',
                        onComplete: () => {
                            // Wieder rausklettern
                            this.tweens.add({
                                targets: this.player, y: savedY, scaleX: 1, scaleY: 1,
                                duration: 400, ease: 'Back.easeOut',
                                onComplete: () => { this.player.setTexture('boy_run_0'); }
                            });
                        }
                    });
                    // Dreck-Partikel fliegen hoch
                    for (let i = 0; i < 5; i++) {
                        const d = this.add.rectangle(obs.sprite.x + Phaser.Math.Between(-8, 8), GROUND_Y, 4, 4, 0x665533).setDepth(15);
                        this.tweens.add({ targets: d, y: d.y - 30 - Math.random()*25, x: d.x + Phaser.Math.Between(-20, 20), alpha: 0, duration: 500, onComplete: () => d.destroy() });
                    }
                } else if (obs.type === 'barrier') {
                    this.showFloatingText(this.player.x, this.player.y - 30, 'AUTSCH!', '#FF6600');
                    // Spieler prallt zurück
                    this.tweens.add({
                        targets: this.player, x: this.player.x - 25, duration: 150,
                        yoyo: true, ease: 'Cubic.easeOut',
                        onComplete: () => { this.player.x = PLAYER_X; }
                    });
                    // Baustelle wackelt
                    this.tweens.add({ targets: obs.sprite, angle: 15, duration: 100, yoyo: true, repeat: 3, onComplete: () => { if(obs.sprite.active) obs.sprite.setAngle(0); } });
                } else if (obs.type === 'bicycle') {
                    // Fahrrad kippt um
                    this.showFloatingText(this.player.x, this.player.y - 30, 'KRACH!', '#FF4444');
                    this.tweens.add({
                        targets: obs.sprite, angle: 90, y: GROUND_Y + 5,
                        duration: 400, ease: 'Bounce.easeOut'
                    });
                    // Spieler stolpert
                    this.player.setTexture('boy_slide');
                    this.player.y = GROUND_Y - 30;
                    this.time.delayedCall(500, () => {
                        this.player.y = this.playerBaseY;
                        this.player.setTexture('boy_run_0');
                        this.player.setAngle(0);
                    });
                    // Klingel-Sound (hoher Ton)
                    SndMgr._tone(1200, 0.1, 'square', 0.15);
                    SndMgr._tone(1500, 0.08, 'square', 0.1, 0.1);
                }
            }
            return true;
        });

        // === NPCs ===
        this.npcs = this.npcs.filter(npc => {
            if (!npc.sprite || !npc.sprite.active) {
                if (npc.speech) npc.speech.destroy();
                if (npc.pan) npc.pan.destroy();
                return false;
            }
            if (npc.type === 'ordnungsamt' || npc.type === 'oma') {
                npc.sprite.x += (spd * 0.3) * dt; // chasing
                if (npc.speech) npc.speech.x = npc.sprite.x;
                if (npc.speech) npc.speech.y = npc.sprite.y - 40;

                // Walk animation
                npc.animTimer = (npc.animTimer || 0) + delta;
                if (npc.animTimer > 150) {
                    npc.animTimer = 0;
                    const base = npc.type + '_run_';
                    const cur = npc.sprite.texture.key;
                    npc.sprite.setTexture(cur === base + '0' ? base + '1' : base + '0');
                }

                // Oma: pan swings above her head
                if (npc.type === 'oma') {
                    if (npc.pan) {
                        npc.pan.x = npc.sprite.x + 8;
                        npc.pan.y = npc.sprite.y - 50;
                        npc.pan.setRotation(Math.sin(time * 0.008) * 0.7);
                    }
                    // Oma smashes obstacles she reaches!
                    this.obstacles = this.obstacles.filter(obs => {
                        if (Math.abs(obs.sprite.x - npc.sprite.x) < 30) {
                            // SMASH! Oma clears it with her pan
                            SndMgr.bonk();
                            // Obstacle flies away
                            this.tweens.add({
                                targets: obs.sprite,
                                y: obs.sprite.y - 80,
                                x: obs.sprite.x + Phaser.Math.Between(-60, 60),
                                angle: Phaser.Math.Between(-180, 180),
                                alpha: 0, duration: 500,
                                onComplete: () => obs.sprite.destroy()
                            });
                            this.showFloatingText(obs.sprite.x, obs.sprite.y - 20, 'WUMM!', '#663399');
                            return false;
                        }
                        return true;
                    });
                }

                // MARIO STOMP CHECK: player falling onto NPC from above
                const dx = Math.abs(npc.sprite.x - this.player.x);
                const playerFeet = this.player.y + 50;
                const npcTop = npc.sprite.y - 40;
                if (dx < 35 && !this.playerOnGround && this.playerVelY > 0 && playerFeet >= npcTop && playerFeet <= npc.sprite.y) {
                    // STOMP!
                    this.stompNPC(npc);
                    npc.sprite.destroy();
                    if (npc.speech) npc.speech.destroy();
                    if (npc.pan) npc.pan.destroy();
                    return false;
                }

                if (npc.sprite.x >= this.player.x - 10 && this.playerOnGround) {
                    // Caught on ground!
                    this.npcCatchPlayer(npc);
                    npc.sprite.destroy();
                    if (npc.speech) npc.speech.destroy();
                    if (npc.pan) npc.pan.destroy();
                    return false;
                }
                if (npc.sprite.x > GW + 50) { npc.sprite.destroy(); if (npc.speech) npc.speech.destroy(); if (npc.pan) npc.pan.destroy(); return false; }
                // Timeout - NPC gives up
                npc.timer -= delta;
                if (npc.timer <= 0) {
                    npc.sprite.destroy();
                    if (npc.speech) npc.speech.destroy();
                    if (npc.pan) npc.pan.destroy();
                    return false;
                }
            } else if (npc.type === 'cat') {
                npc.timer -= delta;

                // Cat jumping around
                npc.jumpTimer = (npc.jumpTimer || 0) - delta;
                if (npc.jumpTimer <= 0 && npc.sprite.y >= GROUND_Y - 24) {
                    npc.jumpVel = -(4 + Math.random() * 4);
                    npc.jumpTimer = 400 + Math.random() * 600;
                }
                npc.jumpVel = (npc.jumpVel || 0) + 0.3;
                npc.sprite.y += npc.jumpVel;
                if (npc.sprite.y >= GROUND_Y - 22) {
                    npc.sprite.y = GROUND_Y - 28;
                    npc.jumpVel = 0;
                }

                if (!npc.chaseTriggered) {
                    // Phase 1: Cat runs in from left at 2x speed toward dogs
                    const catSpeed = this.levelCfg.speed * 2;
                    npc.sprite.x += catSpeed * dt;
                    npc.sprite.setFlipX(true); // face right

                    const firstDogX = this.dogs.length > 0 ? this.dogs[0].sprite.x : this.player.x + 100;
                    if (npc.sprite.x >= firstDogX - 30) {
                        npc.chaseTriggered = true;
                        npc.soundTimer = 0;
                        this.cameras.main.shake(300, 0.01);
                        SndMgr.hiss();
                        this.dogs.forEach((d, i) => {
                            this.time.delayedCall(i * 150, () => SndMgr.bark());
                        });
                        this.showFloatingText(GW/2, 120, 'Die Hunde jagen die Katze!', '#FF8833');
                        // Whole game speeds up for 7 seconds
                        this.gameSpeed = this.levelCfg.speed * 2;
                        SndMgr.startMusic(280);
                        this.dogsChasing = true;
                        this.dogChaseTimer = 7000;
                        this.dogs.forEach(d => {
                            d.chaseOffsetX = d.baseOffsetX + 250;
                        });
                    }
                } else {
                    // Phase 2: Chase! Cat stays visible, running ahead of the dogs
                    const lastDog = this.dogs[this.dogs.length - 1];
                    const targetX = lastDog ? lastDog.sprite.x + 60 : this.player.x + 300;
                    // Cat stays just ahead of the furthest dog
                    npc.sprite.x += (targetX - npc.sprite.x) * 0.08;
                    // Keep cat on screen
                    npc.sprite.x = Phaser.Math.Clamp(npc.sprite.x, this.player.x + 50, GW - 40);
                    // Flip based on movement direction
                    npc.sprite.setFlipX(targetX > npc.sprite.x);

                    // Periodic barking, meowing, hissing during chase
                    npc.soundTimer = (npc.soundTimer || 0) - delta;
                    if (npc.soundTimer <= 0) {
                        npc.soundTimer = 800 + Math.random() * 1200;
                        const r = Math.random();
                        if (r < 0.4) SndMgr.bark();
                        else if (r < 0.7) SndMgr.meow();
                        else SndMgr.hiss();
                    }
                }

                // Cat disappears when chase timer runs out
                if (npc.timer <= 0 || (!this.dogsChasing && npc.chaseTriggered)) {
                    npc.sprite.destroy();
                    return false;
                }
            } else if (npc.type === 'strange_dog') {
                npc.sprite.x -= spd * 0.5 * dt;
                npc.timer -= delta;
                if (npc.sprite.x < -50 || npc.timer <= 0) { npc.sprite.destroy(); return false; }
            }
            return true;
        });

        // === COMBO TIMER ===
        if (this.comboTimer > 0) {
            this.comboTimer -= delta;
            if (this.comboTimer <= 0) {
                this.combo = 0;
                this.comboMultiplier = 1;
            }
        }

        // === WEATHER CHANGE mid-level (not in bonus) ===
        if (!this.isBonus && !this.weatherChanged && this.levelNum >= 2) {
            const wp = this.distanceTraveled / this.levelCfg.distance;
            if (wp >= this.weatherChangeDist) {
                this.weatherChanged = true;
                this.changeWeather(this.nextWeather);
            }
        }

        // === WEATHER EFFECTS ===
        this.weatherTimer -= delta;
        if (this.weatherTimer <= 0) {
            this.weatherTimer = 50;
            if (this.weather === 'rain') {
                const drop = this.add.image(Math.random() * GW, -5, 'raindrop').setDepth(40).setAlpha(0.6);
                this.tweens.add({ targets: drop, y: GH + 10, x: drop.x - 30, duration: 600 + Math.random()*200, onComplete: () => drop.destroy() });
            } else if (this.weather === 'snow') {
                const flake = this.add.image(Math.random() * GW, -5, 'snowflake').setDepth(40).setAlpha(0.8);
                this.tweens.add({ targets: flake, y: GH + 10, x: flake.x + Phaser.Math.Between(-40, 40), duration: 2000 + Math.random()*1000, onComplete: () => flake.destroy() });
            } else if (this.weather === 'fog') {
                // Spawn thick fog clouds that drift across, obscuring everything
                if (this.fogClouds.length < 6 && Math.random() < 0.3) {
                    const fy = GROUND_Y - 80 + Phaser.Math.Between(-60, 40);
                    const fscale = 2.5 + Math.random() * 2;
                    const fc = this.add.image(GW + 80, fy, 'fog_cloud')
                        .setScale(fscale).setAlpha(0.55 + Math.random() * 0.15)
                        .setDepth(55); // above gameplay (dogs=9, poops=5, obstacles=5, player=10)
                    this.fogClouds.push(fc);
                }
            }
        }
        // Move fog clouds
        if (this.weather === 'fog') {
            this.fogClouds = this.fogClouds.filter(fc => {
                if (!fc.active) return false;
                fc.x -= (spd * 0.4 + 20) * dt;
                if (fc.x < -200) { fc.destroy(); return false; }
                return true;
            });
        }

        // === HUD UPDATE ===
        this.hudMoney.setText(this.money + '€');
        this.hudPoops.setText(this.isBonus ? `${this.poopsCollected}` : `${this.poopsCollected}/${this.levelCfg.poopGoal}`);
        for (let i = 0; i < 3; i++) {
            this.hudTickets[i].setAlpha(i < this.tickets ? 1 : 0.3);
            this.hudHearts[i].setAlpha(i < this.lives ? 1 : 0.15);
            this.hudHearts[i].setScale(i < this.lives ? 1.5 : 1);
        }

        // === KEYBOARD ===
        if (this.isBonus) {
            // Bonus: Space/E/Down = collect, Left/Right/A/D = move (handled above)
            if (Phaser.Input.Keyboard.JustDown(this.keySpace) || Phaser.Input.Keyboard.JustDown(this.keyE) || Phaser.Input.Keyboard.JustDown(this.cursors.down)) {
                this.doCollect();
            }
        } else {
            if (Phaser.Input.Keyboard.JustDown(this.keySpace) || Phaser.Input.Keyboard.JustDown(this.cursors.up)) {
                this.doJump();
            }
            if (Phaser.Input.Keyboard.JustDown(this.keyE) || Phaser.Input.Keyboard.JustDown(this.cursors.down)) {
                this.doCollect();
            }
        }

        // === BONUS TIMER ===
        if (this.isBonus) {
            this.bonusTimer -= delta;
            const secs = Math.max(0, Math.ceil(this.bonusTimer / 1000));
            this.hudBonusTimer.setText(`⏱ ${secs}s`);
            if (secs <= 5) this.hudBonusTimer.setColor('#FF4444');
            if (this.bonusTimer <= 0) {
                this.levelComplete();
            }
        }

        // === LEVEL COMPLETE CHECK ===
        if (!this.isBonus && this.distanceTraveled >= this.levelCfg.distance) {
            this.levelComplete();
        }
      } catch(e) {
        console.error('UPDATE ERROR:', e);
        if (!this._errorShown) {
            this._errorShown = true;
            this.add.text(10, 10, 'FEHLER: ' + e.message + '\n' + e.stack,
                { fontSize: '12px', color: '#FF0000', backgroundColor: '#000000', wordWrap: { width: GW - 20 } }).setDepth(999);
        }
      }
    }

    dogPoop(dog) {
        dog.isPooping = true;
        dog.sprite.setTexture(dog.info.breed + '_poop');
        SndMgr.poop();

        this.time.delayedCall(600, () => {
            dog.isPooping = false;
            // Spawn poop at dog's position, but NOT on obstacles!
            let poopX = dog.sprite.x;
            const tooClose = this.obstacles.some(obs =>
                obs.sprite && obs.sprite.active && Math.abs(obs.sprite.x - poopX) < 40
            );
            if (tooClose) {
                // Shift poop to clear space (behind the obstacle)
                poopX -= 50;
                if (poopX < PLAYER_X + 30) poopX = PLAYER_X + 30;
            }
            const r = Math.random();
            const goldChance = this.isBonus ? 0.15 : 0.02; // Bonus: 15% golden poops!
            const type = r < goldChance ? 'gold' : r < 0.25 ? 'big' : 'small';
            const texKey = 'poop_' + type;
            const poopDepth = this.isBonus ? 12 : 5;
            const poopSprite = this.add.image(poopX, GROUND_Y - 18, texKey).setDepth(poopDepth);

            // Steam
            let steam = null;
            const steamContainer = this.add.container(poopSprite.x, poopSprite.y - 10).setDepth(poopDepth + 1);
            this.time.addEvent({ delay: 500, repeat: 5, callback: () => {
                if (!poopSprite.active) return;
                const s = this.add.image(Phaser.Math.Between(-5, 5), Phaser.Math.Between(-5, 0), 'steam').setScale(0.8).setAlpha(0.5);
                steamContainer.add(s);
                this.tweens.add({ targets: s, y: s.y - 15, alpha: 0, duration: 600, onComplete: () => s.destroy() });
            }});

            this.activePoops.push({ sprite: poopSprite, type, collected: false, steppedOn: false, steam: steamContainer });
        });
    }

    spawnObstacle() {
        const types = ['puddle', 'hole', 'bicycle', 'barrier'];
        const type = types[Math.floor(Math.random() * types.length)];
        let y = GROUND_Y;
        if (type === 'puddle') y = GROUND_Y + 12;
        else if (type === 'hole') y = GROUND_Y + 16;
        else if (type === 'bicycle') y = GROUND_Y - 40;
        else if (type === 'barrier') y = GROUND_Y - 28;

        const sprite = this.add.image(GW + 50, y, type).setDepth(5);
        this.obstacles.push({ sprite, type, hit: false });

        // Spawn cars on the road — more with higher levels
        const carChance = Math.min(0.25 + this.levelNum * 0.08, 0.7);
        const numCars = Math.random() < carChance ? (Math.random() < 0.3 && this.levelNum >= 3 ? 2 : 1) : 0;
        for (let ci = 0; ci < numCars; ci++) {
            const scale = 2.2 + Math.random() * 1.0;
            const speed = 1200 + Math.random() * 1200;
            const fromLeft = Math.random() < 0.35;
            const startX = fromLeft ? -160 : GW + 160;
            const endX = fromLeft ? GW + 160 : -160;
            const carY = GROUND_Y + 50 + ci * 20;
            const carKey = 'car' + Math.floor(Math.random() * NUM_CAR_COLORS);
            const car = this.add.image(startX, carY, carKey).setDepth(50).setScale(scale);
            if (fromLeft) car.setFlipX(true);
            this.tweens.add({ targets: car, x: endX, duration: speed, delay: ci * 400, onComplete: () => car.destroy() });
        }

        // Random NPC events (strange dogs only, cat is distance-based)
        if (Math.random() < 0.15 && !this.npcs.some(n => n.type === 'strange_dog')) {
            this.spawnStrangeDog();
        }
    }

    checkMissedPoopEvents() {
        // No penalties in bonus level!
        if (this.isBonus) return;
        // Never both Oma and Ordnungsamt at the same time!
        const hasChaser = this.npcs.some(n => n.type === 'ordnungsamt' || n.type === 'oma');
        if (hasChaser) return;

        // Ordnungsamt after ~3 missed
        if (this.missedSinceLastEvent >= 3) {
            this.spawnOrdnungsamt();
            this.missedSinceLastEvent = 0;
            return; // don't also spawn oma
        }
        // Oma after ~5 missed total
        if (this.poopsMissed >= this.levelCfg.omaAfter && this.poopsMissed % 5 === 0) {
            this.spawnOma();
        }
    }

    spawnOrdnungsamt() {
        SndMgr.siren();
        const sprite = this.add.sprite(-40, GROUND_Y - 50, 'ordnungsamt_run_0').setDepth(10);
        const speech = this.add.text(sprite.x, sprite.y - 40, 'HALT! STEHEN BLEIBEN!',
            { fontFamily: 'monospace', fontSize: '11px', color: '#FF4444', backgroundColor: '#FFFFFF', padding: { x: 4, y: 2 } }).setDepth(11).setOrigin(0.5);
        this.npcs.push({ sprite, type: 'ordnungsamt', timer: 8000, speech, animTimer: 0 });
        this.showFloatingText(GW/2, 80, '🚔 Ordnungsamt!', '#FF4444');
    }

    spawnOma() {
        SndMgr.bonk();
        const sprite = this.add.sprite(-40, GROUND_Y - 50, 'oma_run_0').setDepth(10);
        const pan = this.add.sprite(-40, GROUND_Y - 95, 'pan').setDepth(11);
        const line = OMA_LINES[Math.floor(Math.random() * OMA_LINES.length)];
        const speech = this.add.text(sprite.x, sprite.y - 40, line,
            { fontFamily: 'monospace', fontSize: '11px', color: '#663399', backgroundColor: '#FFFFFF', padding: { x: 4, y: 2 } }).setDepth(11).setOrigin(0.5);
        this.npcs.push({ sprite, type: 'oma', timer: 6000, speech, pan, animTimer: 0 });
    }

    spawnCat() {
        SndMgr.meow();
        // Cat enters from the LEFT, runs right at 2x speed, flipped to face right
        const sprite = this.add.sprite(-50, GROUND_Y - 22, 'cat').setDepth(10).setFlipX(true);
        this.npcs.push({ sprite, type: 'cat', timer: 12000, chaseTriggered: false, jumpVel: 0, jumpTimer: 0 });
        this.showFloatingText(GW/2, 120, '🐱 KATZE!!!', '#FF8833');
        // Dogs bark when cat appears
        this.dogs.forEach((d, i) => {
            this.time.delayedCall(i * 200, () => SndMgr.bark());
        });
    }

    spawnStrangeDog() {
        const sprite = this.add.sprite(GW + 30, GROUND_Y - 24, 'strange_dog').setDepth(8).setScale(0.8);
        this.npcs.push({ sprite, type: 'strange_dog', timer: 3000 });
        SndMgr.bark();
        // Make own dogs nervous - leash shortens a bit
        this.leashTarget = Math.max(0.5, this.leashTarget - 0.2);
        this.dogs.forEach(d => { d.poopTimer = Math.min(d.poopTimer, 1000); });
    }

    stompNPC(npc) {
        // Mario-style stomp! Bounce player up
        this.playerVelY = -8;
        this.playerOnGround = false;
        SndMgr.stomp();
        this.cameras.main.shake(150, 0.01);

        const bonus = npc.type === 'ordnungsamt' ? 5 : 3;
        this.money += bonus;

        // Squash animation
        const squashed = this.add.sprite(npc.sprite.x, GROUND_Y - 5, npc.type === 'ordnungsamt' ? 'ordnungsamt' : 'oma').setDepth(10);
        squashed.setScale(1.5, 0.3); // flat!
        this.tweens.add({ targets: squashed, alpha: 0, scaleX: 2, duration: 600, onComplete: () => squashed.destroy() });

        // Stars/sparkle around stomped NPC
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const sp = this.add.image(npc.sprite.x, npc.sprite.y, 'sparkle').setDepth(50).setScale(1.5);
            this.tweens.add({
                targets: sp, x: sp.x + Math.cos(angle) * 40, y: sp.y + Math.sin(angle) * 40,
                alpha: 0, duration: 500, onComplete: () => sp.destroy()
            });
        }

        const label = npc.type === 'ordnungsamt' ? 'PLATT! +5€' : 'ZERQUETSCHT! +3€';
        this.showFloatingText(npc.sprite.x, npc.sprite.y - 40, label, '#44FF44');
    }

    loseLife() {
        if (this.invincible || this.isGameOver) return;
        this.lives--;
        this.cameras.main.shake(300, 0.02);
        SndMgr.bonk();
        this.showFloatingText(this.player.x, this.player.y - 30, 'AUTSCH!', '#FF4444');

        // Invincibility frames (player blinks)
        this.invincible = true;
        const blink = this.time.addEvent({ delay: 100, repeat: 15, callback: () => {
            this.player.setAlpha(this.player.alpha === 1 ? 0.3 : 1);
        }});
        this.time.delayedCall(1600, () => {
            this.invincible = false;
            this.player.setAlpha(1);
        });

        // Combo reset
        this.combo = 0;
        this.comboMultiplier = 1;

        if (this.lives <= 0) {
            this.gameOver();
        }
    }

    npcCatchPlayer(npc) {
        if (this.isGameOver) return;
        if (npc.type === 'ordnungsamt') {
            this.tickets++;
            const fine = 5;
            this.money = Math.max(0, this.money - fine);
            this.cameras.main.shake(300, 0.02);
            SndMgr.siren();
            this.showFloatingText(this.player.x, this.player.y - 50, `STRAFZETTEL! -${fine}€`, '#FF0000');
            if (this.tickets >= 3) {
                this.gameOver();
            }
        } else if (npc.type === 'oma') {
            // Oma steals EVERYTHING!
            const stolen = this.money;
            this.money = 0;
            this.cameras.main.shake(400, 0.025);
            SndMgr.bonk();
            if (stolen > 0) {
                this.showFloatingText(this.player.x, this.player.y - 50, `BONK! -${stolen}€ ALLES WEG!`, '#663399');
            } else {
                this.showFloatingText(this.player.x, this.player.y - 50, 'BONK! Nichts zu holen!', '#663399');
            }
        }
    }

    showFloatingText(x, y, text, color) {
        const t = this.add.text(x, y, text,
            { fontFamily: 'monospace', fontSize: '16px', color: color, stroke: '#333', strokeThickness: 3 }).setOrigin(0.5).setDepth(100);
        this.tweens.add({ targets: t, y: y - 40, alpha: 0, duration: 1200, onComplete: () => t.destroy() });
    }

    levelComplete() {
        if (this.isGameOver) return;
        this.isGameOver = true;
        SndMgr.stopMusic();

        // Clear leash
        if (this.leashGfx) this.leashGfx.clear();

        // Clean up obstacles, poops, NPCs
        this.obstacles.forEach(o => { if (o.sprite) o.sprite.destroy(); });
        this.obstacles = [];
        this.activePoops.forEach(p => {
            if (p.sprite) p.sprite.destroy();
            if (p.steam) p.steam.destroy();
        });
        this.npcs.forEach(n => {
            if (n.sprite) n.sprite.destroy();
            if (n.speech) n.speech.destroy();
            if (n.pan) n.pan.destroy();
        });
        this.npcs = [];

        if (this.isBonus) {
            SndMgr.fanfare();
            this.showLevelStats();
            return;
        }

        // === LEVEL END ANIMATION: Boy brings dogs home ===
        const homeX = GW - 80;
        const homeY = GROUND_Y - 80;
        const home = this.add.image(GW + 140, homeY, 'house').setDepth(8).setScale(1.3);

        // "Zuhause!" label
        const homeLbl = this.add.text(GW + 140, homeY - 90, 'Zuhause!', {
            fontFamily: 'monospace', fontSize: '18px', color: '#FFDD00',
            stroke: '#333', strokeThickness: 3
        }).setOrigin(0.5).setDepth(9).setAlpha(0);

        // 1) House slides in from right
        this.tweens.add({ targets: home, x: homeX, duration: 1200, ease: 'Power2' });
        this.tweens.add({ targets: homeLbl, x: homeX, alpha: 1, duration: 1200, ease: 'Power2' });

        // 2) Gather dogs behind the boy (leash pull)
        this.dogs.forEach((dog, i) => {
            dog.sprite.setFlipX(true); // face right
            this.tweens.add({
                targets: dog.sprite,
                x: this.player.x - 40 - i * 35,
                y: GROUND_Y - 24,
                duration: 700,
                ease: 'Power2'
            });
        });

        // Walk animation timers
        const walkAnim = this.time.addEvent({
            delay: 120, loop: true,
            callback: () => {
                this.runFrame = (this.runFrame + 1) % 4;
                if (this.player && this.player.active) this.player.setTexture('boy_run_' + this.runFrame);
            }
        });
        const dogAnims = this.dogs.map(dog => this.time.addEvent({
            delay: 140, loop: true,
            callback: () => {
                if (dog.sprite && dog.sprite.active) {
                    const base = dog.info.breed + '_run_';
                    const cur = dog.sprite.texture.key;
                    dog.sprite.setTexture(cur === base + '0' ? base + '1' : base + '0');
                }
            }
        }));

        const doorX = homeX;

        // 3) After house is in + dogs gathered: walk to house
        this.time.delayedCall(1400, () => {
            // Start happy walking-home music
            SndMgr.startGoHomeMusic();

            // Fade "Zuhause!" text
            this.tweens.add({ targets: homeLbl, alpha: 0, duration: 600, delay: 800 });

            // Boy walks to door (ensure on ground first)
            this.player.y = this.playerBaseY;
            const walkDur = Math.max(1200, ((doorX - this.player.x) / 280) * 1000);
            this.tweens.add({
                targets: this.player,
                x: doorX,
                y: this.playerBaseY,
                duration: walkDur,
                ease: 'Linear',
                onComplete: () => {
                    walkAnim.destroy();
                    this.player.setTexture('boy_run_0');
                    // Boy enters house (shrinks into door)
                    this.tweens.add({
                        targets: this.player,
                        scaleX: 0.3, scaleY: 0.3, alpha: 0,
                        y: this.player.y + 15,
                        duration: 400, ease: 'Power2'
                    });
                }
            });

            // Dogs follow with staggered start
            this.dogs.forEach((dog, i) => {
                const delay = 250 + i * 300;
                const dogDur = walkDur + 200;
                this.tweens.add({
                    targets: dog.sprite,
                    x: doorX + 5,
                    duration: dogDur,
                    delay: delay,
                    ease: 'Linear',
                    onComplete: () => {
                        if (dogAnims[i]) dogAnims[i].destroy();
                        dog.sprite.setTexture(dog.info.breed + '_run_0');
                        // Dog enters house
                        this.tweens.add({
                            targets: dog.sprite,
                            scaleX: 0.2, scaleY: 0.2, alpha: 0,
                            y: dog.sprite.y + 10,
                            duration: 300, ease: 'Power2'
                        });
                    }
                });
            });

            // Window lights up after everyone enters
            const allInTime = walkDur + 250 + this.dogs.length * 300 + 500;
            this.time.delayedCall(allInTime, () => {
                const lx = homeX - 30, ly = homeY - 14;
                const glow = this.add.rectangle(lx, ly, 28, 18, 0xFFFF88, 0).setDepth(9);
                this.tweens.add({ targets: glow, alpha: 0.7, duration: 400 });
            });

            // Show stats after animation
            this.time.delayedCall(allInTime + 600, () => {
                SndMgr.stopMusic(); // stop walking-home music
                SndMgr.fanfare();
                this.showLevelStats();
            });
        });
    }

    showLevelStats() {
        const allCollected = this.poopsMissed === 0;
        const levelEarnings = this.money - this.carryMoney;
        const bonusDouble = this.isBonus && allCollected;
        const cleanBonus = !this.isBonus && allCollected ? 10 : 0;
        const doubleExtra = bonusDouble ? levelEarnings : 0;
        const totalMoney = this.money + cleanBonus + doubleExtra;

        const save = SaveMgr.load();
        save.totalMoney += levelEarnings + cleanBonus + doubleExtra;
        if (!this.isBonus) save.maxLevel = Math.max(save.maxLevel, this.levelNum + 1);
        SaveMgr.save(save);

        const bg = this.add.rectangle(GW/2, GH/2, GW, GH, 0x000000, 0.75).setDepth(200);

        const lines = this.isBonus ? [
            'BONUS-LEVEL VORBEI!',
            '',
            `Haufen gesammelt: ${this.poopsCollected}`,
            `Davon goldene: ${this.goldenCollected}`,
            '',
            `Bonus-Taschengeld: +${levelEarnings}€`,
            bonusDouble ? '🌟 ALLE EINGESAMMELT! GELD VERDOPPELT! 🌟' : '',
            bonusDouble ? `Extra: +${doubleExtra}€` : '',
            `Taschengeld gesamt: ${totalMoney}€`,
            '',
            'Weiter geht\'s!',
        ].filter(Boolean) : [
            `Level ${this.levelNum} geschafft!`,
            '',
            `Haufen gesammelt: ${this.poopsCollected}`,
            `Haufen liegen gelassen: ${this.poopsMissed}`,
            `Strafzettel: ${this.tickets}`,
            '',
            `Dieses Level: +${levelEarnings}€`,
            allCollected ? `SAUBER-BONUS: +${cleanBonus}€!` : '',
            `Taschengeld gesamt: ${totalMoney}€`,
            '',
        ].filter(Boolean);

        const txtY = this.isBonus ? GH/2 - 60 : GH/2 - 40;
        const txt = this.add.text(GW/2, txtY, lines.join('\n'),
            { fontFamily: 'monospace', fontSize: '16px', color: this.isBonus ? '#FFD700' : '#FFDD00', align: 'center', lineSpacing: 4, stroke: '#333', strokeThickness: 2 }).setOrigin(0.5).setDepth(200);

        // Bonus: show poop collection graphic (row of mini poops)
        if (this.isBonus) {
            const total = this.poopsCollected + this.poopsMissed;
            const maxIcons = Math.min(total, 30); // cap for display
            const iconSize = Math.min(24, Math.max(14, (GW - 100) / maxIcons));
            const startX = GW/2 - (maxIcons * iconSize) / 2 + iconSize/2;
            const iconY = GH/2 + 55;
            // Show collected first (gold ones highlighted), then missed as dark
            let goldShown = 0;
            for (let i = 0; i < maxIcons; i++) {
                const isCollected = i < this.poopsCollected;
                const isGold = isCollected && goldShown < this.goldenCollected;
                if (isGold) goldShown++;
                const key = isGold ? 'poop_gold' : 'poop_small';
                const icon = this.add.image(startX + i * iconSize, iconY, key)
                    .setDepth(201).setScale(iconSize / 40);
                if (!isCollected) {
                    icon.setAlpha(0.2).setTint(0x444444);
                }
                // Pop-in animation
                icon.setScale(0);
                this.tweens.add({
                    targets: icon, scaleX: iconSize/40, scaleY: iconSize/40,
                    duration: 200, delay: i * 40, ease: 'Back.easeOut'
                });
            }
            // "ALLE!" badge if all collected
            if (allCollected && total > 0) {
                const badge = this.add.text(GW/2, iconY - 22, 'ALLE EINGESAMMELT!',
                    { fontFamily: 'monospace', fontSize: '14px', color: '#FFD700',
                      stroke: '#333', strokeThickness: 3 }).setOrigin(0.5).setDepth(201).setAlpha(0).setScale(0.5);
                this.tweens.add({
                    targets: badge, alpha: 1, scaleX: 1.2, scaleY: 1.2,
                    duration: 500, delay: maxIcons * 40 + 200, ease: 'Back.easeOut',
                    onComplete: () => {
                        this.tweens.add({ targets: badge, scaleX: 1, scaleY: 1, duration: 200 });
                    }
                });
                // Sparkle around the badge
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const sx = GW/2 + Math.cos(angle) * 120;
                    const sy = iconY - 22 + Math.sin(angle) * 20;
                    const sp = this.add.image(GW/2, iconY - 22, 'sparkle').setDepth(201).setScale(0).setAlpha(0);
                    this.tweens.add({
                        targets: sp, x: sx, y: sy, scaleX: 1.5, scaleY: 1.5, alpha: 1,
                        duration: 400, delay: maxIcons * 40 + 400 + i * 50,
                        onComplete: () => {
                            this.tweens.add({ targets: sp, alpha: 0, scaleX: 0, scaleY: 0, duration: 300, onComplete: () => sp.destroy() });
                        }
                    });
                }
            }
        }

        const isNextBoss = !this.isBonus && this.levelNum % 5 === 0;
        const isNextBonus = !this.isBonus && !isNextBoss && this.levelNum % 3 === 0;
        const btnLabel = isNextBoss ? '  BOSS-KAMPF!  ' : isNextBonus ? '  BONUS-LEVEL!  ' : '  WEITER!  ';
        const btnColor = isNextBoss ? '#CC2222' : isNextBonus ? '#CC8800' : '#44AA44';
        const btnY = this.isBonus ? GH/2 + 130 : GH/2 + 100;
        const btnNext = this.add.text(GW/2, btnY, btnLabel,
            { fontFamily: 'monospace', fontSize: '22px', color: '#FFF', backgroundColor: btnColor, padding: { x: 16, y: 8 } }).setOrigin(0.5).setDepth(200).setInteractive({ useHandCursor: true });
        if (isNextBoss) {
            this.add.text(GW/2, GH/2 + 130, `${this.poopsCollected} Beutel = Munition!`, { fontFamily: 'monospace', fontSize: '12px', color: '#FF8844', stroke: '#333', strokeThickness: 2 }).setOrigin(0.5).setDepth(200);
        } else if (isNextBonus) {
            this.add.text(GW/2, GH/2 + 130, 'Ab in den Hundepark!', { fontFamily: 'monospace', fontSize: '12px', color: '#FFD700', stroke: '#333', strokeThickness: 2 }).setOrigin(0.5).setDepth(200);
        }
        btnNext.on('pointerdown', () => {
            SndMgr.click();
            if (this.isBonus) {
                this.scene.restart({ level: this.levelNum + 1, money: totalMoney });
            } else if (isNextBoss) {
                this.scene.start('Boss', {
                    level: this.levelNum,
                    bags: this.poopsCollected,
                    money: totalMoney
                });
            } else if (this.levelNum % 3 === 0) {
                this.scene.restart({ level: this.levelNum, money: totalMoney, bonus: true });
            } else {
                this.scene.restart({ level: this.levelNum + 1, money: totalMoney });
            }
        });
        btnNext.on('pointerover', () => btnNext.setScale(1.1));
        btnNext.on('pointerout', () => btnNext.setScale(1));
    }

    gameOver() {
        if (this.isGameOver) return;
        this.isGameOver = true;
        SndMgr.stopMusic();
        SndMgr.sad();
        this.cameras.main.shake(500, 0.03);

        const save = SaveMgr.load();
        const sessionEarnings = this.money - this.carryMoney;
        save.totalMoney += Math.max(0, sessionEarnings);
        SaveMgr.save(save);

        this.time.delayedCall(1000, () => {
            this.scene.start('GameOver', {
                money: this.money, // Gesamtes Geld über alle Level
                poopsCollected: this.poopsCollected,
                poopsMissed: this.poopsMissed,
                level: this.levelNum,
                tickets: this.tickets,
                lives: this.lives,
            });
        });
    }
}

// === BOSS SCENE ===
class BossScene extends Phaser.Scene {
    constructor() { super('Boss'); }

    init(data) {
        this.levelNum = data.level || 5;
        this.bags = data.bags || 10;
        this.money = data.money || 0;
    }

    create() {
        SndMgr.init(); SndMgr.resume();
        this.cameras.main.setBackgroundColor(0x555566);

        // State
        this.bossHP = 0; // 0-100 fill percentage
        this.phase = 1;
        this.lives = 3;
        this.bagsLeft = this.bags;
        this.isGameOver = false;
        this.isCollecting = false;
        this.invincible = false;
        this.playerOnGround = true;
        this.playerVelY = 0;
        this.playerBaseY = GROUND_Y - 50;

        // Boss state
        this.bossX = GW - 160;
        this.bossY = GROUND_Y - 80;
        this.bossBaseY = GROUND_Y - 80;
        this.bossVelY = 0;
        this.bossOnGround = true;
        this.bossDir = -1; // moving left
        this.bossSpeed = 60;
        this.bossCharging = false;
        this.bossChargeTimer = 0;
        this.bossStunned = false;

        // Lid state
        this.lidOpen = false;
        this.lidTimer = 0;
        this.lidWarning = false;
        this.lidWarningTimer = 0;

        // Attack state
        this.attackTimer = 0;
        this.specialTimer = 0;
        this.projectiles = []; // boss projectiles
        this.playerBags = []; // player thrown bags
        this.groundBags = []; // bags on ground to pick up
        this.spinningTires = []; // phase 3 spinning tires
        this.groundEffects = []; // stink clouds, paint splashes, liquid puddles

        // Phase timing
        this.phaseConfig = {
            1: { openTime: 3000, closeTime: 2000, attackInterval: 3500, bossSpeed: 60 },
            2: { openTime: 2000, closeTime: 3000, attackInterval: 2500, bossSpeed: 100 },
            3: { openTime: 1500, closeTime: 4000, attackInterval: 1500, bossSpeed: 140 }
        };

        // Projectile hit size per bag (scales with total bags available)
        this.bagHitPercent = Math.max(6, Math.min(15, 100 / Math.max(1, this.bags)));

        // === BACKGROUND: MÜLLKIPPE ===
        // Dunkler, bewölkter Himmel mit Grün-Grau-Stich
        const skyGfx = this.add.graphics().setDepth(0);
        skyGfx.fillGradientStyle(0x2A3A2A, 0x2A3A2A, 0x4A5A4A, 0x4A5A4A);
        skyGfx.fillRect(0, 0, GW, GROUND_Y);
        // Wolken (düster, smoggy)
        const cloudColors = [0x3A4A3A, 0x444E44, 0x505A50];
        [[80,40,110,35],[250,55,90,28],[430,30,130,38],[620,50,100,30],[750,35,80,25]].forEach(([cx,cy,rx,ry]) => {
            skyGfx.fillStyle(cloudColors[Math.floor(Math.random()*3)], 0.5);
            skyGfx.fillEllipse(cx, cy, rx*2, ry*2);
            skyGfx.fillStyle(cloudColors[Math.floor(Math.random()*3)], 0.3);
            skyGfx.fillEllipse(cx+20, cy-8, rx*1.5, ry*1.2);
        });
        // Stinkige grüne Dunst-Schicht über dem Boden
        skyGfx.fillStyle(0x556B2F, 0.15);
        skyGfx.fillRect(0, GROUND_Y - 120, GW, 120);
        skyGfx.fillStyle(0x6B8E23, 0.08);
        skyGfx.fillRect(0, GROUND_Y - 80, GW, 80);

        // Mond (grünlich durch Smog)
        this.add.circle(GW - 90, 55, 28, 0xCCCCAA).setDepth(0).setAlpha(0.4);
        this.add.circle(GW - 86, 52, 24, 0xDDDDBB).setDepth(0).setAlpha(0.25);

        // Boden: Dreckige Erde der Müllkippe
        const groundGfx = this.add.graphics().setDepth(1);
        groundGfx.fillGradientStyle(0x5A4A30, 0x5A4A30, 0x3A2A15, 0x3A2A15);
        groundGfx.fillRect(0, GROUND_Y, GW, GH - GROUND_Y);
        // Dreck-Textur (kleine Flecken)
        for (let i = 0; i < 40; i++) {
            const dx = Math.random() * GW, dy = GROUND_Y + Math.random() * (GH - GROUND_Y);
            groundGfx.fillStyle([0x4A3A20, 0x6B5B3A, 0x3A2A10][Math.floor(Math.random()*3)], 0.5);
            groundGfx.fillCircle(dx, dy, 3 + Math.random() * 8);
        }
        // Pfützen auf dem Boden (schmutzig grün/braun)
        [[120, GROUND_Y+25, 50, 12],[400, GROUND_Y+35, 60, 10],[650, GROUND_Y+20, 45, 11]].forEach(([px,py,pw,ph]) => {
            groundGfx.fillStyle(0x3A4A2A, 0.6);
            groundGfx.fillEllipse(px, py, pw*2, ph*2);
            groundGfx.fillStyle(0x5A6A3A, 0.3);
            groundGfx.fillEllipse(px+5, py-2, pw*1.2, ph*0.8);
        });

        // Müllhaufen im Hintergrund (verschiedene Höhen)
        const trashGfx = this.add.graphics().setDepth(2);
        // Großer Müllberg links-mitte
        trashGfx.fillStyle(0x5A5040);
        trashGfx.beginPath();
        trashGfx.moveTo(0, GROUND_Y);
        trashGfx.lineTo(20, GROUND_Y - 60);
        trashGfx.lineTo(60, GROUND_Y - 90);
        trashGfx.lineTo(110, GROUND_Y - 110);
        trashGfx.lineTo(160, GROUND_Y - 95);
        trashGfx.lineTo(200, GROUND_Y - 70);
        trashGfx.lineTo(230, GROUND_Y);
        trashGfx.closePath();
        trashGfx.fill();
        // Müllberg-Schattierung
        trashGfx.fillStyle(0x4A4030, 0.6);
        trashGfx.beginPath();
        trashGfx.moveTo(110, GROUND_Y - 110);
        trashGfx.lineTo(160, GROUND_Y - 95);
        trashGfx.lineTo(200, GROUND_Y - 70);
        trashGfx.lineTo(230, GROUND_Y);
        trashGfx.lineTo(140, GROUND_Y);
        trashGfx.closePath();
        trashGfx.fill();

        // Müllberg rechts (hinter Boss)
        trashGfx.fillStyle(0x555040);
        trashGfx.beginPath();
        trashGfx.moveTo(550, GROUND_Y);
        trashGfx.lineTo(580, GROUND_Y - 50);
        trashGfx.lineTo(640, GROUND_Y - 85);
        trashGfx.lineTo(700, GROUND_Y - 100);
        trashGfx.lineTo(740, GROUND_Y - 80);
        trashGfx.lineTo(780, GROUND_Y - 55);
        trashGfx.lineTo(800, GROUND_Y - 40);
        trashGfx.lineTo(800, GROUND_Y);
        trashGfx.closePath();
        trashGfx.fill();
        trashGfx.fillStyle(0x4A4030, 0.5);
        trashGfx.beginPath();
        trashGfx.moveTo(700, GROUND_Y - 100);
        trashGfx.lineTo(740, GROUND_Y - 80);
        trashGfx.lineTo(800, GROUND_Y - 40);
        trashGfx.lineTo(800, GROUND_Y);
        trashGfx.lineTo(660, GROUND_Y);
        trashGfx.closePath();
        trashGfx.fill();

        // Kleiner Müllhügel mittig
        trashGfx.fillStyle(0x5E5545);
        trashGfx.beginPath();
        trashGfx.moveTo(320, GROUND_Y);
        trashGfx.lineTo(350, GROUND_Y - 35);
        trashGfx.lineTo(400, GROUND_Y - 50);
        trashGfx.lineTo(440, GROUND_Y - 40);
        trashGfx.lineTo(470, GROUND_Y);
        trashGfx.closePath();
        trashGfx.fill();

        // Müll-Details auf den Haufen
        const detailGfx = this.add.graphics().setDepth(3);
        // Müllsäcke (schwarze/graue Beutel)
        [[70,GROUND_Y-70,16],[140,GROUND_Y-80,14],[90,GROUND_Y-50,12],
         [600,GROUND_Y-55,15],[680,GROUND_Y-75,16],[720,GROUND_Y-60,13],
         [370,GROUND_Y-35,11],[410,GROUND_Y-30,12]].forEach(([x,y,r]) => {
            detailGfx.fillStyle(0x222222, 0.8);
            detailGfx.fillEllipse(x, y, r*2, r*1.6);
            detailGfx.fillStyle(0x333333, 0.4);
            detailGfx.fillEllipse(x-2, y-3, r*1.2, r*0.8);
        });
        // Alte Dosen/Flaschen (kleine bunte Flecken)
        [[50,GROUND_Y-40,0xCC4444],[130,GROUND_Y-60,0x4488CC],[180,GROUND_Y-55,0xCCAA33],
         [100,GROUND_Y-85,0x44AA44],[620,GROUND_Y-45,0xCC6633],[660,GROUND_Y-70,0x4466BB],
         [740,GROUND_Y-50,0xDD5555],[380,GROUND_Y-25,0x55AA55],[430,GROUND_Y-35,0xAAAA33]].forEach(([x,y,c]) => {
            detailGfx.fillStyle(c, 0.7);
            detailGfx.fillRoundedRect(x-4, y-3, 8, 12, 2);
            detailGfx.fillStyle(0xFFFFFF, 0.2);
            detailGfx.fillCircle(x, y-1, 2);
        });
        // Kartons (braune Rechtecke, teilweise zerknittert)
        [[160,GROUND_Y-90,22,16],[30,GROUND_Y-35,18,14],[650,GROUND_Y-80,20,15],
         [760,GROUND_Y-45,18,12],[350,GROUND_Y-40,16,12]].forEach(([x,y,w,h]) => {
            detailGfx.fillStyle(0x8B7355, 0.8);
            detailGfx.fillRect(x-w/2, y-h/2, w, h);
            detailGfx.lineStyle(1, 0x6B5335, 0.5);
            detailGfx.strokeRect(x-w/2, y-h/2, w, h);
            // Tape-Streifen
            detailGfx.fillStyle(0xAA9966, 0.5);
            detailGfx.fillRect(x-w/2, y-2, w, 3);
        });
        // Alte Reifen
        [[45, GROUND_Y-15, 18],[190, GROUND_Y-8, 15],[580, GROUND_Y-12, 17]].forEach(([x,y,r]) => {
            detailGfx.lineStyle(6, 0x222222, 0.7);
            detailGfx.strokeCircle(x, y, r);
            detailGfx.lineStyle(2, 0x333333, 0.4);
            detailGfx.strokeCircle(x, y, r-3);
        });
        // Stink-Linien (grüne Wellenlinien die aufsteigen)
        const stinkGfx = this.add.graphics().setDepth(3);
        [[90,GROUND_Y-110],[150,GROUND_Y-100],[650,GROUND_Y-90],[710,GROUND_Y-95],[390,GROUND_Y-55]].forEach(([sx,sy]) => {
            stinkGfx.lineStyle(1.5, 0x88AA44, 0.3);
            stinkGfx.beginPath();
            stinkGfx.moveTo(sx, sy);
            for (let i = 1; i <= 5; i++) {
                stinkGfx.lineTo(sx + Math.sin(i*1.2)*8, sy - i*8);
            }
            stinkGfx.strokePath();
        });
        // Stink-Linien animieren (sanftes Schweben)
        this.tweens.add({
            targets: stinkGfx, y: -15, alpha: 0.1, duration: 4000,
            yoyo: true, repeat: -1, ease: 'Sine.easeInOut'
        });

        // Zaun im Hintergrund (Maschendraht)
        const fenceGfx = this.add.graphics().setDepth(2);
        // Pfosten
        for (let fx = 40; fx < GW; fx += 120) {
            fenceGfx.fillStyle(0x666666, 0.5);
            fenceGfx.fillRect(fx-2, GROUND_Y - 160, 4, 160);
            // Pfostenspitze
            fenceGfx.fillStyle(0x777777, 0.5);
            fenceGfx.fillCircle(fx, GROUND_Y - 160, 4);
        }
        // Draht-Linien (horizontal)
        for (let fy = GROUND_Y - 150; fy < GROUND_Y - 20; fy += 25) {
            fenceGfx.lineStyle(1, 0x888888, 0.25);
            fenceGfx.lineBetween(0, fy, GW, fy);
        }
        // Diagonal-Draht (Rauten-Muster)
        for (let fx = 0; fx < GW; fx += 30) {
            fenceGfx.lineStyle(0.5, 0x777777, 0.15);
            fenceGfx.lineBetween(fx, GROUND_Y - 150, fx+30, GROUND_Y - 20);
            fenceGfx.lineBetween(fx+30, GROUND_Y - 150, fx, GROUND_Y - 20);
        }

        // Arena-Begrenzung (Betonblöcke statt dünne Wände)
        detailGfx.fillStyle(0x666655);
        detailGfx.fillRect(0, GROUND_Y - 60, 12, 60);
        detailGfx.fillRect(GW - 12, GROUND_Y - 60, 12, 60);
        detailGfx.fillStyle(0x555544, 0.5);
        detailGfx.fillRect(2, GROUND_Y - 58, 8, 56);
        detailGfx.fillRect(GW - 10, GROUND_Y - 58, 8, 56);

        // === PLAYER ===
        this.player = this.add.image(120, this.playerBaseY, 'boy_run_0').setDepth(10);
        this.runFrame = 0;
        this.runTimer = 0;

        // === BOSS (composite: body + interior + arms + lid) ===
        this.bossBody = this.add.image(0, 0, 'boss_body_1');
        this.bossInterior = this.add.image(0, -40, 'boss_interior').setAlpha(0); // hidden when lid closed
        this.bossArmL = this.add.image(-48, -10, `boss_arm_1`).setOrigin(0.5, 0).setFlipX(true);
        this.bossArmR = this.add.image(48, -10, `boss_arm_1`).setOrigin(0.5, 0);
        // Lid sits on top of body. Origin at bottom-center = hinge point.
        // Positioned so lid ellipse center aligns with body's flat top (-46)
        this.bossLid = this.add.image(0, -38, `boss_lid_1`).setOrigin(0.5, 1);
        this.boss = this.add.container(this.bossX, this.bossY, [
            this.bossArmL, this.bossBody, this.bossInterior, this.bossArmR, this.bossLid
        ]).setDepth(10);
        // Arm/lid animation state
        this.armThrowing = false;
        this.lidTargetAngle = 0; // 0 = closed, -70 = open
        this.bossHurtFlash = false;

        // === HUD ===
        this.createHUD();

        // === INPUT ===
        this.cursors = this.input.keyboard.createCursorKeys();
        this.keyA = this.input.keyboard.addKey('A');
        this.keyD = this.input.keyboard.addKey('D');
        this.keyW = this.input.keyboard.addKey('W');
        this.keyE = this.input.keyboard.addKey('E'); // collect bags
        this.keyF = this.input.keyboard.addKey('F'); // throw bags
        this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        this.throwCooldown = 0;
        this.collectCooldown = 0;

        // Touch input (multitouch: pointer1 + pointer2)
        this.input.addPointer(1); // enable 2nd pointer for multitouch
        this.touchDucking = false;
        this.touchMoveDir = 0;
        this.touchJumpPointer = null;

        const handlePointerDown = (pointer) => {
            SndMgr.resume();
            if (this.isGameOver) return;
            if (pointer.x > GW / 2) {
                if (pointer.y < GH / 2) {
                    this.throwBag();
                } else {
                    this.touchDucking = true;
                }
            } else {
                if (pointer.y < GH / 3) {
                    // Top third left = jump
                    this.playerJump();
                    this.touchJumpPointer = pointer;
                } else {
                    // Bottom two-thirds left = move
                    this.touchMoveDir = pointer.x < GW / 4 ? -1 : 1;
                }
            }
        };
        const handlePointerMove = (pointer) => {
            if (!pointer.isDown) return;
            if (pointer === this.touchJumpPointer) return; // don't convert jump to move
            if (pointer.x > GW / 2) return;
            this.touchMoveDir = pointer.x < GW / 4 ? -1 : 1;
        };
        const handlePointerUp = (pointer) => {
            if (pointer === this.touchJumpPointer) { this.touchJumpPointer = null; return; }
            // Check if any pointer still held on left side for movement
            const p1 = this.input.pointer1;
            const p2 = this.input.pointer2;
            const anyLeftDown = (p1.isDown && p1.x <= GW/2) || (p2.isDown && p2.x <= GW/2);
            if (!anyLeftDown) this.touchMoveDir = 0;
            // Check ducking
            const anyRightDown = (p1.isDown && p1.x > GW/2 && p1.y >= GH/2) || (p2.isDown && p2.x > GW/2 && p2.y >= GH/2);
            if (!anyRightDown) this.touchDucking = false;
        };
        this.input.on('pointerdown', handlePointerDown);
        this.input.on('pointermove', handlePointerMove);
        this.input.on('pointerup', handlePointerUp);

        // Control hints
        this.add.text(GW - 10, GH - 50, '← Links / Rechts →  bewegen', {
            fontFamily: 'monospace', fontSize: '9px', color: '#AAA'
        }).setOrigin(1, 0.5).setDepth(100).setAlpha(0.5);
        this.add.text(GW - 10, GH - 38, '↑ Springen  |  F = Werfen', {
            fontFamily: 'monospace', fontSize: '9px', color: '#AAA'
        }).setOrigin(1, 0.5).setDepth(100).setAlpha(0.5);
        this.add.text(GW - 10, GH - 26, 'E = Aufheben  |  Leertaste = Springen', {
            fontFamily: 'monospace', fontSize: '9px', color: '#AAA'
        }).setOrigin(1, 0.5).setDepth(100).setAlpha(0.5);

        // Start boss music
        SndMgr.startBossMusic();

        // Initial lid timer - start closed
        this.lidTimer = this.phaseConfig[1].closeTime;

        // Boss intro animation
        this.boss.setAlpha(0);
        this.tweens.add({ targets: this.boss, alpha: 1, duration: 800, ease: 'Power2' });

        // "BOSS-KAMPF!" text
        const introText = this.add.text(GW/2, GH/2 - 60, 'BOSS-KAMPF!', {
            fontFamily: 'monospace', fontSize: '36px', color: '#FF4444',
            stroke: '#000', strokeThickness: 4
        }).setOrigin(0.5).setDepth(100);
        this.tweens.add({ targets: introText, alpha: 0, y: GH/2 - 120, duration: 2000, delay: 1000, ease: 'Power2',
            onComplete: () => introText.destroy()
        });
    }

    createHUD() {
        // Boss name
        this.add.text(GW/2, 12, 'MÜLLMONSTER-TONNE', {
            fontFamily: 'monospace', fontSize: '14px', color: '#FF8844',
            stroke: '#000', strokeThickness: 2
        }).setOrigin(0.5).setDepth(100);

        // Fill bar background
        this.add.rectangle(GW/2, 32, 204, 16, 0x333333).setDepth(100);
        this.add.rectangle(GW/2, 32, 200, 12, 0x111111).setDepth(100);
        this.fillBar = this.add.rectangle(GW/2 - 99, 32, 2, 10, 0x44CC44).setOrigin(0, 0.5).setDepth(101);

        // Phase text
        this.phaseText = this.add.text(GW/2 + 110, 32, 'Phase 1', {
            fontFamily: 'monospace', fontSize: '12px', color: '#AAA',
            stroke: '#000', strokeThickness: 1
        }).setOrigin(0, 0.5).setDepth(100);

        // Player lives (hearts)
        this.heartTexts = [];
        for (let i = 0; i < 3; i++) {
            const h = this.add.image(24 + i * 26, 30, 'heart').setDepth(100).setScale(1.2);
            this.heartTexts.push(h);
        }

        // Bags count
        this.bagText = this.add.text(20, 48, `Beutel: ${this.bagsLeft}`, {
            fontFamily: 'monospace', fontSize: '12px', color: '#88DD88',
            stroke: '#000', strokeThickness: 1
        }).setDepth(100);

        // Lid indicator
        this.lidIndicator = this.add.text(GW/2, 50, 'DECKEL ZU', {
            fontFamily: 'monospace', fontSize: '11px', color: '#FF4444',
            stroke: '#000', strokeThickness: 1
        }).setOrigin(0.5).setDepth(100);
    }

    update(time, delta) {
        if (this.isGameOver) return;
        const dt = delta / 1000;

        // === PLAYER PHYSICS ===
        if (!this.playerOnGround) {
            this.playerVelY += 25 * dt;
            this.player.y += this.playerVelY;
            if (this.player.y >= this.playerBaseY) {
                this.player.y = this.playerBaseY;
                this.playerVelY = 0;
                this.playerOnGround = true;
            }
        }

        // === PLAYER MOVEMENT ===
        const moveSpeed = this.playerOnGround ? 200 : 220;
        let moveDir = this.touchMoveDir;
        if (this.cursors.left.isDown || this.keyA.isDown) moveDir = -1;
        else if (this.cursors.right.isDown || this.keyD.isDown) moveDir = 1;
        if (moveDir !== 0) {
            this.player.x += moveDir * moveSpeed * dt;
            this.player.x = Phaser.Math.Clamp(this.player.x, 30, GW - 50);
        }

        // Jump
        if ((this.cursors.up.isDown || this.keyW.isDown || this.keySpace.isDown) && this.playerOnGround) {
            this.playerJump();
        }

        // Throw (F key)
        this.throwCooldown -= delta;
        if (this.keyF.isDown && this.throwCooldown <= 0) {
            this.throwBag();
        }

        // Ducking (E key held = stay ducked, collect bags while ducked)
        this.collectCooldown -= delta;
        const ducking = this.keyE.isDown || this.touchDucking;
        if (ducking && this.playerOnGround) {
            if (!this.isCollecting) {
                this.isCollecting = true;
                this.player.setTexture('boy_collect');
                this.player.y = GROUND_Y - 45;
            }
            // Auto-collect nearby bags while ducked
            if (this.collectCooldown <= 0) {
                this.collectGroundBag();
            }
        } else if (this.isCollecting && !ducking) {
            this.isCollecting = false;
            this.player.y = this.playerBaseY;
            this.player.setTexture('boy_run_0');
        }

        // Player animation - only animate when moving
        if (this.isCollecting) {
            // stay in collect pose
        } else if (!this.playerOnGround) {
            this.player.setTexture('boy_jump');
        } else if (moveDir !== 0) {
            // Walking - animate run cycle
            this.runTimer += delta;
            if (this.runTimer > 120) {
                this.runTimer = 0;
                this.runFrame = (this.runFrame + 1) % 4;
                this.player.setTexture('boy_run_' + this.runFrame);
            }
        } else {
            // Standing still
            this.player.setTexture('boy_run_0');
            this.runTimer = 0;
        }
        // Always face the boss
        this.player.setFlipX(this.bossX < this.player.x);

        // === BOSS AI ===
        this.updateBoss(dt, delta);

        // === LID MECHANICS ===
        this.updateLid(delta);

        // === BOSS ATTACKS ===
        this.updateAttacks(dt, delta);

        // === PROJECTILES ===
        this.updateProjectiles(dt);

        // === SPINNING TIRES ===
        this.updateSpinningTires(dt, delta);

        // === GROUND BAGS (pickup) ===
        this.updateGroundBags();

        // === PLAYER BAGS ===
        this.updatePlayerBags(dt);

        // === GROUND EFFECTS ===
        this.groundEffects = this.groundEffects.filter(e => {
            e.timer -= delta;
            if (e.timer <= 0) { e.sprite.destroy(); return false; }
            e.sprite.setAlpha(e.timer / e.maxTimer * 0.7);
            return true;
        });

        // === PHASE CHECK ===
        const newPhase = this.bossHP < 33 ? 1 : this.bossHP < 66 ? 2 : 3;
        if (newPhase !== this.phase) {
            this.phase = newPhase;
            this.phaseText.setText('Phase ' + this.phase);
            SndMgr.bossAngry();
            this.cameras.main.shake(400, 0.02);
            // Flash boss red for phase change
            this.bossHurtFlash = true;
            [this.bossBody, this.bossArmL, this.bossArmR, this.bossLid].forEach(p => p.setTint(0xFF0000));
            this.time.delayedCall(300, () => {
                this.bossHurtFlash = false;
                if (this.boss) [this.bossBody, this.bossArmL, this.bossArmR, this.bossLid].forEach(p => p.clearTint());
            });
        }

        // === HUD UPDATE ===
        this.fillBar.width = Math.max(1, (this.bossHP / 100) * 198);
        if (this.bossHP < 33) this.fillBar.setFillStyle(0x44CC44);
        else if (this.bossHP < 66) this.fillBar.setFillStyle(0xCCAA22);
        else this.fillBar.setFillStyle(0xCC4444);

        const groundCount = this.groundBags.length;
        this.bagText.setText(`Beutel: ${this.bagsLeft}` + (groundCount > 0 ? ` (${groundCount} am Boden)` : ''));

        // Update boss part textures based on phase
        if (!this.bossStunned) {
            this.bossBody.setTexture(`boss_body_${this.phase}`);
            this.bossLid.setTexture(`boss_lid_${this.phase}`);
            this.bossArmL.setTexture(`boss_arm_${this.phase}`);
            this.bossArmR.setTexture(`boss_arm_${this.phase}`);
        }

        // Animate boss parts (arms, lid)
        this.updateBossParts(dt, delta);

        // === WIN/LOSE CHECK ===
        if (this.bossHP >= 100) {
            this.bossVictory();
        } else if (this.lives <= 0) {
            this.bossDefeat();
        }
    }

    playerJump() {
        if (!this.playerOnGround || this.isGameOver) return;
        this.playerOnGround = false;
        this.playerVelY = -12;
        SndMgr.jump();
    }

    throwBag() {
        if (this.isGameOver || this.bagsLeft <= 0 || this.throwCooldown > 0) return;
        this.bagsLeft--;
        this.throwCooldown = 400; // ms cooldown between throws
        SndMgr.bossThrow();

        const bag = this.add.image(this.player.x + 15, this.player.y - 10, 'bag_flying').setDepth(15);
        // Calculate parabola toward boss
        const dx = this.bossX - this.player.x;
        this.playerBags.push({
            sprite: bag,
            x: this.player.x + 15,
            y: this.player.y - 10,
            vx: dx * 1.2,
            vy: -180,
            gravity: 300
        });
    }

    updateBoss(dt, delta) {
        // Boss stunned (squished) - stays motionless
        if (this.bossStunned) {
            this.boss.setPosition(this.bossX, this.bossY);
            return;
        }

        const cfg = this.phaseConfig[this.phase];

        // Roll left-right (wider range so player can jump over)
        if (!this.bossCharging) {
            this.bossX += this.bossDir * cfg.bossSpeed * dt;
            if (this.bossX > GW - 60) { this.bossDir = -1; }
            if (this.bossX < 120) { this.bossDir = 1; }
        }

        // Occasional charge at player (Phase 2+)
        if (this.phase >= 2 && !this.bossCharging) {
            this.bossChargeTimer += delta;
            if (this.bossChargeTimer > 8000) {
                this.bossChargeTimer = 0;
                this.bossCharging = true;
                this.tweens.add({
                    targets: this.boss, angle: 5, duration: 150, yoyo: true, repeat: 3,
                    onComplete: () => {
                        const chargeTarget = this.player.x + 40;
                        this.tweens.add({
                            targets: this, bossX: chargeTarget, duration: 600, ease: 'Power2',
                            onComplete: () => {
                                this.tweens.add({
                                    targets: this, bossX: GW - 160, duration: 1200, ease: 'Power2',
                                    onComplete: () => { this.bossCharging = false; }
                                });
                            }
                        });
                    }
                });
            }
        }

        // Occasional jumps
        if (this.bossOnGround && Math.random() < 0.002 * this.phase) {
            this.bossOnGround = false;
            this.bossVelY = -6;
        }
        if (!this.bossOnGround) {
            this.bossVelY += 15 * dt;
            this.bossY += this.bossVelY;
            if (this.bossY >= this.bossBaseY) {
                this.bossY = this.bossBaseY;
                this.bossVelY = 0;
                this.bossOnGround = true;
            }
        }

        this.boss.setPosition(this.bossX, this.bossY);

        // Boss-player collision
        const colDx = Math.abs(this.bossX - this.player.x);
        if (colDx < 45) {
            const playerBottom = this.player.y + 20;
            const bossTop = this.bossY - 65;
            // Player falling down onto boss top = STOMP
            if (!this.playerOnGround && this.playerVelY > 0 && playerBottom >= bossTop && playerBottom <= bossTop + 30) {
                this.stompBoss();
            }
            // Side collision (player not above boss)
            else if (playerBottom > bossTop + 20 && this.player.y > this.bossY - 70) {
                this.hitPlayer();
            }
        }
    }

    updateBossParts(dt, delta) {
        if (this.isGameOver && !this.boss) return;

        // Idle arm animation (only when not doing a specific arm anim)
        if (!this.armThrowing && !this.bossStunned) {
            const t = this.time.now * 0.003;
            this.bossArmL.setAngle(Math.sin(t) * 10);
            this.bossArmR.setAngle(Math.sin(t + Math.PI * 0.7) * 10);
        }

        // Reset armThrowing when juggling tires are gone (and no active arm tweens)
        if (this.spinningTires.length === 0 && this.armThrowing && !this.bossStunned) {
            // Check if arm tweens are done using getTweensOf
            const armTweens = this.tweens.getTweensOf(this.bossArmR);
            if (armTweens.length === 0) {
                this.armThrowing = false;
                this.boss.setAngle(0); // reset body wobble from juggling
            }
        }

        // Show/hide interior based on lid angle (smooth transition)
        if (this.bossLid && this.bossInterior) {
            const lidAngle = this.bossLid.angle;
            // Interior visible when lid opens past -15 degrees
            const interiorAlpha = Math.min(1, Math.max(0, (-lidAngle - 15) / 30));
            this.bossInterior.setAlpha(interiorAlpha);
        }

        // Green glow on body when lid is open (visual hint: throw now!)
        if (this.bossLid && !this.isGameOver && !this.bossHurtFlash) {
            if (this.lidOpen) {
                this.bossInterior.setTint(0x44FF44); // green glow on interior
            } else {
                this.bossInterior.clearTint();
            }
        }
    }

    stompBoss() {
        if (this.bossStunned || this.isGameOver) return;
        // Player bounces off
        this.playerVelY = -10;
        this.playerOnGround = false;
        SndMgr.stomp();
        this.showFloatingText(this.bossX, this.bossY - 90, 'BOING!', '#FFAA00');

        // Drop spinning tires when stomped
        this.spinningTires.forEach(t => {
            t.timer = 0; // mark for removal
            // Tire falls to ground with bounce
            this.tweens.add({
                targets: t.sprite,
                y: GROUND_Y - 10,
                angle: t.sprite.angle + 360 + Math.random() * 360,
                duration: 600,
                ease: 'Bounce.easeOut',
                onComplete: () => { t.sprite.destroy(); }
            });
            this.tweens.add({
                targets: t.sprite,
                x: t.sprite.x + (Math.random() - 0.5) * 150,
                duration: 600,
                ease: 'Power2'
            });
        });
        this.spinningTires = [];

        // Boss gets squished for 3 seconds
        this.bossStunned = true;
        this.bossY = this.bossBaseY + 40; // push down to ground
        this.bossVelY = 0;
        this.bossOnGround = true;
        this.bossCharging = false;
        // Kill any active boss movement tweens
        this.tweens.killTweensOf(this);
        this.boss.setPosition(this.bossX, this.bossY);
        this.boss.setScale(1.3, 0.5); // squash flat
        this.cameras.main.shake(200, 0.02);

        // Lid forced open while stunned
        this.lidOpen = true;
        this.lidTargetAngle = -70;
        this.tweens.add({ targets: this.bossLid, angle: -70, duration: 200 });
        this.lidIndicator.setText('DECKEL AUF!');
        this.lidIndicator.setColor('#44FF44');

        // Arms wiggle frantically while stunned
        this.armThrowing = true; // prevent idle override
        this.stunWiggle = this.time.addEvent({ delay: 120, loop: true, callback: () => {
            if (this.boss && this.bossStunned) {
                const a = (Date.now() % 240 < 120) ? 20 : -20;
                this.bossArmL.setAngle(a);
                this.bossArmR.setAngle(-a);
            }
        }});

        // Recover after 3 seconds
        this.time.delayedCall(3000, () => {
            if (this.isGameOver) return;
            this.bossStunned = false;
            this.armThrowing = false;
            if (this.stunWiggle) { this.stunWiggle.destroy(); this.stunWiggle = null; }
            this.boss.setAngle(0);
            this.bossY = this.bossBaseY;
            this.bossVelY = 0;
            this.bossOnGround = true;
            this.bossCharging = false;
            this.boss.setScale(1, 1);
            this.boss.setPosition(this.bossX, this.bossY);
            this.lidOpen = false;
            this.lidTargetAngle = 0;
            this.tweens.add({ targets: this.bossLid, angle: 0, duration: 300, ease: 'Bounce.easeOut' });
            this.lidTimer = this.phaseConfig[this.phase].closeTime;
            this.lidIndicator.setText('DECKEL ZU');
            this.lidIndicator.setColor('#FF4444');
            SndMgr.bossAngry();
        });
    }

    updateLid(delta) {
        if (this.bossStunned) return; // lid forced open during stun
        const cfg = this.phaseConfig[this.phase];
        this.lidTimer -= delta;

        if (this.lidOpen) {
            if (this.lidTimer <= 0) {
                this.lidOpen = false;
                this.lidTimer = cfg.closeTime;
                this.lidWarning = false;
                this.lidTargetAngle = 0;
                // Smooth lid close with bounce
                this.tweens.add({ targets: this.bossLid, angle: 0, duration: 300, ease: 'Bounce.easeOut' });
                this.lidIndicator.setText('DECKEL ZU');
                this.lidIndicator.setColor('#FF4444');
            }
        } else {
            // Warning before opening - lid chatters/rattles
            if (this.lidTimer <= 500 && !this.lidWarning) {
                this.lidWarning = true;
                // Lid rattles as warning (small angle oscillation)
                this.tweens.add({ targets: this.bossLid, angle: -8, duration: 60, yoyo: true, repeat: 5, ease: 'Sine.easeInOut' });
                // Body wobbles slightly too
                this.tweens.add({ targets: this.boss, angle: 2, duration: 80, yoyo: true, repeat: 3 });
            }
            if (this.lidTimer <= 0) {
                this.lidOpen = true;
                this.lidTimer = cfg.openTime;
                this.lidTargetAngle = -70;
                // Smooth lid open with spring
                this.tweens.add({ targets: this.bossLid, angle: -70, duration: 250, ease: 'Back.easeOut' });
                this.lidIndicator.setText('DECKEL AUF!');
                this.lidIndicator.setColor('#44FF44');
            }
        }
    }

    updateAttacks(dt, delta) {
        if (this.bossStunned) return; // no attacks while stunned
        const cfg = this.phaseConfig[this.phase];
        this.specialTimer += delta;

        // No normal attacks while juggling tires; only attack when lid is open
        if (this.spinningTires.length === 0) {
            if (this.lidOpen) {
                this.attackTimer += delta;
                if (this.attackTimer >= cfg.attackInterval) {
                    this.attackTimer = 0;
                    this.bossAttack();
                    if (this.phase === 3 && Math.random() < 0.4) {
                        this.time.delayedCall(300, () => this.bossAttack());
                    }
                }
            }
        } else {
            // Juggling animation - arms do circular motion, body wobbles slightly
            const t = Date.now() * 0.006;
            this.bossArmL.setAngle(-30 + Math.sin(t) * 25);
            this.bossArmR.setAngle(-30 + Math.sin(t + Math.PI) * 25);
            this.boss.setAngle(Math.sin(t * 0.5) * 3);
            this.armThrowing = true; // prevent idle override
        }

        // Special attacks per phase (every 8-12 seconds)
        const specialInterval = 10000 - this.phase * 1000;
        if (this.specialTimer >= specialInterval) {
            this.specialTimer = 0;
            this.bossSpecialAttack();
        }
    }

    bossSpecialAttack() {
        if (this.isGameOver) return;
        SndMgr.bossAngry();
        this.cameras.main.shake(200, 0.015);

        // Force lid open for special attacks (boss opens wide to attack)
        this.lidOpen = true;
        this.lidTargetAngle = -70;
        this.tweens.add({ targets: this.bossLid, angle: -70, duration: 200, ease: 'Back.easeOut' });

        // Warning: boss wobbles + arms reach up
        this.tweens.add({
            targets: this.boss,
            angle: 8, scaleX: 1.15,
            duration: 100, yoyo: true, repeat: 4, ease: 'Sine.easeInOut'
        });
        // Arms reach up during special
        this.armThrowing = true;
        this.tweens.add({ targets: this.bossArmL, angle: -50, duration: 200 });
        this.tweens.add({ targets: this.bossArmR, angle: -50, duration: 200 });

        this.time.delayedCall(500, () => {
            if (this.isGameOver) return;

            if (this.phase >= 1) {
                // PHASE 1 SPECIAL: Müll-Salve - 8 projectiles in all directions
                const count = 6 + this.phase * 2;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const speed = 150 + Math.random() * 80;
                    const pool = ['throw_banana', 'throw_apple', 'throw_eggshell'];
                    const texKey = pool[Math.floor(Math.random() * pool.length)];
                    const sprite = this.add.image(this.bossX, this.bossY - 30, texKey).setDepth(15);
                    this.projectiles.push({
                        sprite, x: this.bossX, y: this.bossY - 30,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 100,
                        gravity: 250, type: texKey, hit: false
                    });
                }
                this.showFloatingText(this.bossX, this.bossY - 90, 'MÜLL-SALVE!', '#FF8800');
            }

            if (this.phase >= 2) {
                // PHASE 2 SPECIAL: Liquid wave - 5 liquid blobs raining down
                for (let i = 0; i < 5; i++) {
                    this.time.delayedCall(i * 200, () => {
                        if (this.isGameOver) return;
                        const tx = 80 + Math.random() * (GW - 160);
                        const sprite = this.add.image(tx, -20, 'throw_liquid').setDepth(15);
                        this.projectiles.push({
                            sprite, x: tx, y: -20,
                            vx: (Math.random() - 0.5) * 40,
                            vy: 60, gravity: 300,
                            type: 'throw_liquid', hit: false, makePuddle: true
                        });
                    });
                }
                this.showFloatingText(this.bossX, this.bossY - 110, 'GIFT-REGEN!', '#44FF44');
            }

            if (this.phase >= 3) {
                // PHASE 3 SPECIAL: 3 tires spinning in a circle around the boss
                const tireCount = 3;
                for (let i = 0; i < tireCount; i++) {
                    const startAngle = (i / tireCount) * Math.PI * 2;
                    const sprite = this.add.image(this.bossX, this.bossY, 'throw_tire').setDepth(15);
                    this.spinningTires.push({
                        sprite, angle: startAngle, radius: 60,
                        expandTo: 180, speed: 2.5, timer: 5000,
                        cx: this.bossX, cy: this.bossY - 20
                    });
                }
                this.showFloatingText(this.bossX, this.bossY - 130, 'REIFEN-TORNADO!', '#FF4444');
            }

            // Arms swing forward (throwing motion) then reset
            this.tweens.add({ targets: this.bossArmL, angle: 30, duration: 150, yoyo: true,
                onComplete: () => { this.armThrowing = false; } });
            this.tweens.add({ targets: this.bossArmR, angle: 30, duration: 150, yoyo: true });
        });
    }

    bossAttack() {
        if (this.isGameOver) return;
        if (!this.lidOpen) return; // Can only throw when lid is open!

        // Throw animation: arm reaches into lid, then swings forward
        SndMgr.bossThrow();
        this.armThrowing = true;
        // Right arm reaches up into trash (negative angle = up)
        this.tweens.add({
            targets: this.bossArmR, angle: -55, duration: 100,
            onComplete: () => {
                // Arm swings forward to throw
                this.tweens.add({
                    targets: this.bossArmR, angle: 35, duration: 120,
                    onComplete: () => { this.armThrowing = false; }
                });
            }
        });
        // Body wobbles slightly
        this.tweens.add({ targets: this.boss, angle: -5, duration: 100, yoyo: true });

        // Choose projectile based on phase
        const phase1 = ['throw_banana', 'throw_apple', 'throw_eggshell'];
        const phase2 = [...phase1, 'throw_shoe', 'throw_fishbone'];
        const phase3 = [...phase2, 'throw_trashbag', 'throw_paintcan', 'throw_toiletseat'];
        const pool = this.phase === 1 ? phase1 : this.phase === 2 ? phase2 : phase3;
        const texKey = pool[Math.floor(Math.random() * pool.length)];

        const speeds = { 1: 180, 2: 250, 3: 320 };
        const speed = speeds[this.phase] + Math.random() * 50;

        const sprite = this.add.image(this.bossX - 30, this.bossY - 20, texKey).setDepth(15);

        // Aim at player with some spread
        const dx = this.player.x - this.bossX;
        const dy = (this.player.y - 20) - this.bossY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const spread = (Math.random() - 0.5) * 0.3;

        this.projectiles.push({
            sprite: sprite,
            x: this.bossX - 30,
            y: this.bossY - 20,
            vx: (dx / dist) * speed + spread * speed,
            vy: -200 + Math.random() * 50,
            gravity: 350,
            type: texKey,
            hit: false
        });
    }

    updateProjectiles(dt) {
        this.projectiles = this.projectiles.filter(p => {
            p.vy += p.gravity * dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.sprite.setPosition(p.x, p.y);
            p.sprite.setRotation(p.sprite.rotation + dt * 3);

            // Off screen
            if (p.y > GH + 50 || p.x < -50 || p.x > GW + 50) {
                p.sprite.destroy();
                return false;
            }

            // Hit ground - special effects
            if (p.y >= GROUND_Y - 5 && !p.hit) {
                p.hit = true;
                if (p.type === 'throw_fishbone') {
                    const cloud = this.add.image(p.x, GROUND_Y - 20, 'stink_cloud').setDepth(8).setAlpha(0.7);
                    this.groundEffects.push({ sprite: cloud, timer: 3000, maxTimer: 3000, x: p.x, type: 'stink' });
                } else if (p.type === 'throw_paintcan') {
                    const splash = this.add.image(p.x, GROUND_Y - 5, 'paint_splash').setDepth(3).setAlpha(0.8);
                    this.groundEffects.push({ sprite: splash, timer: 5000, maxTimer: 5000, x: p.x, type: 'paint' });
                } else if (p.type === 'throw_liquid' && p.makePuddle) {
                    const puddle = this.add.image(p.x, GROUND_Y - 3, 'liquid_puddle').setDepth(3).setAlpha(0.8);
                    this.groundEffects.push({ sprite: puddle, timer: 4000, maxTimer: 4000, x: p.x, type: 'liquid' });
                }
                p.sprite.destroy();
                return false;
            }

            // Hit player
            if (!p.hit && Math.abs(p.x - this.player.x) < 25 && Math.abs(p.y - this.player.y) < 35) {
                p.hit = true;
                this.hitPlayer();
                p.sprite.destroy();
                return false;
            }

            return true;
        });

        // Ground effect collision with player
        this.groundEffects.forEach(e => {
            if ((e.type === 'liquid' || e.type === 'paint') && Math.abs(e.x - this.player.x) < 25 && this.playerOnGround) {
                this.hitPlayer();
            }
        });
    }

    updatePlayerBags(dt) {
        this.playerBags = this.playerBags.filter(b => {
            b.vy += b.gravity * dt;
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            b.sprite.setPosition(b.x, b.y);
            b.sprite.setRotation(b.sprite.rotation + dt * 5);

            // Hit ground - bag becomes pickup
            if (b.y >= GROUND_Y - 8) {
                b.sprite.destroy();
                this.spawnGroundBag(Phaser.Math.Clamp(b.x, 30, GW - 30));
                return false;
            }

            // Off screen sides
            if (b.x > GW + 50 || b.x < -50) {
                b.sprite.destroy();
                return false;
            }

            // Blocked by spinning tires
            let blockedByTire = false;
            this.spinningTires.forEach(t => {
                const tx = t.cx + Math.cos(t.angle) * t.radius;
                const ty = t.cy + Math.sin(t.angle) * t.radius * 0.4;
                if (Math.abs(b.x - tx) < 25 && Math.abs(b.y - ty) < 25) {
                    blockedByTire = true;
                }
            });
            if (blockedByTire) {
                b.sprite.destroy();
                SndMgr.bonk();
                this.showFloatingText(b.x, b.y - 20, 'BLOCKED!', '#FF8800');
                this.spawnGroundBag(Phaser.Math.Clamp(b.x, 30, GW - 30));
                return false;
            }

            // Hit boss area
            if (Math.abs(b.x - this.bossX) < 45 && Math.abs(b.y - this.bossY) < 60) {
                b.sprite.destroy();
                if (this.lidOpen) {
                    // HIT! Bag goes in
                    this.bossHP = Math.min(100, this.bossHP + this.bagHitPercent);
                    SndMgr.bossHurt();
                    this.showFloatingText(this.bossX, this.bossY - 70, 'TREFFER!', '#44FF44');
                    const splat = this.add.image(this.bossX, this.bossY - 30, 'bag_splat').setDepth(15);
                    this.tweens.add({ targets: splat, alpha: 0, scaleX: 1.5, scaleY: 1.5, duration: 400, onComplete: () => splat.destroy() });
                    // Flash all parts white/red for hurt
                    this.bossHurtFlash = true;
                    [this.bossBody, this.bossArmL, this.bossArmR, this.bossLid].forEach(p => p.setTint(0xFF6666));
                    this.tweens.add({ targets: this.boss, scaleX: 1.15, scaleY: 0.9, duration: 80, yoyo: true });
                    this.time.delayedCall(300, () => {
                        this.bossHurtFlash = false;
                        if (this.boss && !this.isGameOver) {
                            [this.bossBody, this.bossArmL, this.bossArmR, this.bossLid].forEach(p => p.clearTint());
                        }
                    });
                } else {
                    // MISS! Bounces off → lands on ground as pickup
                    SndMgr.bonk();
                    this.showFloatingText(this.bossX, this.bossY - 70, 'BONK!', '#FF4444');
                    const landX = this.bossX - 40 - Math.random() * 100;
                    this.spawnGroundBag(Phaser.Math.Clamp(landX, 30, GW - 30));
                }
                return false;
            }

            return true;
        });
    }

    hitPlayer() {
        if (this.invincible || this.isGameOver) return;
        this.lives--;
        SndMgr.playerHit();
        this.cameras.main.shake(300, 0.02);
        this.showFloatingText(this.player.x, this.player.y - 30, 'AUTSCH!', '#FF4444');

        // Update hearts
        for (let i = 0; i < 3; i++) {
            this.heartTexts[i].setAlpha(i < this.lives ? 1 : 0.2);
        }

        // Invincibility frames
        this.invincible = true;
        const blink = this.time.addEvent({ delay: 100, repeat: 15, callback: () => {
            if (this.player) this.player.setAlpha(this.player.alpha === 1 ? 0.3 : 1);
        }});
        this.time.delayedCall(1600, () => {
            this.invincible = false;
            if (this.player) this.player.setAlpha(1);
        });
    }

    spawnGroundBag(x) {
        const sprite = this.add.image(x, GROUND_Y - 8, 'bag_ground').setDepth(6);
        // Little bounce-in animation
        sprite.y = GROUND_Y - 30;
        this.tweens.add({ targets: sprite, y: GROUND_Y - 8, duration: 300, ease: 'Bounce.easeOut' });
        this.groundBags.push({ sprite, x });
    }

    collectGroundBag() {
        if (this.isGameOver || this.collectCooldown > 0) return;
        // Find nearest ground bag within range
        let nearest = null, nearDist = 60;
        this.groundBags.forEach(b => {
            const d = Math.abs(b.x - this.player.x);
            if (d < nearDist) { nearest = b; nearDist = d; }
        });
        if (nearest) {
            this.collectCooldown = 400;
            nearest.sprite.destroy();
            this.groundBags = this.groundBags.filter(b => b !== nearest);
            this.bagsLeft++;
            SndMgr.collect();
            this.showFloatingText(nearest.x, GROUND_Y - 30, '+1', '#88DD88');
        }
    }

    updateGroundBags() {
        // Ground bags just sit there, no auto-pickup
    }

    updateSpinningTires(dt, delta) {
        this.spinningTires = this.spinningTires.filter(t => {
            t.timer -= delta;
            if (t.timer <= 0) { t.sprite.destroy(); return false; }

            // Expand radius over time
            if (t.radius < t.expandTo) t.radius += 80 * dt;
            t.angle += t.speed * dt;
            t.cx += (this.bossX - t.cx) * 2 * dt; // follow boss loosely

            const tx = t.cx + Math.cos(t.angle) * t.radius;
            const ty = t.cy + Math.sin(t.angle) * t.radius * 0.4; // elliptical
            t.sprite.setPosition(tx, ty);
            t.sprite.setRotation(t.sprite.rotation + dt * 8);

            // Fade out near end
            if (t.timer < 1000) t.sprite.setAlpha(t.timer / 1000);

            // Hit player
            if (Math.abs(tx - this.player.x) < 25 && Math.abs(ty - this.player.y) < 30) {
                this.hitPlayer();
            }

            return true;
        });
    }

    bossVictory() {
        if (this.isGameOver) return;
        this.isGameOver = true;
        SndMgr.stopMusic();

        // Lid slams shut (can is FULL!)
        this.tweens.add({ targets: this.bossLid, angle: 0, duration: 150, ease: 'Power3' });

        // Phase 1: Boss wobbles nervously
        this.tweens.add({
            targets: this.boss, angle: 5, duration: 100, yoyo: true, repeat: 5,
            onComplete: () => {
                // Phase 2: Boss turns red and swells up
                [this.bossBody, this.bossArmL, this.bossArmR, this.bossLid].forEach(p => p.setTint(0xFF4444));
                // Arms flail in panic
                this.tweens.add({ targets: this.bossArmL, angle: -40, duration: 150, yoyo: true, repeat: 8 });
                this.tweens.add({ targets: this.bossArmR, angle: -40, duration: 180, yoyo: true, repeat: 7 });
                // Lid rattles - trying to contain the pressure
                this.tweens.add({ targets: this.bossLid, angle: -10, duration: 80, yoyo: true, repeat: 12 });

                this.tweens.add({
                    targets: this.boss, scaleX: 1.4, scaleY: 1.3,
                    duration: 1500, ease: 'Sine.easeIn',
                    onUpdate: (tween) => {
                        // Wobble increases as it swells
                        const p = tween.progress;
                        this.boss.setAngle(Math.sin(Date.now() * 0.02) * (3 + p * 12));
                        // Color goes from red to bright red/white
                        if (p > 0.5) {
                            const flash = Math.sin(Date.now() * 0.03) > 0;
                            [this.bossBody, this.bossLid].forEach(s =>
                                s.setTint(flash ? 0xFFAAAA : 0xFF2222)
                            );
                        }
                    },
                    onComplete: () => {
                        // Phase 3: Swell even more (about to burst!)
                        SndMgr.bossAngry();
                        this.cameras.main.shake(300, 0.02);
                        this.tweens.add({
                            targets: this.boss, scaleX: 1.8, scaleY: 1.6,
                            duration: 800, ease: 'Quad.easeIn',
                            onUpdate: () => {
                                this.boss.setAngle(Math.sin(Date.now() * 0.04) * 15);
                                // Rapid flashing
                                const flash = Date.now() % 100 < 50;
                                [this.bossBody, this.bossArmL, this.bossArmR, this.bossLid].forEach(s =>
                                    s.setTint(flash ? 0xFFFFFF : 0xFF0000)
                                );
                            },
                            onComplete: () => {
                                // Phase 4: EXPLOSION!
                                SndMgr.bossDefeat();
                                this.cameras.main.shake(600, 0.05);
                                this.cameras.main.flash(300, 255, 200, 100);

                                // Hide composite parts, show defeat body
                                this.bossArmL.setVisible(false);
                                this.bossArmR.setVisible(false);
                                this.bossLid.setVisible(false);
                                this.bossInterior.setVisible(false);
                                this.bossBody.setTexture('boss_tonne_defeat');
                                this.bossBody.clearTint();
                                this.boss.setAngle(0);
                                this.boss.setScale(1.5);

                                // Boss shrinks away after explosion
                                this.tweens.add({
                                    targets: this.boss, scaleX: 0, scaleY: 0, alpha: 0,
                                    duration: 1000, delay: 500, ease: 'Power2'
                                });

                                // Lots of confetti!
                                for (let i = 0; i < 50; i++) {
                                    const cx = this.bossX + (Math.random() - 0.5) * 80;
                                    const cy = this.bossY + (Math.random() - 0.5) * 80;
                                    const size = 4 + Math.random() * 8;
                                    const conf = this.add.rectangle(cx, cy, size, size * 0.6,
                                        [0xFF4444, 0x44AAFF, 0xFFDD00, 0x44DD44, 0xFF88FF, 0xFFAA00, 0xFF8800][Math.floor(Math.random()*7)]
                                    ).setDepth(50).setAngle(Math.random() * 360);
                                    this.tweens.add({
                                        targets: conf,
                                        x: cx + (Math.random() - 0.5) * 400,
                                        y: cy - 150 - Math.random() * 250,
                                        angle: Math.random() * 1080,
                                        alpha: 0,
                                        duration: 2000 + Math.random() * 1500,
                                        ease: 'Power1'
                                    });
                                }

                                // Trash pieces fly out
                                const trashKeys = ['throw_banana', 'throw_shoe', 'throw_apple', 'throw_eggshell', 'throw_fishbone'];
                                for (let i = 0; i < 8; i++) {
                                    const t = this.add.image(this.bossX, this.bossY,
                                        trashKeys[Math.floor(Math.random() * trashKeys.length)]
                                    ).setDepth(45);
                                    const ang = (i / 8) * Math.PI * 2;
                                    this.tweens.add({
                                        targets: t,
                                        x: this.bossX + Math.cos(ang) * (200 + Math.random() * 150),
                                        y: this.bossY + Math.sin(ang) * 150 - 100,
                                        angle: Math.random() * 720,
                                        alpha: 0,
                                        duration: 1500 + Math.random() * 500,
                                        ease: 'Power2'
                                    });
                                }

                                // Victory text (delayed so explosion is visible)
                                this.time.delayedCall(1500, () => {
                                    const bg = this.add.rectangle(GW/2, GH/2, GW, GH, 0x000000, 0.6).setDepth(200);
                                    const victText = this.add.text(GW/2, GH/2 - 80, 'BOSS BESIEGT!', {
                                        fontFamily: 'monospace', fontSize: '36px', color: '#FFD700',
                                        stroke: '#000', strokeThickness: 4
                                    }).setOrigin(0.5).setDepth(201);
                                    this.tweens.add({ targets: victText, scaleX: 1.2, scaleY: 1.2, duration: 300, yoyo: true, repeat: 1 });

                                    let bonusMoney = 20;
                                    let lines = [`+${bonusMoney}€ Bonus-Taschengeld!`];

                                    // Easter egg: exactly 0 bags left
                                    if (this.bagsLeft === 0) {
                                        lines.push('');
                                        lines.push('Knapp daneben ist auch dabei!');
                                        lines.push('+10€ Extra-Bonus!');
                                        bonusMoney += 10;
                                    }

                                    this.add.text(GW/2, GH/2 - 20, lines.join('\n'), {
                                        fontFamily: 'monospace', fontSize: '16px', color: '#FFDD00',
                                        align: 'center', stroke: '#333', strokeThickness: 2
                                    }).setOrigin(0.5).setDepth(201);

                                    const btnNext = this.add.text(GW/2, GH/2 + 60, '  WEITER!  ', {
                                        fontFamily: 'monospace', fontSize: '22px', color: '#FFF',
                                        backgroundColor: '#44AA44', padding: { x: 16, y: 8 }
                                    }).setOrigin(0.5).setDepth(201).setInteractive({ useHandCursor: true });
                                    btnNext.on('pointerdown', () => {
                                        SndMgr.click();
                                        this.scene.start('Game', {
                                            level: this.levelNum + 1,
                                            money: this.money + bonusMoney
                                        });
                                    });
                                    btnNext.on('pointerover', () => btnNext.setScale(1.1));
                                    btnNext.on('pointerout', () => btnNext.setScale(1));
                                });
                            }
                        });
                    }
                });
            }
        });
    }

    bossDefeat() {
        if (this.isGameOver) return;
        this.isGameOver = true;
        SndMgr.stopMusic();
        SndMgr.sad();

        // Boss laughs (lid claps open/closed like a laughing mouth, arms wave)
        let laughOpen = false;
        const laughAnim = this.time.addEvent({ delay: 250, repeat: 8, callback: () => {
            if (this.bossLid) {
                laughOpen = !laughOpen;
                this.tweens.add({ targets: this.bossLid, angle: laughOpen ? -50 : 0, duration: 120 });
                // Arms wave with laughter
                this.bossArmL.setAngle(laughOpen ? -25 : 15);
                this.bossArmR.setAngle(laughOpen ? -25 : 15);
            }
        }});

        this.time.delayedCall(1200, () => {
            const bg = this.add.rectangle(GW/2, GH/2, GW, GH, 0x000000, 0.7).setDepth(200);

            this.add.text(GW/2, GH/2 - 60, 'Die Tonne hat gewonnen!', {
                fontFamily: 'monospace', fontSize: '24px', color: '#FF4444',
                stroke: '#000', strokeThickness: 3
            }).setOrigin(0.5).setDepth(201);

            const btnRetry = this.add.text(GW/2, GH/2 + 10, '  NOCHMAL!  ', {
                fontFamily: 'monospace', fontSize: '18px', color: '#FFF',
                backgroundColor: '#CC8800', padding: { x: 16, y: 8 }
            }).setOrigin(0.5).setDepth(201).setInteractive({ useHandCursor: true });
            btnRetry.on('pointerdown', () => {
                SndMgr.click();
                this.scene.start('Boss', {
                    level: this.levelNum,
                    bags: this.bags, // original bag count
                    money: this.money
                });
            });
            btnRetry.on('pointerover', () => btnRetry.setScale(1.1));
            btnRetry.on('pointerout', () => btnRetry.setScale(1));

            const btnMenu = this.add.text(GW/2, GH/2 + 60, '  ZURÜCK ZUM MENÜ  ', {
                fontFamily: 'monospace', fontSize: '14px', color: '#FFF',
                backgroundColor: '#666', padding: { x: 12, y: 6 }
            }).setOrigin(0.5).setDepth(201).setInteractive({ useHandCursor: true });
            btnMenu.on('pointerdown', () => {
                SndMgr.click();
                this.scene.start('Menu');
            });
            btnMenu.on('pointerover', () => btnMenu.setScale(1.1));
            btnMenu.on('pointerout', () => btnMenu.setScale(1));
        });
    }

    showFloatingText(x, y, text, color) {
        const t = this.add.text(x, y, text, {
            fontFamily: 'monospace', fontSize: '16px', color: color,
            stroke: '#000', strokeThickness: 2
        }).setOrigin(0.5).setDepth(50);
        this.tweens.add({ targets: t, y: y - 40, alpha: 0, duration: 800, ease: 'Power2', onComplete: () => t.destroy() });
    }
}

// === GAME OVER SCENE ===
class GameOverScene extends Phaser.Scene {
    constructor() { super('GameOver'); }
    init(data) { this.data = data; }
    create() {
        const d = this.data;
        const isPrison = d.tickets >= 3;

        if (isPrison) {
            this.cameras.main.setBackgroundColor(0x111122);
        } else {
            this.cameras.main.setBackgroundColor(0x331111);
        }

        const title = isPrison ? 'AB INS GEFÄNGNIS!' : 'GAME OVER';
        const titleColor = isPrison ? '#8888FF' : '#FF4444';
        const subtitle = isPrison
            ? '3 Strafzettel! Das Ordnungsamt hat dich eingebuchtet!'
            : d.lives <= 0
                ? 'Keine Leben mehr!'
                : GAMEOVER_TEXTS[Math.floor(Math.random() * GAMEOVER_TEXTS.length)];

        this.add.text(GW/2, 50, title, { fontFamily: 'monospace', fontSize: '36px', color: titleColor, stroke: '#000', strokeThickness: 4 }).setOrigin(0.5);
        this.add.text(GW/2, 95, subtitle, { fontFamily: 'monospace', fontSize: '14px', color: '#FFAA44', wordWrap: { width: 600 }, align: 'center' }).setOrigin(0.5);

        // Visual
        if (isPrison) {
            // Prison bars
            for (let i = 0; i < 8; i++) {
                this.add.rectangle(GW/2 - 80 + i * 24, 180, 4, 100, 0x888888).setDepth(5);
            }
            this.add.image(GW/2, 190, 'boy_run_0').setScale(0.8).setDepth(3);
            this.add.image(GW/2 + 50, 180, 'ordnungsamt').setScale(0.7).setDepth(1);
        } else {
            this.add.image(GW/2, 190, 'boy_run_0').setScale(0.8);
            for (let i = 0; i < 6; i++) {
                this.add.image(GW/2 + Phaser.Math.Between(-100, 100), 220 + Phaser.Math.Between(-20, 20), 'poop_small').setScale(0.8);
            }
        }

        const stats = [
            `Level: ${d.level}`,
            `Haufen gesammelt: ${d.poopsCollected}`,
            `Haufen liegen gelassen: ${d.poopsMissed}`,
            `Strafzettel: ${d.tickets}/3`,
            `Leben: ${d.lives}/3`,
            `Taschengeld: ${d.money}€`,
        ];
        this.add.text(GW/2, 275, stats.join('\n'),
            { fontFamily: 'monospace', fontSize: '14px', color: '#FFFFFF', align: 'center', lineSpacing: 5 }).setOrigin(0.5);

        // Highscore check
        const save = SaveMgr.load();
        const isHighscore = save.highscores.length < 10 || d.money > (save.highscores[save.highscores.length - 1]?.money || 0);

        if (isHighscore && d.money > 0) {
            this.add.text(GW/2, 370, 'NEUER HIGHSCORE! Name eingeben:',
                { fontFamily: 'monospace', fontSize: '14px', color: '#FFDD00' }).setOrigin(0.5);
            this.nameInput = '';
            this.nameText = this.add.text(GW/2, 395, '___',
                { fontFamily: 'monospace', fontSize: '22px', color: '#FFFFFF' }).setOrigin(0.5);

            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const letterBtns = [];
            for (let i = 0; i < 26; i++) {
                const l = letters[i];
                const bx = 120 + (i % 13) * 44;
                const by = 420 + Math.floor(i / 13) * 30;
                const btn = this.add.text(bx, by, l,
                    { fontFamily: 'monospace', fontSize: '16px', color: '#FFF', backgroundColor: '#555', padding: { x: 8, y: 4 } }).setInteractive({ useHandCursor: true });
                btn.on('pointerdown', () => {
                    if (this.nameInput.length < 8) {
                        this.nameInput += l;
                        this.nameText.setText(this.nameInput + '_'.repeat(Math.max(0, 3 - this.nameInput.length)));
                        SndMgr.click();
                    }
                });
                letterBtns.push(btn);
            }

            const btnOK = this.add.text(GW/2, 485, '  OK  ',
                { fontFamily: 'monospace', fontSize: '18px', color: '#FFF', backgroundColor: '#44AA44', padding: { x: 16, y: 6 } }).setOrigin(0.5).setInteractive({ useHandCursor: true });
            btnOK.on('pointerdown', () => {
                const name = this.nameInput || 'ANON';
                SaveMgr.addHighscore(save, { name, money: d.money, level: d.level, poops: d.poopsCollected });
                SndMgr.click();
                letterBtns.forEach(b => b.destroy());
                btnOK.destroy();
                this.nameText.setText(name + ' gespeichert!');
                this.showButtons();
            });
        } else {
            this.showButtons();
        }
    }

    showButtons() {
        const btnStyle = { fontFamily: 'monospace', fontSize: '20px', color: '#FFFFFF', padding: { x: 16, y: 8 } };
        const btnRetry = this.add.text(GW/2 - 100, 470, 'NOCHMAL!', { ...btnStyle, backgroundColor: '#44AA44' }).setOrigin(0.5).setInteractive({ useHandCursor: true });
        const btnMenu = this.add.text(GW/2 + 100, 470, 'MENÜ', { ...btnStyle, backgroundColor: '#3377AA' }).setOrigin(0.5).setInteractive({ useHandCursor: true });

        btnRetry.on('pointerdown', () => { SndMgr.click(); this.scene.start('Game', { level: 1 }); });
        btnMenu.on('pointerdown', () => { SndMgr.click(); this.scene.start('Menu'); });
        [btnRetry, btnMenu].forEach(b => { b.on('pointerover', () => b.setScale(1.1)); b.on('pointerout', () => b.setScale(1)); });
    }
}

// === HIGHSCORE SCENE ===
class HighscoreScene extends Phaser.Scene {
    constructor() { super('Highscore'); }
    create() {
        this.cameras.main.setBackgroundColor(0x222244);
        const save = SaveMgr.load();

        this.add.text(GW/2, 30, 'HIGHSCORES', { fontFamily: 'monospace', fontSize: '30px', color: '#FFDD00', stroke: '#333', strokeThickness: 3 }).setOrigin(0.5);
        this.add.text(GW/2, 65, `Gesamt-Taschengeld: ${save.totalMoney}€`,
            { fontFamily: 'monospace', fontSize: '14px', color: '#AAAAFF' }).setOrigin(0.5);

        // Table header
        this.add.text(80, 100, '#', { fontFamily: 'monospace', fontSize: '14px', color: '#888' });
        this.add.text(120, 100, 'NAME', { fontFamily: 'monospace', fontSize: '14px', color: '#888' });
        this.add.text(320, 100, 'LEVEL', { fontFamily: 'monospace', fontSize: '14px', color: '#888' });
        this.add.text(430, 100, 'GELD', { fontFamily: 'monospace', fontSize: '14px', color: '#888' });
        this.add.text(540, 100, 'HAUFEN', { fontFamily: 'monospace', fontSize: '14px', color: '#888' });

        if (save.highscores.length === 0) {
            this.add.text(GW/2, 200, 'Noch keine Highscores!\nSpiel zuerst ein Spiel!',
                { fontFamily: 'monospace', fontSize: '16px', color: '#666', align: 'center' }).setOrigin(0.5);
        } else {
            save.highscores.forEach((hs, i) => {
                const y = 130 + i * 30;
                const col = i === 0 ? '#FFD700' : i === 1 ? '#C0C0C0' : i === 2 ? '#CD7F32' : '#FFFFFF';
                this.add.text(80, y, `${i+1}.`, { fontFamily: 'monospace', fontSize: '14px', color: col });
                this.add.text(120, y, hs.name, { fontFamily: 'monospace', fontSize: '14px', color: col });
                this.add.text(320, y, `${hs.level}`, { fontFamily: 'monospace', fontSize: '14px', color: col });
                this.add.text(430, y, `${hs.money}€`, { fontFamily: 'monospace', fontSize: '14px', color: col });
                this.add.text(540, y, `${hs.poops}`, { fontFamily: 'monospace', fontSize: '14px', color: col });
            });
        }

        const btnBack = this.add.text(GW/2, GH - 40, '  ZURÜCK  ',
            { fontFamily: 'monospace', fontSize: '20px', color: '#FFF', backgroundColor: '#555', padding: { x: 16, y: 8 } }).setOrigin(0.5).setInteractive({ useHandCursor: true });
        btnBack.on('pointerdown', () => { SndMgr.click(); this.scene.start('Menu'); });
        btnBack.on('pointerover', () => btnBack.setScale(1.1));
        btnBack.on('pointerout', () => btnBack.setScale(1));
    }
}

// === PHASER CONFIG ===
const config = {
    type: Phaser.AUTO,
    width: GW,
    height: GH,
    parent: 'game-container',
    pixelArt: false,
    roundPixels: false,
    backgroundColor: '#87CEEB',
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
    },
    scene: [BootScene, MenuScene, GameScene, BossScene, GameOverScene, HighscoreScene],
    input: {
        activePointers: 3,
    },
    audio: {
        disableWebAudio: true, // We use our own Web Audio
    },
};

const game = new Phaser.Game(config);

// Prevent iOS double-tap zoom and scrolling
document.addEventListener('touchstart', e => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
document.addEventListener('gesturestart', e => e.preventDefault());
document.addEventListener('gesturechange', e => e.preventDefault());

    </script>
</body>
</html>
